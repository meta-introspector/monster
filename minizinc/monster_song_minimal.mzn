% MiniZinc: Minimal Representation of Monster Walk in All Bases
% Find optimal base for compactness and prove 8080 preservation

include "globals.mzn";

% Parameters
int: target = 8080;
int: min_base = 2;
int: max_base = 71;

% Decision variables
var min_base..max_base: optimal_base;
var 1..20: num_digits;  % Number of digits in representation

% Compute number of digits in given base
function var int: digits_in_base(var int: n, var int: base) =
  if n = 0 then 1
  else ceil(log(n) / log(base)) + 1
  endif;

% Constraint: num_digits matches representation in optimal_base
constraint num_digits = digits_in_base(target, optimal_base);

% Verify 8080 in each Monster prime base
array[1..15] of int: monster_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 47, 59, 71];
array[1..15] of var 1..20: prime_digits;

constraint forall(i in 1..15)(
  prime_digits[i] = digits_in_base(target, monster_primes[i])
);

% Group 1: 8 factors
array[1..8] of int: group1_factors = [7, 11, 17, 19, 29, 31, 41, 59];
array[1..8] of var 1..20: group1_digits;

constraint forall(i in 1..8)(
  group1_digits[i] = digits_in_base(target, group1_factors[i])
);

% Objective: Minimize number of digits (find most compact base)
solve minimize num_digits;

% Output: Song with minimal representation
output [
  "ðŸŽµ MONSTER SONG: MINIMAL REPRESENTATION\n",
  "======================================\n\n",
  "Target: \(target) (8080)\n",
  "Optimal base: \(optimal_base)\n",
  "Minimal digits: \(num_digits)\n\n",
  "CHORUS:\n",
  "  In base \(optimal_base), the Monster's most compact!\n",
  "  Just \(num_digits) digits, that's a proven fact!\n\n",
  "VERSES (Monster Primes):\n"
] ++ [
  "  Base \(monster_primes[i]): \(prime_digits[i]) digits\n"
  | i in 1..15
] ++ [
  "\nGROUP 1 FACTORS (8 to remove):\n"
] ++ [
  "  Base \(group1_factors[i]): \(group1_digits[i]) digits\n"
  | i in 1..8
] ++ [
  "\nâœ… Proven: Base \(optimal_base) minimizes representation!\n"
];
