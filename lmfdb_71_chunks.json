[
  {
    "type": "function",
    "file": "lmfdb/number_fields/test_numberfield.py",
    "name": "test_abelian_conductor",
    "line_start": 19,
    "line_end": 20,
    "lines": 2,
    "bytes": 113,
    "has_71": true,
    "code": "    def test_abelian_conductor(self):\n        self.check_args('/NumberField/5.5.5719140625.2', '275') # conductor"
  },
  {
    "type": "function",
    "file": "lmfdb/hilbert_modular_forms/test_hmf.py",
    "name": "test_typo",
    "line_start": 26,
    "line_end": 28,
    "lines": 3,
    "bytes": 164,
    "has_71": true,
    "code": "    def test_typo(self): #771\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/?field_label=2.2.5.1')\n        assert 'Search again' in L.get_data(as_text=True)"
  },
  {
    "type": "function",
    "file": "lmfdb/abvar/fq/test_av.py",
    "name": "test_slopes",
    "line_start": 46,
    "line_end": 50,
    "lines": 5,
    "bytes": 168,
    "has_71": true,
    "code": "    def test_slopes(self):\n        r\"\"\"\n        Check that display_slopes works\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/2/71/ah_a\", \"[0, 1/2, 1/2, 1]\")"
  },
  {
    "type": "function",
    "file": "lmfdb/hilbert_modular_forms/test_hmf.py",
    "name": "test_large",
    "line_start": 30,
    "line_end": 32,
    "lines": 3,
    "bytes": 174,
    "has_71": true,
    "code": "    def test_large(self): #616\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/?field_label=4.4.2000.1&count=1200')\n        assert '719.2-c' in L.get_data(as_text=True)"
  },
  {
    "type": "function",
    "file": "lmfdb/utils/search_columns.py",
    "name": "display",
    "line_start": 309,
    "line_end": 316,
    "lines": 8,
    "bytes": 200,
    "has_71": true,
    "code": "    def display(self, rec):\n        ans = self.get(rec)\n        if ans > 0:\n            return \"&#x2713;\"\n        elif ans < 0:\n            return self.no\n        else:\n            return self.unknown"
  },
  {
    "type": "function",
    "file": "lmfdb/maass_forms/test_maass.py",
    "name": "test_search_all",
    "line_start": 29,
    "line_end": 31,
    "lines": 3,
    "bytes": 203,
    "has_71": true,
    "code": "    def test_search_all(self):\n        L = self.tc.get(\"/ModularForm/GL2/Q/Maass/?search_type=List&all=1\")\n        assert \"9.533695\" in L.get_data(as_text=True) and \"19.48471\" in L.get_data(as_text=True)"
  },
  {
    "type": "function",
    "file": "lmfdb/tests/test_utils.py",
    "name": "test_format_percentage",
    "line_start": 120,
    "line_end": 125,
    "lines": 6,
    "bytes": 236,
    "has_71": true,
    "code": "    def test_format_percentage(self):\n        r\"\"\"\n        Checking utility: format_percentage\n        \"\"\"\n        self.assertEqual(format_percentage(12,31), '     38.71')\n        self.assertEqual(format_percentage(12,37), '     32.43')"
  },
  {
    "type": "function",
    "file": "lmfdb/lattice/test_lattice.py",
    "name": "test_lattice_dim",
    "line_start": 11,
    "line_end": 15,
    "lines": 5,
    "bytes": 267,
    "has_71": true,
    "code": "    def test_lattice_dim(self):\n        L = self.tc.get(\"/Lattice/9.8.16.1.1\").get_data(as_text=True)\n        assert '115712' in L #coeff in theta series\n        assert '1.58740105196819947475170563927' in L #Hermite number\n        assert '11612160' in L #group order"
  },
  {
    "type": "class",
    "file": "lmfdb/utils/color.py",
    "name": "Original",
    "line_start": 316,
    "line_end": 326,
    "lines": 11,
    "bytes": 269,
    "has_71": true,
    "code": "class Original(ColorScheme):\n    code = 0\n    col_main_d  = '#040'\n    col_main_dl = '#060'\n    col_main    = '#157715'\n    col_main_2  = '#afa'\n    col_main_l  = '#bfb'\n    col_main_b  = '#cfc'\n    col_main_lg = '#8b8'\n    col_main_ld = '#dfd'\n    col_main_ll = '#efe'"
  },
  {
    "type": "function",
    "file": "lmfdb/abvar/fq/test_av.py",
    "name": "test_is_supersingular",
    "line_start": 39,
    "line_end": 44,
    "lines": 6,
    "bytes": 271,
    "has_71": true,
    "code": "    def test_is_supersingular(self):\n        r\"\"\"\n        Check that is_supersingular is computed correctly\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/2/7/a_a\", \">supersingular\")\n        self.check_args(\"/Variety/Abelian/Fq/2/71/ah_a\", \">not supersingular\")"
  },
  {
    "type": "function",
    "file": "lmfdb/utils/search_columns.py",
    "name": "display",
    "line_start": 288,
    "line_end": 295,
    "lines": 8,
    "bytes": 290,
    "has_71": true,
    "code": "    def display(self, rec):\n        val = self._get(rec, downloading=True) # We emulate downloading so that we can determine if the value is None\n        if val:\n            return \"&#x2713;\"\n        elif val is None:\n            return self.unknown\n        else:\n            return self.no"
  },
  {
    "type": "function",
    "file": "lmfdb/abvar/fq/test_browse_page.py",
    "name": "test_search_pointcountsav",
    "line_start": 172,
    "line_end": 177,
    "lines": 6,
    "bytes": 329,
    "has_71": true,
    "code": "    def test_search_pointcountsav(self):\n        r\"\"\"\n        Check that we can search by the point counts of the abelian variety\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/?abvar_point_count=%5B75%2C7125%5D\", \"2.9.ab_d\")\n        self.check_args(\"/Variety/Abelian/Fq/?abvar_point_count=%5B75%2C7125%5D\", \"2.9.ab_d\")"
  },
  {
    "type": "class",
    "file": "lmfdb/utils/color.py",
    "name": "RuddyBrowns",
    "line_start": 484,
    "line_end": 495,
    "lines": 12,
    "bytes": 340,
    "has_71": true,
    "code": "class RuddyBrowns(ColorScheme):\n    code = 2\n    col_main_ld = '#83614c'\n    col_main_dl = '#33261d'\n    col_main    = '#372820'\n    col_main_2  = '#443227'\n    col_main_l  = '#83614c'\n    col_main_lg = '#83614c'\n    col_main_ll = '#c39070'\n    col_main_d  = '#33261d'\n    col_main_g  = '#474' # Not very visible\n    grey        = '#771307'"
  },
  {
    "type": "function",
    "file": "lmfdb/genus2_curves/test_genus2_curves.py",
    "name": "test_twist_link",
    "line_start": 51,
    "line_end": 60,
    "lines": 10,
    "bytes": 355,
    "has_71": true,
    "code": "    def test_twist_link(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?g22=1016576&g20=5071050752/9&g21=195344320/9\")\n        for label in [\n            \"576.b.147456.1\",\n            \"1152.a.147456.1\",\n            \"2304.b.147456.1\",\n            \"4608.a.4608.1\",\n            \"4608.b.4608.1\",\n        ]:\n            assert label in L.get_data(as_text=True)"
  },
  {
    "type": "function",
    "file": "lmfdb/groups/abstract/test_browse_page.py",
    "name": "test_highlighted_character",
    "line_start": 593,
    "line_end": 598,
    "lines": 6,
    "bytes": 415,
    "has_71": true,
    "code": "    def test_highlighted_character(self):\n        r\"\"\"\n        Check that character links work\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/char_table/72.43?char_highlight=72.43.6a\", \"The row representing the character 72.43.6a is highlighted below.\")\n        self.check_args(\"/Groups/Abstract/Qchar_table/96.71?char_highlight=96.71.6a\", \"The row representing the character 96.71.6a is highlighted below.\")"
  },
  {
    "type": "function",
    "file": "lmfdb/lfunctions/test_lfunctions.py",
    "name": "test_Lgl3maass",
    "line_start": 319,
    "line_end": 324,
    "lines": 6,
    "bytes": 423,
    "has_71": true,
    "code": "    def test_Lgl3maass(self):\n        L = self.tc.get('/L/ModularForm/GL3/Q/Maass/1/1/20.39039_14.06890/-0.0742719/', follow_redirects=True)\n        assert '0.0742' in L.get_data(as_text=True)\n        assert '3-1-1.1-r0e3-p14.07p20.39m34.46-0' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/3/1/1.1/r0e3/p14.07p20.39m34.46/0/', follow_redirects=True)\n        assert '0.9615558824' in L.get_data(as_text=True)"
  },
  {
    "type": "function",
    "file": "lmfdb/number_fields/test_numberfield.py",
    "name": "test_split_ors",
    "line_start": 87,
    "line_end": 92,
    "lines": 6,
    "bytes": 556,
    "has_71": true,
    "code": "    def test_split_ors(self):\n        self.check_args('/NumberField/?signature=%5B0%2C3%5D&galois_group=S3', '6.0.177147.2')\n        self.check_args('/NumberField/?signature=%5B3%2C0%5D&galois_group=S3', '3.3.229.1')\n        self.check_args('/NumberField/?signature=[4%2C0]&galois_group=C2xC2&class_number=3%2C6','4.4.1311025.1')\n        self.check_args('/NumberField/?signature=[4%2C0]&galois_group=C2xC2&class_number=6%2C3','4.4.1311025.1')\n        self.check_args('/NumberField/?signature=[4%2C0]&galois_group=C2xC2&class_number=5-6%2C3','4.4.485809.1')"
  },
  {
    "type": "function",
    "file": "lmfdb/lfunctions/test_lfunctions.py",
    "name": "test_Lgl4maass",
    "line_start": 326,
    "line_end": 334,
    "lines": 9,
    "bytes": 609,
    "has_71": true,
    "code": "    def test_Lgl4maass(self):\n        L = self.tc.get('/L/ModularForm/GL4/Q/Maass/1/1/16.89972_2.272587_-6.03583/0.55659019/', follow_redirects=True)\n        assert '4-1-1.1-r0e4-p2.27m6.04m13.14p16.90-0' in L.get_data(as_text=True)\n        assert '0.556' in L.get_data(as_text=True)\n        assert 'Graph' in L.get_data(as_text=True)\n        assert '16.89972715592' in L.get_data(as_text=True)\n        assert '4-1-1.1-r0e4-p2.27m6.04m13.14p16.90-0' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/4/1/1.1/r0e4/p2.27m6.04m13.14p16.90/0/')\n        assert '16.18901597' in L.get_data(as_text=True)"
  },
  {
    "type": "function",
    "file": "lmfdb/modular_curves/test_modular_curves.py",
    "name": "test_GL2ZNZ_gens",
    "line_start": 145,
    "line_end": 156,
    "lines": 12,
    "bytes": 684,
    "has_71": true,
    "code": "    def test_GL2ZNZ_gens(self):\n        L = self.tc.get(\"/ModularCurve/Q/240.288.8-48.jt.2.31\",follow_redirects=True)\n        for matrix_gens in [\n            r\"$\\GL_2(\\Z/240\\Z)$-generators\",\n            r\"$\\begin{bmatrix}31&amp;54\\\\156&amp;217\\end{bmatrix}$\",\n            r\"$\\begin{bmatrix}110&amp;141\\\\191&amp;100\\end{bmatrix}$\",\n            r\"$\\begin{bmatrix}132&amp;227\\\\7&amp;168\\end{bmatrix}$\",\n            r\"$\\begin{bmatrix}164&amp;137\\\\171&amp;10\\end{bmatrix}$\",\n            r\"$\\begin{bmatrix}181&amp;150\\\\154&amp;113\\end{bmatrix}$\",\n            r\"$\\begin{bmatrix}191&amp;226\\\\34&amp;151\\end{bmatrix}$\"\n            ]:\n            assert matrix_gens in L.get_data(as_text=True)"
  },
  {
    "type": "function",
    "file": "lmfdb/abvar/fq/test_av.py",
    "name": "test_download_all",
    "line_start": 130,
    "line_end": 142,
    "lines": 13,
    "bytes": 688,
    "has_71": true,
    "code": "    def test_download_all(self):\n        r\"\"\"\n        Test downloading all stored data to text\n        \"\"\"\n\n        page = self.tc.get('Variety/Abelian/Fq/download_all/1.81.r', follow_redirects=True)\n        assert '\"abvar_counts\": [99, 6435, 532224, 43043715,' in page.get_data(as_text=True)\n\n        page = self.tc.get('Variety/Abelian/Fq/download_all/3.17.d_b_act', follow_redirects=True)\n        assert '\"curve_counts\": [21, 283, 4719, 84395' in page.get_data(as_text=True)\n\n        text = self.tc.get('Variety/Abelian/Fq/data/3.17.d_b_act', follow_redirects=True).get_data(as_text=True)\n        assert 'dim4_factors' in text and 'multiplicity' in text and 'brauer_invariants' in text"
  },
  {
    "type": "function",
    "file": "lmfdb/siegel_modular_forms/test_siegel_modular_forms.py",
    "name": "test_sample_page_Q",
    "line_start": 78,
    "line_end": 97,
    "lines": 20,
    "bytes": 734,
    "has_71": true,
    "code": "    def test_sample_page_Q(self):\n        \"\"\"\n        Test eigenvalue, Fourier coefficient, and modulus selection on a sample page with coefficient field Q\n        \"\"\"\n        self.check(\n            \"Sp4Z.24_E\",\n            [\"35184384671745\", \"19664276334286895123835070363311360\", \"...\"],\n        )\n        self.check(\n            \"Sp4Z.24_E?ev_index=19&fc_det=0&modulus=&update=1\",\n            [\n                \"3498743002442937227729601361394364486949008189359690164120\",\n                \"3398215376663749994606261280\",\n                \"(0, 0, 25)\",\n            ],\n        )\n        self.check(\n            \"Sp4Z.24_E/?ev_index=&fc_det=&modulus=1000000007&update=1\",\n            [\"384425457\", \"(1, 1, 1)\", \"384425457\"],\n        )"
  },
  {
    "type": "class",
    "file": "lmfdb/utils/search_columns.py",
    "name": "CheckCol",
    "line_start": 277,
    "line_end": 295,
    "lines": 19,
    "bytes": 754,
    "has_71": true,
    "code": "class CheckCol(SearchCol):\n    \"\"\"\n    Check columns are for boolean columns from the database.  They use a unicode check mark\n    to represent a True value, and question mark for unknown, and blank for False.\n    They are also centered by default.\n    \"\"\"\n    def __init__(self, name, knowl, title, align=\"center\", unknown=\"?\", no=\"\", **kwds):\n        super().__init__(name, knowl, title, align=align, **kwds)\n        self.unknown = unknown\n        self.no = no\n\n    def display(self, rec):\n        val = self._get(rec, downloading=True) # We emulate downloading so that we can determine if the value is None\n        if val:\n            return \"&#x2713;\"\n        elif val is None:\n            return self.unknown\n        else:\n            return self.no"
  },
  {
    "type": "function",
    "file": "lmfdb/classical_modular_forms/test_cmf.py",
    "name": "test_level11",
    "line_start": 188,
    "line_end": 201,
    "lines": 14,
    "bytes": 756,
    "has_71": true,
    "code": "    def test_level11(self):\n        r\"\"\"\n        Check that the weight 2 form of level 11 works.\n        \"\"\"\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/11/2/a/a/\")\n        assert '2 q^{2}' in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/11/2/a/a/?format=satake\")\n        assert r'0.707107' in page.get_data(as_text=True)\n        assert r'0.957427' in page.get_data(as_text=True)\n        assert r'0.223607' in page.get_data(as_text=True)\n        assert r'0.974679' in page.get_data(as_text=True)\n        ## We also check that the L-function works\n        page = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/11/2/a/a/', follow_redirects=True)\n        assert '0.253841' in page.get_data(as_text=True)"
  },
  {
    "type": "function",
    "file": "lmfdb/groups/abstract/main.py",
    "name": "trans_expr_data",
    "line_start": 3669,
    "line_end": 3676,
    "lines": 8,
    "bytes": 809,
    "has_71": true,
    "code": "def trans_expr_data(label):\n    tex_name = db.gps_groups.lookup(label, \"tex_name\")\n    ans = f\"Transitive permutation representations of ${tex_name}$:<br />\\n\"\n    ans += f\"<table>\\n<tr><th>{display_knowl('gg.label', 'Label')}</th><th>{display_knowl('gg.parity', 'Parity')}</th><th>{display_knowl('gg.primitive', 'Primitive')}</th></tr>\\n\"\n    for rec in db.gps_transitive.search({\"abstract_label\":label}, [\"label\", \"parity\", \"prim\"]):\n        ans += f'<tr><td><a href=\"{url_for(\"galois_groups.by_label\", label=rec[\"label\"])}\">{rec[\"label\"]}</a></td><td class=\"right\">${rec[\"parity\"]}$</td><td class=\"center\">{\"yes\" if rec[\"prim\"] == 1 else \"no\"}</td></tr>' # it would be nice to use &#x2713; and &#x2717; (check and x), but if everything is no then it's confusing\n    ans += \"</table>\"\n    return Markup(ans)"
  },
  {
    "type": "function",
    "file": "lmfdb/lfunctions/test_lfunctions.py",
    "name": "test_tracehash",
    "line_start": 500,
    "line_end": 511,
    "lines": 12,
    "bytes": 835,
    "has_71": true,
    "code": "    def test_tracehash(self):\n        L = self.tc.get('/L/tracehash/7200459463482029776252499748763/', follow_redirects=True)\n        assert 'trace_hash = 7200459463482029776252499748763 not in [0, 2^61]' in L.get_data(as_text=True)\n        L = self.tc.get('/L/tracehash/1938322253992393114/', follow_redirects=True)\n        assert '324016' in L.get_data(as_text=True), \"Missing data in /L/tracehash/1938322253992393114/\"\n        assert 'Dual L-function' not in L.get_data(as_text=True)\n        assert '2-324016-1.1-c1-0-6' in L.get_data(as_text=True)\n        assert 'Elliptic curve 324016.h' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/tracehash/1127515239490717889/', follow_redirects=True)\n        assert 'Elliptic curve 37.a' in L.get_data(as_text=True)\n        assert 'Dual L-function' not in L.get_data(as_text=True)"
  },
  {
    "type": "class",
    "file": "lmfdb/utils/search_columns.py",
    "name": "CheckMaybeCol",
    "line_start": 298,
    "line_end": 323,
    "lines": 26,
    "bytes": 837,
    "has_71": true,
    "code": "class CheckMaybeCol(SearchCol):\n    \"\"\"\n    CheckMaybe columns are for integer columns that use 1 to represent true, -1 for false and 0 for unknown.\n    They explicitly show \"not computed\" rather than \"?\" for unknown values.\n    They are also centered by default.\n    \"\"\"\n    def __init__(self, name, knowl, title, align=\"center\", unknown=\"?\", no=\"\", **kwds):\n        super().__init__(name, knowl, title, align=align, **kwds)\n        self.unknown = unknown\n        self.no = no\n\n    def display(self, rec):\n        ans = self.get(rec)\n        if ans > 0:\n            return \"&#x2713;\"\n        elif ans < 0:\n            return self.no\n        else:\n            return self.unknown\n\n    def download(self, rec, name=None):\n        ans = self._get(rec)\n        if ans == 0:\n            return None\n        else:\n            return (ans > 0)"
  },
  {
    "type": "function",
    "file": "lmfdb/genus2_curves/test_genus2_curves.py",
    "name": "test_mwgroup",
    "line_start": 189,
    "line_end": 202,
    "lines": 14,
    "bytes": 843,
    "has_71": true,
    "code": "    def test_mwgroup(self):\n        L = self.tc.get(\"/Genus2Curve/Q/25913/a/25913/1\")\n        assert \"\\\\Z \\\\oplus \\\\Z \\\\oplus \\\\Z\" in L.get_data(as_text=True)\n        assert \"-x^3 - z^3\" in L.get_data(as_text=True)\n        assert \"0.375585\" in L.get_data(as_text=True)\n        assert \"\\\\infty\" in L.get_data(as_text=True)\n        assert \"6.2.1658432.2\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/969306/a/969306/1\")\n        assert \"\\\\Z \\\\oplus \\\\Z \\\\oplus \\\\Z \\\\oplus \\\\Z/{2}\\\\Z\" in L.get_data(as_text=True)\n        assert \"16y\" in L.get_data(as_text=True) and \"2xz^2 + 11z^3\" in L.get_data(as_text=True)\n        assert \"3.259671\" in L.get_data(as_text=True)\n        assert \"\\\\infty\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/461/a/461/2\")\n        assert \"trivial\" in L.get_data(as_text=True)"
  },
  {
    "type": "function",
    "file": "lmfdb/symL/sympowlmfdb.py",
    "name": "Lderivs",
    "line_start": 181,
    "line_end": 225,
    "lines": 45,
    "bytes": 1379,
    "has_71": true,
    "code": "    def Lderivs(self, E, n, prec, d):\n        r\"\"\"\n        Return `0^{th}` to `d^{th}` derivatives of\n        `L(\\mathrm{Sym}^{(n)}(E,s)` to prec digits of precision, where\n        `s` is the right edge if `n` is even and the center\n        if `n` is odd.\n\n        INPUT:\n\n\n        -  ``E`` - elliptic curve\n\n        -  ``n`` - integer (even or odd)\n\n        -  ``prec`` - integer\n\n        -  ``d`` - integer\n\n\n        OUTPUT: a string, exactly as output by sympow\n\n        .. note::\n\n           To use this function you may have to run a few commands\n           like ``sympow('-new_data 1d2')``, each which takes a\n           few minutes. If this function fails it will indicate what commands\n           have to be run.\n\n        EXAMPLES::\n\n            sage: print(sympow.Lderivs(EllipticCurve('11a'), 1, 16, 2))  # not tested\n            ...\n             1n0: 2.538418608559107E-01\n             1w0: 2.538418608559108E-01\n             1n1: 1.032321840884568E-01\n             1w1: 1.059251499158892E-01\n             1n2: 3.238743180659171E-02\n             1w2: 3.414818600982502E-02\n        \"\"\"\n        if prec > 64:\n            raise ValueError(\"prec (=%s) must be at most 64\" % prec)\n        if prec < 1:\n            raise ValueError(\"prec (=%s) must be at least 1\" % prec)\n        v = self('-sp %sp%sd%s %s' % (n, prec, d, self._curve_str(E)))\n        return self._fix_err(v)"
  },
  {
    "type": "function",
    "file": "lmfdb/elliptic_curves/test_browse_page.py",
    "name": "test_search",
    "line_start": 80,
    "line_end": 104,
    "lines": 25,
    "bytes": 1459,
    "has_71": true,
    "code": "    def test_search(self):\n        r\"\"\"\n        Check that various search combinations work.\n        \"\"\"\n        self.check_args(\"/EllipticCurve/Q/?conductor=100-200&count=100\",\n                        '[0, -1, 1, -887, -10143]')\n        self.check_args_with_timeout(\"/EllipticCurve/Q/?rank=0&torsion=2&sha=4&count=100\",\n                        '[0, -1, 0, -10560, -414180]')\n        self.check_args(\"/EllipticCurve/Q/?conductor=&jinv=-4096%2F11&count=100\",\n                        '169136.i3')\n        self.check_args(\"/EllipticCurve/Q/?torsion=%5B2%2C4%5D&sha=&count=100\",\n                        '[0, 1, 0, -1664, -9804]')\n        self.check_args_with_timeout(\"/EllipticCurve/Q/?nonmax_quantifier=include&nonmax_primes=2,3&count=100\",\n                        '[1, -1, 1, -24575, 1488935]')\n        self.check_args_with_timeout(\"/EllipticCurve/Q/?nonmax_quantifier=exactly&nonmax_primes=5&optimal=on&count=100\",\n                        '[0, 0, 1, -75, 256]')\n        self.check_args(\"EllipticCurve/Q/?conductor=990&optimal=on\",\n                        '990h1')\n        L = self.tc.get(\"EllipticCurve/Q/?isogeny_degrees=13\")\n        assert '[0, 0, 1, -849658625, 9532675710156]' in L.get_data(as_text=True)\n        assert '[0, -1, 1, -10, -20]' not in L.get_data(as_text=True)\n\n        # Test error handling\n        L = self.tc.get(\"EllipticCurve/Q/?conductor=162&jinv=-1159088625%2F097152\")\n        assert ' is not a valid input' in L.get_data(as_text=True)"
  },
  {
    "type": "function",
    "file": "lmfdb/classical_modular_forms/test_cmf2.py",
    "name": "test_trivial_searches",
    "line_start": 190,
    "line_end": 217,
    "lines": 28,
    "bytes": 1607,
    "has_71": true,
    "code": "    def test_trivial_searches(self):\n        from sage.all import Subsets\n        for begin in [\n                ('level=10&weight=1-20&dim=1',\n                    ['Results (21 matches)', '171901114', 'No', '10.723', 'A-L signs']\n                    ),\n                ('level=10%2C13%2C17&weight=1-8&dim=1',\n                    ['Results (12 matches)', '1373', 'No', '0.136']\n                    )]:\n            for s in Subsets(['has_self_twist=no', 'is_self_dual=yes', 'nf_label=1.1.1.1','char_order=1','inner_twist_count=1']):\n                s = '&'.join(['/ModularForm/GL2/Q/holomorphic/?search_type=List', begin[0]] + list(s))\n                page = self.tc.get(s, follow_redirects=True)\n                for elt in begin[1]:\n                    assert elt in page.get_data(as_text=True), s\n\n        for begin in [\n                ('level=1-330&weight=1&projective_image=D2',\n                    ['Results (49 matches)',\n                        '328.1.c.a', r\"\\sqrt{-82}\", r\"\\sqrt{-323}\", r\"\\sqrt{109}\"]\n                    ),\n                ('level=900-1000&weight=1-&projective_image=D2',\n                    ['Results (26 matches)', r\"\\sqrt{-1}\", r\"\\sqrt{-995}\", r\"\\sqrt{137}\"]\n                    )]:\n            for s in Subsets(['has_self_twist=yes', 'has_self_twist=cm', 'has_self_twist=rm', 'projective_image=Dn','dim=1-4']):\n                s = '&'.join(['/ModularForm/GL2/Q/holomorphic/?search_type=List', begin[0]] + list(s))\n                page = self.tc.get(s, follow_redirects=True)\n                for elt in begin[1]:\n                    assert elt in page.get_data(as_text=True), s"
  },
  {
    "type": "function",
    "file": "lmfdb/classical_modular_forms/test_cmf2.py",
    "name": "test_hecke_charpolys",
    "line_start": 362,
    "line_end": 394,
    "lines": 33,
    "bytes": 1734,
    "has_71": true,
    "code": "    def test_hecke_charpolys(self):\n        \"\"\"Test that the Hecke charpolys are correct.\n\n        Some expected Hecke charpolys are stored in the dict test_data,\n        which are then checked to be in the relevant page. These examples\n        have been chosen to be readily verifiable from the displayed\n        Fourier coefficients of each respective homepage.\"\"\"\n\n        test_data = {# Dimension 1\n                    '11/2/a/a': {2: r'\\( T + 2 \\)',\n                                 17: r'\\( T + 2 \\)',\n                                 29: r'\\( T \\)'},\n\n                    # Dimension 2\n                    '10/3/c/a': {5: r'\\( T^{2} + 25 \\)',\n                                 11: r'\\( (T + 8)^{2} \\)',\n                                 97: r'\\( T^{2} + 126T + 7938 \\)'},\n\n                    # Dimension 5\n                    '294/5/b/f': {2: r'\\( (T^{2} + 8)^{5} \\)',\n                                    # The following test checks that monomials do not have superfluous parentheses\n                                    7: r'\\( T^{10} \\)'},\n                    }\n\n        for label, some_expected_charpolys in test_data.items():\n            page_as_text = self.tc.get('/ModularForm/GL2/Q/holomorphic/{}/'.format(label), follow_redirects=True).get_data(as_text=True)\n            for _, expected_pth_charpoly in some_expected_charpolys.items():\n                assert expected_pth_charpoly in page_as_text\n\n        # Check large dimensions behave as we expect. The following is a form of dimension 108\n\n        large_dimension_page_as_text = self.tc.get('/ModularForm/GL2/Q/holomorphic/671/2/i/a/', follow_redirects=True).get_data(as_text=True)\n        assert \"Hecke characteristic polynomials\" not in large_dimension_page_as_text"
  },
  {
    "type": "function",
    "file": "lmfdb/classical_modular_forms/test_cmf.py",
    "name": "test_character_values",
    "line_start": 604,
    "line_end": 657,
    "lines": 54,
    "bytes": 1838,
    "has_71": true,
    "code": "    def test_character_values(self):\n        # A newform orbit of dimension 1\n        data = self.tc.get('/ModularForm/GL2/Q/holomorphic/12/3/c/a/').get_data(as_text=True)\n        character_values_table = r\"\"\"\n<table class=\"ntdata\">\n  <tbody>\n        <tr>\n      <td class=\"dark border-right border-bottom\">\\(n\\)</td>\n      <td class=\"light border-bottom\">\\(5\\)</td>\n      <td class=\"dark border-bottom\">\\(7\\)</td>    </tr>\n    <tr>\n      <td class=\"dark border-right\">\\(\\chi(n)\\)</td>\n      <td class=\"light\">\\(-1\\)</td>\n      <td class=\"dark\">\\(1\\)</td>    </tr>\n  </tbody>\n</table>\n\"\"\"\n        assert (character_values_table in data)\n\n        # A newform orbit of dimension 2\n        data = self.tc.get('/ModularForm/GL2/Q/holomorphic/119/1/d/a/').get_data(as_text=True)\n        character_values_table = r\"\"\"\n<table class=\"ntdata\">\n  <tbody>\n        <tr>\n      <td class=\"dark border-right border-bottom\">\\(n\\)</td>\n      <td class=\"light border-bottom\">\\(52\\)</td>\n      <td class=\"dark border-bottom\">\\(71\\)</td>    </tr>\n    <tr>\n      <td class=\"dark border-right\">\\(\\chi(n)\\)</td>\n      <td class=\"light\">\\(-1\\)</td>\n      <td class=\"dark\">\\(-1\\)</td>    </tr>\n  </tbody>\n</table>\n\"\"\"\n        assert (character_values_table in data)\n\n        # An embedded newform\n        data = self.tc.get('/ModularForm/GL2/Q/holomorphic/119/1/d/a/118/1/').get_data(as_text=True)\n        character_values_table = r\"\"\"\n<table class=\"ntdata\">\n  <tbody>\n        <tr>\n      <td class=\"dark border-right border-bottom\">\\(n\\)</td>\n      <td class=\"light border-bottom\">\\(52\\)</td>\n      <td class=\"dark border-bottom\">\\(71\\)</td>    </tr>\n    <tr>\n      <td class=\"dark border-right\">\\(\\chi(n)\\)</td>\n      <td class=\"light\">\\(-1\\)</td>\n      <td class=\"dark\">\\(-1\\)</td>    </tr>\n  </tbody>\n</table>\n\"\"\"\n        assert (character_values_table in data)"
  },
  {
    "type": "function",
    "file": "lmfdb/lfunctions/test_lfunctions.py",
    "name": "test_errorMessages",
    "line_start": 553,
    "line_end": 588,
    "lines": 36,
    "bytes": 1935,
    "has_71": true,
    "code": "    def test_errorMessages(self):\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/5/k/4/a/1/')\n        assert 'The requested URL was not found on the server' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Character/Dirichlet/9/10/')\n        assert 'L-function for dirichlet character with label 9.10 not found' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/Q/11/b/')\n        assert 'L-function for elliptic curve isogeny class with label 11.b not found' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/5/6/d/c/')\n        assert 'L-function for classical modular form with label 5.6.d.c not found' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL3/Q/Maass/1/1/16.40312_0.171121/-0.421999/')\n        assert 'L-function for modular form ModularForm/GL3/Q/Maass/1/1/16.40312_0.171121/-0.421999/ not found' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/TotallyReal/2.2.5.1/holomorphic/2.2.5.1-31.1-a/2/0/')\n        assert 'not in the database' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/TotallyReal/2.2.5.1/holomorphic/2.2.5.1-31.5-a/0/0/')\n        assert 'not in the database' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Genus2Curve/Q/247/a/')\n        assert 'L-function for genus 2 curve with label 247.a not found' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/NumberField/2.2.7.1/')\n        assert 'not in the database' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ArtinRepresentation/3.231.4t5.a.a/')\n        assert 'not in the database' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/SymmetricPower/2/EllipticCurve/Q/37/d/')\n        assert 'not in the database' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/SymmetricPower/2/EllipticCurve/Q/27/a/')\n        assert 'not in the database' in L.get_data(as_text=True)"
  },
  {
    "type": "function",
    "file": "lmfdb/abvar/fq/test_browse_page.py",
    "name": "test_search_combos",
    "line_start": 268,
    "line_end": 303,
    "lines": 36,
    "bytes": 2384,
    "has_71": true,
    "code": "    def test_search_combos(self):\n        r\"\"\"\n        Check that various search combinations work.\n        \"\"\"\n        # dimension and base field, last one is from the table\n        self.check_args(\"/Variety/Abelian/Fq/?q=7&g=1\", \"1.7.f\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=7&g=1\", \"1.7.f\")\n        self.check_args(\"/Variety/Abelian/Fq/1/7/\", \"1.7.af\")\n        # dimension, base field and p-rank\n        self.check_args(\"/Variety/Abelian/Fq/?q=9&g=2&p_rank=2\", \"2.9.ad_b\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=9&g=2&p_rank=2\", \"2.9.af_o\")\n        # dimension, base field and initial coefficients\n        self.check_args(\"/Variety/Abelian/Fq/?q=25&g=2&initial_coefficients=%5B1%2C-13%5D\", \"2.25.b_an\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=25&g=2&initial_coefficients=%5B1%2C-13%5D\", \"2.25.b_an\")\n        # dimension, base field and point counts of the abelian variety\n        self.check_args(\"/Variety/Abelian/Fq/?q=25&g=2&abvar_point_count=%5B373%2C391277%5D\", \"2.25.an_dh\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=25&g=2&abvar_point_count=%5B373%2C391277%5D\", \"2.25.an_dh\")\n        # dimension, base field and point counts of the curve\n        self.check_args(\"/Variety/Abelian/Fq/?q=3&g=4&curve_point_count=%5B0%2C4%2C15%5D\", \"4.3.ae_f_ad_e\")\n        # dimension, base field and maximum number to display\n        self.check_args(\"/Variety/Abelian/Fq/?q=25&g=2&count=100\", \"2.25.an_do\")\n        # p-rank and initial coefficients\n        self.check_args(\"/Variety/Abelian/Fq/?p_rank=2&initial_coefficients=%5B1%2C-1%2C3%2C9%5D\", \"4.3.b_ab_d_j\")\n        self.check_args(\"/Variety/Abelian/Fq/?p_rank=2&initial_coefficients=%5B1%2C-1%2C3%2C9%5D\", \"4.3.b_ab_d_j\")\n        # initial coefficients and point counts of the abelian variety\n        self.check_args(\n            \"/Variety/Abelian/Fq/?initial_coefficients=%5B1%2C-1%2C3%2C9%5D&abvar_point_count=%5B75%2C7125%5D\",\n            \"No matches\"\n        )\n        self.check_args(\n            \"/Variety/Abelian/Fq/?initial_coefficients=%5B1%2C-1%2C3%2C9%5D&abvar_point_count=%5B75%2C7125%5D\",\n            \"No matches\"\n        )\n        # Combining unknown fields on Jacobian and Principal polarization.\n        self.check_args(\"/Variety/Abelian/Fq/?g=3&jacobian=no&polarizable=not_no\", \"3.2.a_a_ae\")\n        self.check_args(\"/Variety/Abelian/Fq/?g=3&jacobian=no&polarizable=yes\", \"3.2.a_ac_a\")"
  },
  {
    "type": "class",
    "file": "lmfdb/maass_forms/test_maass.py",
    "name": "MaassTest",
    "line_start": 8,
    "line_end": 55,
    "lines": 48,
    "bytes": 2418,
    "has_71": true,
    "code": "class MaassTest(LmfdbTest):\n    def test_index(self):\n        L = self.tc.get(\"/ModularForm/GL2/Q/Maass/\")\n        assert 'database currently contains' in L.get_data(as_text=True)\n\n    def test_browse_1_10_0_10(self):\n        L = self.tc.get(\"/ModularForm/GL2/Q/Maass/BrowseGraph/1/10/0/10/\")\n        assert 'In the plot below each dot is linked' in L.get_data(as_text=True)\n\n    def test_browse_1_15_0_15(self):\n        L = self.tc.get(\"/ModularForm/GL2/Q/Maass/BrowseGraph/1/15/0/15/\")\n        assert 'In the plot below each dot is linked' in L.get_data(as_text=True)\n\n    def test_browse_10_100_0_4(self):\n        L = self.tc.get(\"/ModularForm/GL2/Q/Maass/BrowseGraph/10/100/0/4/\")\n        assert 'In the plot below each dot is linked' in L.get_data(as_text=True)\n\n    def test_browse_100_1000_0_1(self):\n        L = self.tc.get(\"/ModularForm/GL2/Q/Maass/BrowseGraph/100/1000/0/1/\")\n        assert 'In the plot below each dot is linked' in L.get_data(as_text=True)\n\n    def test_search_all(self):\n        L = self.tc.get(\"/ModularForm/GL2/Q/Maass/?search_type=List&all=1\")\n        assert \"9.533695\" in L.get_data(as_text=True) and \"19.48471\" in L.get_data(as_text=True)\n\n    def test_search_N_101(self):\n        L = self.tc.get(\"/ModularForm/GL2/Q/Maass/?level=101\")\n        assert \"0.453759\" in L.get_data(as_text=True) and \"1.11356\" in L.get_data(as_text=True)\n\n    def test_search_R_40_50(self):\n        L = self.tc.get(\"/ModularForm/GL2/Q/Maass/?spectral_parameter=40-50\")\n        assert \"40.54335\" in L.get_data(as_text=True) and \"49.68352\" in L.get_data(as_text=True)\n\n    def test_search_R_1234(self):\n        L = self.tc.get(\"/ModularForm/GL2/Q/Maass/?spectral_parameter=12.34\")\n        assert \"12.34000\" in L.get_data(as_text=True)\n\n    def test_form_1234(self):\n        L = self.tc.get(\"/ModularForm/GL2/Q/Maass/19.205\")\n        assert \"coefficients\" in L.get_data(as_text=True) and \"-1.236693\" in L.get_data(as_text=True) and \"1.858211\" in L.get_data(as_text=True)\n\n    def test_form_1234_long_label(self):\n        L = self.tc.get(\"/ModularForm/GL2/Q/Maass/19.0.1.205.1\")\n        assert \"coefficients\" in L.get_data(as_text=True) and \"-1.236693\" in L.get_data(as_text=True) and \"1.858211\" in L.get_data(as_text=True)\n\n    def test_underlying_data(self):\n        data = self.tc.get(\"/ModularForm/GL2/Q/Maass/data/42.42\").get_data(as_text=True)\n        assert (\"maass_rigor\" in data and \"symmetry\" in data)"
  },
  {
    "type": "function",
    "file": "lmfdb/utils/completeness.py",
    "name": "__call__",
    "line_start": 2367,
    "line_end": 2418,
    "lines": 52,
    "bytes": 2849,
    "has_71": true,
    "code": "    def __call__(self, db, query):\n        N, td, pd, Qd, perfect, simple, abelian = IntegerSet(query.get(\"order\")), IntegerSet(query.get(\"transitive_degree\")), IntegerSet(query.get(\"permutation_degree\")), IntegerSet(query.get(\"linQ_dim\")), query.get(\"perfect\"), query.get(\"simple\"), query.get(\"abelian\")\n        # First missing\n        # PSL(2,2729) = 10162031880\n        #POmega-(4,53)= 11082179160\n        # PSU(3,23)   = 26056457856\n        # 2B(2,128)   = 34093383680\n        # Suz         = 448345497600\n        # ON          = 460815505920\n        # G(2,7)      = 664376138496\n        # PSL(4,7)    = 2317591180800\n        # PSp(4,23)   = 20674026236160\n        #POmega+(10,2)= 23499295948800\n        # PSU(5,4)    = 53443952640000\n        # PSU(4,9)    = 101798586432000\n        # PSp(10,2)   = 24815256521932800\n        # 2G(2,243)   = 49825657439340552\n        #POmega+(8,4) = 67010895544320000\n        #POmega-(8,4) = 67536471195648000\n        # 3D(4,4)     = 67802350642790400\n        # PSp(6,7)    = 273457218604953600\n        # PSL(8,2)    = 5348063769211699200\n        #POmega-(12,2)= 51615733565620224000\n        # PSL(5,7)    = 187035198320488089600\n        # PSL(6,4)    = 361310134959341568000\n        #POmega-(10,3)= 650084965259666227200\n        # PSU(6,4)    = 1120527288631296000000\n        # Omega(9,4)  = 4408780839651901440000\n        # PSp(8,4)    = 4408780839651901440000\n        # PSU(7,3)    = 72853912155490594652160\n        # 2F(4,8)     = 264905352699586176614400\n        # PSU(9,2)    = 325473292721108444774400\n        # F(4,3)      = 5734420792816671844761600\n        # PSL(7,4)    = 72736898347485916060188672000\n        # PSU(8,3)    = 261303669649855006027009228800\n        ord2000 = IntegerSet({\"$lte\": 2000, \"$nin\":[512,640,768,896,1024,1152,1280,1408,1536,1664,1792,1920]})\n        if N.is_subset(ord2000):\n            return True, \"groups of order at most 2000 except orders larger than 500 that are multiples of 128\", None\n        if perfect is True and N.bounded(50000):\n            return True, \"perfect groups of order at most 50000\", None\n        if simple is True and abelian is False and N.bounded(10162031879):\n            return True, \"nonabelian simple groups of order less than 10162031880\", None\n        td48 = IntegerSet(top(31)).union(IntegerSet([33,47]))\n        if td.is_subset(td48):\n            return True, \"groups with minimal transitive degree at most 47 (except 32)\", None\n        if td.bounded(47) and N.bounded(40000000000, infinity):\n            return True, \"groups with minimal transitive degree 32 and order at least 40 billion\", None\n        if pd.bounded(15):\n            return True, \"groups with minimal permutation degree at most 15\", None\n        if Qd.bounded(6):\n            return True, r\"groups with linear $\\Q$-degree at most 6\", None\n        return False, None, None"
  },
  {
    "type": "class",
    "file": "lmfdb/utils/completeness.py",
    "name": "GroupBound",
    "line_start": 2366,
    "line_end": 2418,
    "lines": 53,
    "bytes": 2876,
    "has_71": true,
    "code": "class GroupBound(ColTest):\n    def __call__(self, db, query):\n        N, td, pd, Qd, perfect, simple, abelian = IntegerSet(query.get(\"order\")), IntegerSet(query.get(\"transitive_degree\")), IntegerSet(query.get(\"permutation_degree\")), IntegerSet(query.get(\"linQ_dim\")), query.get(\"perfect\"), query.get(\"simple\"), query.get(\"abelian\")\n        # First missing\n        # PSL(2,2729) = 10162031880\n        #POmega-(4,53)= 11082179160\n        # PSU(3,23)   = 26056457856\n        # 2B(2,128)   = 34093383680\n        # Suz         = 448345497600\n        # ON          = 460815505920\n        # G(2,7)      = 664376138496\n        # PSL(4,7)    = 2317591180800\n        # PSp(4,23)   = 20674026236160\n        #POmega+(10,2)= 23499295948800\n        # PSU(5,4)    = 53443952640000\n        # PSU(4,9)    = 101798586432000\n        # PSp(10,2)   = 24815256521932800\n        # 2G(2,243)   = 49825657439340552\n        #POmega+(8,4) = 67010895544320000\n        #POmega-(8,4) = 67536471195648000\n        # 3D(4,4)     = 67802350642790400\n        # PSp(6,7)    = 273457218604953600\n        # PSL(8,2)    = 5348063769211699200\n        #POmega-(12,2)= 51615733565620224000\n        # PSL(5,7)    = 187035198320488089600\n        # PSL(6,4)    = 361310134959341568000\n        #POmega-(10,3)= 650084965259666227200\n        # PSU(6,4)    = 1120527288631296000000\n        # Omega(9,4)  = 4408780839651901440000\n        # PSp(8,4)    = 4408780839651901440000\n        # PSU(7,3)    = 72853912155490594652160\n        # 2F(4,8)     = 264905352699586176614400\n        # PSU(9,2)    = 325473292721108444774400\n        # F(4,3)      = 5734420792816671844761600\n        # PSL(7,4)    = 72736898347485916060188672000\n        # PSU(8,3)    = 261303669649855006027009228800\n        ord2000 = IntegerSet({\"$lte\": 2000, \"$nin\":[512,640,768,896,1024,1152,1280,1408,1536,1664,1792,1920]})\n        if N.is_subset(ord2000):\n            return True, \"groups of order at most 2000 except orders larger than 500 that are multiples of 128\", None\n        if perfect is True and N.bounded(50000):\n            return True, \"perfect groups of order at most 50000\", None\n        if simple is True and abelian is False and N.bounded(10162031879):\n            return True, \"nonabelian simple groups of order less than 10162031880\", None\n        td48 = IntegerSet(top(31)).union(IntegerSet([33,47]))\n        if td.is_subset(td48):\n            return True, \"groups with minimal transitive degree at most 47 (except 32)\", None\n        if td.bounded(47) and N.bounded(40000000000, infinity):\n            return True, \"groups with minimal transitive degree 32 and order at least 40 billion\", None\n        if pd.bounded(15):\n            return True, \"groups with minimal permutation degree at most 15\", None\n        if Qd.bounded(6):\n            return True, r\"groups with linear $\\Q$-degree at most 6\", None\n        return False, None, None"
  },
  {
    "type": "function",
    "file": "lmfdb/ecnf/main.py",
    "name": "index",
    "line_start": 97,
    "line_end": 154,
    "lines": 58,
    "bytes": 3180,
    "has_71": true,
    "code": "def index():\n    #    if 'jump' in request.args:\n    #        return show_ecnf1(request.args['label'])\n    info = to_dict(request.args, search_array=ECNFSearchArray(), stats=ECNF_stats())\n    if request.args:\n        return elliptic_curve_search(info)\n    bread = get_bread()\n\n    # the dict data will hold additional information to be displayed on\n    # the main browse and search page\n\n    # info['fields'] holds data for a sample of number fields of different\n    # signatures for a general browse:\n\n    info['fields'] = []\n    # Rationals\n    # info['fields'].append(['the rational field', (('1.1.1.1', [url_for('ec.rational_elliptic_curves'), '$\\Q$']),)]) # Removed due to ambiguity\n\n    # Real quadratics (sample)\n    rqfs = ['2.2.{}.1'.format(d) for d in [8, 12, 5, 24, 28, 40, 44, 13, 56, 60]]\n    info['fields'].append(['By <a href=\"{}\">real quadratic field</a>'.format(url_for('.statistics_by_signature', d=2, r=2)),\n                           ((nf, [url_for('.show_ecnf1', nf=nf), field_pretty(nf)])\n                            for nf in rqfs)])\n\n    # Imaginary quadratics (sample)\n    iqfs = ['2.0.{}.1'.format(d) for d in [4, 8, 3, 20, 24, 7, 40, 11, 52]] #, 56, 15, 68, 19, 84, 88, 23, 43, 67, 163]]\n    info['fields'].append(['By <a href=\"{}\">imaginary quadratic field</a>'.format(url_for('.statistics_by_signature', d=2, r=0)),\n                           ((nf, [url_for('.show_ecnf1', nf=nf), field_pretty(nf)])\n                            for nf in iqfs)])\n\n    # Cubics (sample)\n    cubics = ['3.1.23.1'] + ['3.3.{}.1'.format(d) for d in [49,81,148,169,229,257,316]]\n    info['fields'].append(['By <a href=\"{}\">cubic field</a>'.format(url_for('.statistics_by_degree', d=3)),\n                           ((nf, [url_for('.show_ecnf1', nf=nf), field_pretty(nf)])\n                            for nf in cubics)])\n\n    # Quartics (sample)\n    quartics = ['4.4.{}.1'.format(d) for d in [725,1125,1600,1957,2000,2048,2225,2304]]\n    info['fields'].append(['By <a href=\"{}\">totally real quartic field</a>'.format(url_for('.statistics_by_degree', d=4)),\n                           ((nf, [url_for('.show_ecnf1', nf=nf), field_pretty(nf)])\n                            for nf in quartics)])\n\n    # Quintics (sample)\n    quintics = ['5.5.{}.1'.format(d) for d in [14641, 24217, 36497, 38569, 65657, 70601, 81509]]\n    info['fields'].append(['By <a href=\"{}\">totally real quintic field</a>'.format(url_for('.statistics_by_degree', d=5)),\n                           ((nf, [url_for('.show_ecnf1', nf=nf), field_pretty(nf)])\n                            for nf in quintics)])\n\n    # Sextics (sample)\n    sextics = ['6.6.{}.1'.format(d) for d in [300125, 371293, 434581, 453789, 485125, 592661, 703493]]\n    info['fields'].append(['By <a href=\"{}\">totally real sextic field</a>'.format(url_for('.statistics_by_degree', d=6)),\n                           ((nf, [url_for('.show_ecnf1', nf=nf), field_pretty(nf)])\n                            for nf in sextics)])\n\n    return render_template(\"ecnf-index.html\",\n                           title=\"Elliptic curves over number fields\",\n                           info=info,\n                           bread=bread, learnmore=learnmore_list())"
  },
  {
    "type": "function",
    "file": "lmfdb/utils/search_parsing.py",
    "name": "parse_bracketed_rats",
    "line_start": 980,
    "line_end": 1063,
    "lines": 84,
    "bytes": 3316,
    "has_71": true,
    "code": "def parse_bracketed_rats(\n    inp,\n    query,\n    qfield,\n    minlength=None,\n    maxlength=None,\n    exactlength=None,\n    split=True,\n    process=None,\n    listprocess=None,\n    keepbrackets=False,\n    extractor=None,\n):\n    if (\n        not BRACKETED_RAT_RE.match(inp)\n        or (maxlength is not None and inp.count(\",\") > maxlength - 1)\n        or (minlength is not None and inp.count(\",\") < minlength - 1)\n        or (exactlength is not None and inp.count(\",\") != exactlength - 1)\n        or (exactlength is not None and inp == \"[]\" and exactlength > 0)\n    ):\n        if exactlength == 2:\n            lstr = \"pair of rational numbers\"\n            example = \"[2,3/2] or [3,3]\"\n        elif exactlength == 1:\n            lstr = \"list of 1 rational number\"\n            example = \"[2/5]\"\n        elif exactlength is not None:\n            lstr = \"list of %s rational numbers\" % exactlength\n            example = (\n                str(list(range(2, exactlength + 2))).replace(\", \", \"/13,\")\n                + \" or \"\n                + str([3] * exactlength).replace(\", \", \"/4,\")\n            )\n        elif minlength is not None and maxlength is not None:\n            lstr = f\"list of rational numbers with length between {minlength} and {maxlength}\"\n            example = (\n                str(list(range(2, minlength + 2))).replace(\", \", \"/13,\")\n                + \" or \"\n                + str([2] * max(1, maxlength - 2)).replace(\", \", \"/41,\")\n            )\n        elif minlength is not None:\n            lstr = \"list of at least %s rational numbers\" % minlength\n            example = (\n                str(list(range(2, minlength + 2))).replace(\", \", \"/13,\")\n                + \" or \"\n                + str([2] * max(1, minlength - 2)).replace(\", \", \"/41,\")\n            )\n        elif maxlength is not None:\n            lstr = \"list of at most %s rational numbers\" % maxlength\n            example = (\n                str(list(range(2, maxlength + 2))).replace(\", \", \"/13,\")\n                + \" or \"\n                + str([2] * max(1, maxlength - 2)).replace(\", \", \"/41,\")\n            )\n        else:\n            lstr = \"list of rational numbers\"\n            example = \"[1/7,2,3] or [5,6/71]\"\n        raise SearchParsingError(\"It needs to be a %s in square brackets, such as %s.\" % (lstr, example))\n    else:\n        if inp == \"[]\":  # fixes bug in the code below (split never returns an empty list)\n            if split:\n                query[qfield] = []\n            else:\n                query[qfield] = \"\"\n            return\n        L = [QQ(a) for a in inp[1:-1].split(\",\")]\n        if process is not None:\n            L = [process(a) for a in L]\n        if listprocess is not None:\n            L = listprocess(L)\n        if extractor is not None:\n            for qf, v in zip(qfield, extractor(L)):\n                if qf in query and query[qf] != v:\n                    raise SearchParsingError(f\"Inconsistent specification of {qf}: {query[qf]} vs {v}\")\n                query[qf] = v\n        elif split:\n            query[qfield] = L\n        else:\n            inp = \"[%s]\" % \",\".join(str(a) for a in L)\n            if keepbrackets:\n                inp = inp.replace(\"[\", \"['\").replace(\"]\", \"']\").replace(\",\", \"','\")\n                query[qfield] = inp\n            else:\n                query[qfield] = inp[1:-1]"
  },
  {
    "type": "function",
    "file": "lmfdb/characters/test_characters.py",
    "name": "test_dirichletgalorbs",
    "line_start": 100,
    "line_end": 150,
    "lines": 51,
    "bytes": 3341,
    "has_71": true,
    "code": "    def test_dirichletgalorbs(self):\n        W = self.tc.get('/Character/Dirichlet/289/j').get_data(as_text=True)\n        assert r'&rarr; <a href=\"/Character/Dirichlet/289/j\"> j</a>' in W\n        table_row = (r'<td class=\"center\">\\(-1\\)</td>  '\n                    r'<td class=\"center\">\\(1\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{57}{136}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{191}{272}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{57}{68}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{219}{272}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{33}{272}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{229}{272}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{35}{136}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{55}{136}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{61}{272}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{41}{272}\\right)\\)</td>')\n        assert table_row in W\n        assert \"Underlying data\" in W and \"data/289.j\" in W\n\n        W = self.tc.get('/Character/Dirichlet/7145/da')\n        assert r'&rarr; <a href=\"/Character/Dirichlet/7145/da\"> da</a>' in W.get_data(as_text=True)\n        table_row = (r'<td class=\"center\">\\(-1\\)</td>  '\n                    r'<td class=\"center\">\\(1\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{19}{84}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{481}{714}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{19}{42}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{1285}{1428}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{341}{357}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{19}{28}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{124}{357}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{779}{1428}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{15}{119}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{115}{714}\\right)\\)</td>')\n        assert table_row in W.get_data(as_text=True)\n\n        # Tests for URL behaviour of characters\n\n        W = self.tc.get('/Character/Dirichlet/5489/banana/100', follow_redirects=True)\n        assert bool_string(True) in W.get_data(as_text=True)\n        assert r\"The URL has been duly corrected.\" in W.get_data(as_text=True)\n\n        W = self.tc.get('/Character/Dirichlet/254/banana', follow_redirects=True)\n        assert 'Error: No Galois orbit of Dirichlet characters with' in W.get_data(as_text=True)\n\n        W = self.tc.get('/Character/Dirichlet/10001/banana/100', follow_redirects=True)\n        assert r'10001.i' in W.get_data(as_text=True)\n\n        W = self.tc.get('/Character/Dirichlet/9999999999/banana', follow_redirects=True)\n        assert 'Error: Galois orbits have only been computed for modulus up to 100,000' in W.get_data(as_text=True)\n\n        W = self.tc.get('/Character/Dirichlet/58589/50021', follow_redirects=True)\n        assert 'Number field defined by a degree 1428 polynomial' in W.get_data(as_text=True)"
  },
  {
    "type": "function",
    "file": "lmfdb/hypergm/main.py",
    "name": "render_hgm_webpage",
    "line_start": 475,
    "line_end": 567,
    "lines": 93,
    "bytes": 3371,
    "has_71": true,
    "code": "def render_hgm_webpage(label):\n    data = None\n    info = {}\n    data = db.hgm_motives.lookup(label)\n    if data is None:\n        abort(404, \"Hypergeometric motive \" + label + \" was not found in the database.\")\n    title = 'Hypergeometric motive:' + label\n    A = data['A']\n    B = data['B']\n\n    alpha = cyc_to_QZ(A)\n    beta = cyc_to_QZ(B)\n    gammas = ab2gammas(A, B)\n\n    det = db.hgm_families.lucky({'A': A, 'B': B}, 'det')\n    if det is None:\n        det = 'data not computed'\n    else:\n        det = [det[0], str(det[1])]\n        d1 = det[1]\n        d1 = re.sub(r'\\s', '', d1)\n        d1 = re.sub(r'(.)\\(', r'\\1*(', d1)\n        R = PolynomialRing(ZZ, 't')\n        d2 = R(1) if not det[1] else R(d1)\n        det = d2(QQ(data['t'])) * det[0]\n    t = latex(QQ(data['t']))\n    typee = 'Orthogonal'\n    if data['weight'] % 2 and not data['degree'] % 2:\n        typee = 'Symplectic'\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]\n    locinfo = data['locinfo']\n    for j in range(len(locinfo)):\n        locinfo[j] = [primes[j]] + locinfo[j]\n        # locinfo[j][2] = poly_with_factored_coeffs(locinfo[j][2], primes[j])\n        locinfo[j][2] = list_to_factored_poly_otherorder(locinfo[j][2], vari='T')\n    hodge = data['hodge']\n    famhodge = data['famhodge']\n    prop2 = [\n        ('Label', '%s' % data['label']),\n        ('A', r'\\(%s\\)' % A),\n        ('B', r'\\(%s\\)' % B),\n        ('Degree', r'\\(%s\\)' % data['degree']),\n        ('Weight', r'\\(%s\\)' % data['weight']),\n        ('Hodge vector', r'\\(%s\\)' % hodge),\n        ('Conductor', r'\\(%s\\)' % data['cond']),\n    ]\n    # Now add factorization of conductor\n    Cond = ZZ(data['cond'])\n    if not (Cond.abs().is_prime() or Cond == 1):\n        data['cond'] = \"{}={}\".format(str(Cond), factorint(data['cond']))\n\n    info.update({\n                'A': A,\n                'B': B,\n                'alpha': web_latex(alpha),\n                'beta': web_latex(beta),\n                'gammas': gammas,\n                't': t,\n                'degree': data['degree'],\n                'weight': data['weight'],\n                'sign': data['sign'],\n                'sig': data['sig'],\n                'hodge': hodge,\n                'famhodge': famhodge,\n                'cond': data['cond'],\n                'req': data['req'],\n                'lcms': data['lcms'],\n                'type': typee,\n                'det': det,\n                'locinfo': locinfo\n                })\n    AB_data, t_data = data[\"label\"].split(\"_t\")\n    friends = [(\"Motive family \" + AB_data.replace(\"_\", \" \"), url_for(\".by_family_label\", label=AB_data))]\n    friends.append(('L-function', url_for(\"l_functions.l_function_hgm_page\", label=AB_data, t='t' + t_data)))\n#    if rffriend != '':\n#        friends.append(('Discriminant root field', rffriend))\n    downloads = [(\"Underlying data\", url_for(\".hgm_data\", label=data[\"label\"]))]\n\n    AB = 'A = ' + str(A) + ', B = ' + str(B)\n    t_data = str(QQ(data['t']))\n\n    bread = get_bread([('family ' + str(AB), url_for(\".by_family_label\", label=AB_data)), ('t = ' + t_data, ' ')])\n    return render_template(\n        \"hgm-show-motive.html\",\n        title=title,\n        bread=bread,\n        info=info,\n        properties=prop2,\n        friends=friends,\n        downloads=downloads,\n        learnmore=learnmore_list(),\n        KNOWL_ID=\"hgm.%s\" % label,\n    )"
  },
  {
    "type": "function",
    "file": "lmfdb/belyi/test_belyi.py",
    "name": "test_download",
    "line_start": 138,
    "line_end": 206,
    "lines": 69,
    "bytes": 3503,
    "has_71": true,
    "code": "    def test_download(self):\n        r\"\"\"\n        Test download function\n        \"\"\"\n        # genus 0 example\n        # in magma\n        page = self.tc.get(\n            \"/Belyi/download_galmap_to_magma/7T6-7_2.2.1.1.1_3.2.2-a\",\n            follow_redirects=True,\n        )\n        assert (\n            \"phi := 1/2*(7*nu-15)*x^7/(x^7+1/10*(28*nu+7)*x^6+1/100*(-56*nu+511)*x^5+1/40*(-672*nu-1323)*x^4+1/20*(-42*nu-63)*x^3+1/40*(1701*nu+3024)*x^2+1/200*(-6237*nu-11178));\"\n            in page.get_data(as_text=True)\n        )\n        # in sage\n        page = self.tc.get(\n            \"/Belyi/download_galmap_to_sage/7T6-7_2.2.1.1.1_3.2.2-a\",\n            follow_redirects=True,\n        )\n        assert (\n            \"phi = 1/2*(7*nu-15)*x^7/(x^7+1/10*(28*nu+7)*x^6+1/100*(-56*nu+511)*x^5+1/40*(-672*nu-1323)*x^4+1/20*(-42*nu-63)*x^3+1/40*(1701*nu+3024)*x^2+1/200*(-6237*nu-11178))\"\n            in page.get_data(as_text=True)\n        )\n\n        # genus 1 example\n        # in magma\n        page = self.tc.get(\n            \"/Belyi/download_galmap_to_magma/6T15-5.1_5.1_5.1-c\",\n            follow_redirects=True,\n        )\n        assert (\n            \"phi := (1/3125*(162*nu-81)*x^2+1/78125*(972*nu-486)*x+1/390625*(-1458*nu+729))/(x^6-9/25*x^5+27/125*x^4+1/3125*(-162*nu-54)*x^3+1/78125*(729*nu-486)*x^2+1/9765625*(-2187*nu+5832)*x+1/244140625*(-2187*nu-1458))*y+(1/3125*(-162*nu+81)*x^3+1/156250*(1458*nu-729)*x^2+1/9765625*(-2187*nu+10935)*x+1/488281250*(-4374*nu-76545))/(x^6-9/25*x^5+27/125*x^4+1/3125*(-162*nu-54)*x^3+1/78125*(729*nu-486)*x^2+1/9765625*(-2187*nu+5832)*x+1/244140625*(-2187*nu-1458));\"\n            in page.get_data(as_text=True)\n        )\n        # in sage\n        page = self.tc.get(\n            \"/Belyi/download_galmap_to_sage/6T15-5.1_5.1_5.1-c\",\n            follow_redirects=True,\n        )\n        assert (\n           \"phi = (1/3125*(162*nu-81)*x^2+1/78125*(972*nu-486)*x+1/390625*(-1458*nu+729))/(x^6-9/25*x^5+27/125*x^4+1/3125*(-162*nu-54)*x^3+1/78125*(729*nu-486)*x^2+1/9765625*(-2187*nu+5832)*x+1/244140625*(-2187*nu-1458))*y+(1/3125*(-162*nu+81)*x^3+1/156250*(1458*nu-729)*x^2+1/9765625*(-2187*nu+10935)*x+1/488281250*(-4374*nu-76545))/(x^6-9/25*x^5+27/125*x^4+1/3125*(-162*nu-54)*x^3+1/78125*(729*nu-486)*x^2+1/9765625*(-2187*nu+5832)*x+1/244140625*(-2187*nu-1458))\"\n            in page.get_data(as_text=True)\n        )\n        # genus 2 example\n        # in magma\n        page = self.tc.get(\n            \"/Belyi/download_galmap_to_magma/7T5-7_7_3.3.1-a\",\n            follow_redirects=True,\n        )\n        assert (\n            \"phi := (1/2*x^2+2/5*x+1/200*(nu+5))/(x^5+6/5*x^4+1/50*(7*nu+5)*x^3+1/250*(35*nu-57)*x^2+1/10000*(91*nu-345)*x+1/12500*(-133*nu+71))*y+1/2;\"\n            in page.get_data(as_text=True)\n        )\n        # in sage\n        page = self.tc.get(\n            \"/Belyi/download_galmap_to_sage/7T5-7_7_3.3.1-a\",\n            follow_redirects=True,\n        )\n        assert (\n            \"phi = (1/2*x^2+2/5*x+1/200*(nu+5))/(x^5+6/5*x^4+1/50*(7*nu+5)*x^3+1/250*(35*nu-57)*x^2+1/10000*(91*nu-345)*x+1/12500*(-133*nu+71))*y+1/2\"\n            in page.get_data(as_text=True)\n        )\n\n        # Underlying data link\n        data = self.tc.get(\"/Belyi/data/7T5-7_7_3.3.1\", follow_redirects=True).get_data(as_text=True)\n        assert \"maxdegbf\" in data and \"orbit_size\" in data\n\n        data = self.tc.get(\"/Belyi/data/7T5-7_7_3.3.1-a\", follow_redirects=True).get_data(as_text=True)\n        assert \"friends\" in data and \"maxdegbf\" in data and \"portrait\" in data"
  },
  {
    "type": "function",
    "file": "lmfdb/elliptic_curves/elliptic_curve.py",
    "name": "render_bhkssw",
    "line_start": 996,
    "line_end": 1062,
    "lines": 67,
    "bytes": 4034,
    "has_71": true,
    "code": "def render_bhkssw():\n    info = to_dict(request.args)\n    learnmore = learnmore_list_remove('BHKSSW dataset')\n    t = 'Balakrishnan-Ho-Kaplan-Spicer-Stein-Watkins elliptic curve database'\n    bread = [(\"Datasets\", url_for(\"datasets\")), (\"BHKSSW dataset\", \" \")]\n    #if 'filename' in info:\n    #    filepath = os.path.join(os.path.expanduser('~/data/bhkssw_ecdb/' + info['filename']))\n    #    if os.path.isfile(filepath) and os.access(filepath, os.R_OK):\n    #        return send_file(filepath, as_attachment=True)\n    #    else:\n    #        flash_error('File {} not found'.format(info['filename']))\n    #        return redirect(url_for(\".render_bhkssw\"))\n    # This format was nice, but not possible with the 30-second timeout limitation\n    #info['files'] = [ # number of curves, size in MB, lower bound, upper bound, filename\n    #    (2249362, 151, \"0\", r\"1 \\cdot 10^8\", \"1e8db.txt\"),\n    #    (1758056, 123, r\"1 \\cdot 10^8\", r\"2 \\cdot 10^8\", \"2e8db.txt\"),\n    #    (11300506, 798, r\"2 \\cdot 10^8\", r\"1 \\cdot 10^9\", \"1e9db.txt\"),\n    #    (11982016, 866, r\"1 \\cdot 10^9\", r\"2 \\cdot 10^9\", \"2e9db.txt\"),\n    #    (10976368, 800, r\"2 \\cdot 10^9\", r\"3 \\cdot 10^9\", \"3e9db.txt\"),\n    #    (10395560, 768, r\"3 \\cdot 10^9\", r\"4 \\cdot 10^9\", \"4e9db.txt\"),\n    #    (9932368, 744, r\"4 \\cdot 10^9\", r\"5 \\cdot 10^9\", \"5e9db.txt\"),\n    #    (9584588, 720, r\"5 \\cdot 10^9\", r\"6 \\cdot 10^9\", \"6e9db.txt\"),\n    #    (9385318, 707, r\"6 \\cdot 10^9\", r\"7 \\cdot 10^9\", \"7e9db.txt\"),\n    #    (9071666, 685, r\"7 \\cdot 10^9\", r\"8 \\cdot 10^9\", \"8e9db.txt\"),\n    #    (8975214, 679, r\"8 \\cdot 10^9\", r\"9 \\cdot 10^9\", \"9e9db.txt\"),\n    #    (8788686, 666, r\"9 \\cdot 10^9\", r\"1.0 \\cdot 10^{10}\", \"10e9db.txt\"),\n    #    (8642210, 664, r\"1.0 \\cdot 10^{10}\", r\"1.1 \\cdot 10^{10}\", \"11e9db.txt\"),\n    #    (8477024, 652, r\"1.1 \\cdot 10^{10}\", r\"1.2 \\cdot 10^{10}\", \"12e9db.txt\"),\n    #    (8383290, 645, r\"1.2 \\cdot 10^{10}\", r\"1.3 \\cdot 10^{10}\", \"13e9db.txt\"),\n    #    (8275108, 638, r\"1.3 \\cdot 10^{10}\", r\"1.4 \\cdot 10^{10}\", \"14e9db.txt\"),\n    #    (8143456, 628, r\"1.4 \\cdot 10^{10}\", r\"1.5 \\cdot 10^{10}\", \"15e9db.txt\"),\n    #    (8106334, 626, r\"1.5 \\cdot 10^{10}\", r\"1.6 \\cdot 10^{10}\", \"16e9db.txt\"),\n    #    (7959996, 615, r\"1.6 \\cdot 10^{10}\", r\"1.7 \\cdot 10^{10}\", \"17e9db.txt\"),\n    #    (7903210, 611, r\"1.7 \\cdot 10^{10}\", r\"1.8 \\cdot 10^{10}\", \"18e9db.txt\"),\n    #    (7849564, 607, r\"1.8 \\cdot 10^{10}\", r\"1.9 \\cdot 10^{10}\", \"19e9db.txt\"),\n    #    (7781996, 602, r\"1.9 \\cdot 10^{10}\", r\"2.0 \\cdot 10^{10}\", \"20e9db.txt\"),\n    #    (7822372, 605, r\"2.0 \\cdot 10^{10}\", r\"2.1 \\cdot 10^{10}\", \"21e9db.txt\"),\n    #    (7636198, 591, r\"2.1 \\cdot 10^{10}\", r\"2.2 \\cdot 10^{10}\", \"22e9db.txt\"),\n    #    (7562706, 586, r\"2.2 \\cdot 10^{10}\", r\"2.3 \\cdot 10^{10}\", \"23e9db.txt\"),\n    #    (7593218, 588, r\"2.3 \\cdot 10^{10}\", r\"2.4 \\cdot 10^{10}\", \"24e9db.txt\"),\n    #    (7505566, 582, r\"2.4 \\cdot 10^{10}\", r\"2.5 \\cdot 10^{10}\", \"25e9db.txt\"),\n    #    (7409408, 575, r\"2.5 \\cdot 10^{10}\", r\"2.6 \\cdot 10^{10}\", \"26e9db.txt\"),\n    #    (7312946, 567, r\"2.6 \\cdot 10^{10}\", r\"2.7 \\cdot 10^{10}\", \"27e9db.txt\"),\n    #]\n    if 'Fetch' in info:\n        fname = \"{}.txt\"\n        kmax = 2699\n        errors = []\n        if 'k' in info and not errors:\n            k = info[\"k\"].strip()\n            if k.isdigit():\n                k = int(k)\n                if k <= kmax:\n                    fname = fname.format(k)\n                else:\n                    errors.append(f\"k must be at most {kmax}\")\n            else:\n                errors.append(f\"k must be a positive integer at most {kmax}\")\n        if not errors:\n            filepath = os.path.expanduser('~/data/bhkssw_split/' + fname)\n            if os.path.isfile(filepath) and os.access(filepath, os.R_OK):\n                return send_file(filepath, as_attachment=True)\n            errors.append(f\"File {fname} not found\")\n        for err in errors:\n            flash_error(err)\n\n    return render_template(\"bhkssw.html\", info=info, comma=comma, title=t, bread=bread, learnmore=learnmore)"
  },
  {
    "type": "class",
    "file": "lmfdb/elliptic_curves/test_browse_page.py",
    "name": "HomePageTest",
    "line_start": 4,
    "line_end": 104,
    "lines": 101,
    "bytes": 4392,
    "has_71": true,
    "code": "class HomePageTest(LmfdbTest):\n    # All tests should pass\n    #\n    # The page itself\n    def test_page(self):\n        r\"\"\"\n        Check that the elliptic curve/Q search & browse page works.\n        \"\"\"\n        homepage = self.tc.get(\"/EllipticCurve/Q/\").get_data(as_text=True)\n        assert 'Label or coefficients' in homepage\n\n    #\n    # Link to stats page\n    def test_stats(self):\n        r\"\"\"\n        Check that the link to the stats page works.\n        \"\"\"\n        homepage = self.tc.get(\"/EllipticCurve/Q/\").get_data(as_text=True)\n        self.check(homepage, \"/EllipticCurve/Q/stats\",\n                   'Distribution of <a title=\"Rank of an elliptic curve over a number field [ec.rank]\" knowl=\"ec.rank\" kwargs=\"\">rank</a>')\n\n    #\n    # Link to random curve\n    def test_random(self):\n        r\"\"\"\n        Check that the link to a random curve works.\n        \"\"\"\n        homepage = self.tc.get(\"/EllipticCurve/Q/\").get_data(as_text=True)\n        self.check(homepage, \"/EllipticCurve/Q/random\",\n                   'Minimal Weierstrass equation')\n\n    #\n    # Browsing links\n    def test_browse(self):\n        r\"\"\"\n        Check that the browsing links work.\n        \"\"\"\n        homepage = self.tc.get(\"/EllipticCurve/Q/\").get_data(as_text=True)\n        t = \"?conductor=100-999\"\n        assert t in homepage\n        self.check_args(\"/EllipticCurve/Q/%s\" % t,\n                        '[1, 0, 0, 1, 1]')\n        t = \"?rank=4\"\n        assert t in homepage\n        self.check_args(\"/EllipticCurve/Q/%s\" % t,\n                        '[1, -1, 0, -79, 289]')\n        t = \"?torsion=16\"\n        assert t in homepage\n        self.check_args(\"/EllipticCurve/Q/%s\" % t,\n                        '266910.ck5')\n\n    #\n    # Jump to specific curve or class\n    def test_jump(self):\n        r\"\"\"\n        Check that the link to a specific curve works.\n        \"\"\"\n        self.check_args(\"/EllipticCurve/Q/?jump=11.a2\", r'y^2+y=x^3-x^2-10x-20')\n        self.check_args(\"/EllipticCurve/Q/?jump=389.a\", 'Elliptic curves in class 389.a')\n        self.check_args(\"/EllipticCurve/Q/?jump=%5B0%2C1%2C1%2C-2%2C0%5D\", '0.15246')\n        self.check_args(\"/EllipticCurve/Q/?jump=%5B-3024%2C+46224%5D+\", '0.15246')\n\n        # Check that giving defining polynomials for f,h works\n        self.check_args(\"/EllipticCurve/Q/?jump=x%5E3+%2B+10*x+%2B+17%2C+x\", r\"\\frac{109902239}{176525}\")\n\n        # Check that giving a Weierstrass equation works, even without explicit multiplication '*'\n        self.check_args(\"/EllipticCurve/Q/?jump=b%5E2+%2B+ab+%3D+a%5E3+%2B+2a+%2B+1\", \"-0.756030189082\")\n\n        # Check that variables are only single characters\n        self.check_args(\"/EllipticCurve/Q/?jump=%28banana%29%5E2%3Dx%5E3%2B1\", \"does not define an elliptic curve\")\n\n        # Check that the coefficient of x^3 does not need to be 1\n        self.check_args(\"/EllipticCurve/Q/?jump=4x%5E3+%2B+4x+%2B+1\", '91a1')\n    #\n    # Various search combinations\n\n    def test_search(self):\n        r\"\"\"\n        Check that various search combinations work.\n        \"\"\"\n        self.check_args(\"/EllipticCurve/Q/?conductor=100-200&count=100\",\n                        '[0, -1, 1, -887, -10143]')\n        self.check_args_with_timeout(\"/EllipticCurve/Q/?rank=0&torsion=2&sha=4&count=100\",\n                        '[0, -1, 0, -10560, -414180]')\n        self.check_args(\"/EllipticCurve/Q/?conductor=&jinv=-4096%2F11&count=100\",\n                        '169136.i3')\n        self.check_args(\"/EllipticCurve/Q/?torsion=%5B2%2C4%5D&sha=&count=100\",\n                        '[0, 1, 0, -1664, -9804]')\n        self.check_args_with_timeout(\"/EllipticCurve/Q/?nonmax_quantifier=include&nonmax_primes=2,3&count=100\",\n                        '[1, -1, 1, -24575, 1488935]')\n        self.check_args_with_timeout(\"/EllipticCurve/Q/?nonmax_quantifier=exactly&nonmax_primes=5&optimal=on&count=100\",\n                        '[0, 0, 1, -75, 256]')\n        self.check_args(\"EllipticCurve/Q/?conductor=990&optimal=on\",\n                        '990h1')\n        L = self.tc.get(\"EllipticCurve/Q/?isogeny_degrees=13\")\n        assert '[0, 0, 1, -849658625, 9532675710156]' in L.get_data(as_text=True)\n        assert '[0, -1, 1, -10, -20]' not in L.get_data(as_text=True)\n\n        # Test error handling\n        L = self.tc.get(\"EllipticCurve/Q/?conductor=162&jinv=-1159088625%2F097152\")\n        assert ' is not a valid input' in L.get_data(as_text=True)"
  },
  {
    "type": "class",
    "file": "lmfdb/number_fields/test_numberfield.py",
    "name": "NumberFieldTest",
    "line_start": 3,
    "line_end": 99,
    "lines": 97,
    "bytes": 4468,
    "has_71": true,
    "code": "class NumberFieldTest(LmfdbTest):\n    # All tests should pass\n    def test_Q(self):\n        self.check_args('/NumberField/Q', r'\\chi_{1}')\n        self.check_args('/NumberField/1.1.1.1', r'\\chi_{1}')\n\n    def test_hard_degree10(self):\n        self.check_args('/NumberField/10.10.1107649855354064.1', '10T36')\n        self.check_args('/NumberField/10.10.138420300533025695415730492558689.1', '10T38')\n\n    def test_hard_degree16(self):\n        self.check_args('/NumberField/16.0.13307764731675384304522756096.1', '16T1535')\n\n    def test_search_ramif_cl_deg(self):\n        self.check_args('/NumberField/?degree=5&class_group=[2%2C2]&ur_primes=7&discriminant=&ram_quantifier=exactly&ram_primes=2%2C3%2C5', '5.1.27000000000.8')\n\n    def test_abelian_conductor(self):\n        self.check_args('/NumberField/5.5.5719140625.2', '275') # conductor\n\n    def test_stuff_not_computed(self):\n        self.check_args('/NumberField/23.23.931347256889446325436632107655346061164193665348344821578377438399536607931200329.1', 'ot computed')\n\n    def test_search_poly_mean2parser(self):\n        # X^3-4x+2\n        self.check_args('/NumberField/?jump=X**3-4x%2B2&search=Go', '3.3.148.1') # label\n        # z^3 - 4*z + 2\n        self.check_args('/NumberField/?jump=z%5E3+-+4*z%2B2', '3.3.148.1') # label\n\n    def test_search_zeta(self):\n        self.check_args('/NumberField/?jump=Qzeta23&search=Go', '[3]') # class group\n\n    def test_search_sqrt(self):\n        self.check_args('/NumberField/?jump=Qsqrt-163&search=Go', '41') # minpoly\n\n    def test_search_disc(self):\n        self.check_args('/NumberField/?discriminant=1988-2014', '401') # factor of one of the discriminants\n\n    def test_url_label(self):\n        self.check_args('/NumberField/2.2.5.1', '0.481211825') # regulator\n\n    def test_url_naturallabel(self):\n        self.check_args('/NumberField/Qsqrt5', '0.481211825') # regulator\n\n    def test_arith_equiv(self):\n        self.check_args('/NumberField/7.3.6431296.1', '7.3.6431296.2') # arith equiv field\n\n    def test_sextic_twin(self):\n        self.check_args('/NumberField/6.0.10816.1', 'Twin sextic algebra')\n\n    def test_how_computed(self):\n        self.check_args('/NumberField/Source', 'Hunter searches')\n\n    def test_galois_group_page(self):\n        self.check_args('/NumberField/GaloisGroups', 'abstract group may have')\n\n    def test_imaginary_quadratic_page(self):\n        self.check_args('/NumberField/QuadraticImaginaryClassGroups', 'extensive computations')\n\n    def test_discriminants_page(self):\n        self.check_args('/NumberField/Source', 'Jones-David Roberts')\n\n    def test_field_labels_page(self):\n        self.check_args('/NumberField/FieldLabels', 'with the same signature and absolute value of the')\n\n    def test_url_bad(self):\n        self.check_args('/NumberField/junk', 'Error')  # error message\n\n    def test_random_field(self):\n        self.check_args('/NumberField/random', 'Discriminant')\n\n    def test_statistics(self):\n        self.check_args('/NumberField/stats', 'Class number')\n\n    def test_signature_search(self):\n        self.check_args('/NumberField/?start=0&degree=6&signature=%5B0%2C3%5D&count=100', '6.0.61131.1')\n        self.check_args('/NumberField/?start=0&degree=7&signature=%5B3%2C2%5D&count=100', '7.3.1420409.1')\n\n    def test_relative_class_number(self):\n        self.check_args('/NumberField/4.0.1327873600.2', '2108')\n\n    def test_fundamental_units(self):\n        self.check_args('NumberField/2.2.10069.1', '43388173')\n        self.check_args('NumberField/3.3.10004569.1', '22153437467081345')\n\n    def test_split_ors(self):\n        self.check_args('/NumberField/?signature=%5B0%2C3%5D&galois_group=S3', '6.0.177147.2')\n        self.check_args('/NumberField/?signature=%5B3%2C0%5D&galois_group=S3', '3.3.229.1')\n        self.check_args('/NumberField/?signature=[4%2C0]&galois_group=C2xC2&class_number=3%2C6','4.4.1311025.1')\n        self.check_args('/NumberField/?signature=[4%2C0]&galois_group=C2xC2&class_number=6%2C3','4.4.1311025.1')\n        self.check_args('/NumberField/?signature=[4%2C0]&galois_group=C2xC2&class_number=5-6%2C3','4.4.485809.1')\n\n    def test_underlying_data(self):\n        self.check_args('NumberField/2.2.10069.1', ['Underlying data', 'data/2.2.10069.1'])\n\n    def test_errors(self):\n        self.check_args('NumberField/18.0.10490638424...4432.1/download/sage', 'Invalid label')\n        self.check_args('NumberField/4.3.2.1/download/sage', 'There is no number field with label 4.3.2.1')"
  },
  {
    "type": "class",
    "file": "lmfdb/lattice/test_lattice.py",
    "name": "HomePageTest",
    "line_start": 4,
    "line_end": 104,
    "lines": 101,
    "bytes": 4621,
    "has_71": true,
    "code": "class HomePageTest(LmfdbTest):\n    # The Lattice page\n    def test_lattice(self):\n        homepage = self.tc.get(\"/Lattice/\").get_data(as_text=True)\n        assert 'random' in homepage\n        assert 'Gram' in homepage\n\n    def test_lattice_dim(self):\n        L = self.tc.get(\"/Lattice/9.8.16.1.1\").get_data(as_text=True)\n        assert '115712' in L #coeff in theta series\n        assert '1.58740105196819947475170563927' in L #Hermite number\n        assert '11612160' in L #group order\n\n    def test_lattice_classnumber(self):\n        L = self.tc.get(\"/Lattice/?class_number=1\").get_data(as_text=True)\n        assert '2.13.26.1.2' in L #label (class number 1)\n\n    def test_lattice_classnumber_large(self):\n        L = self.tc.get(\"/Lattice/3.1942.3884.56.13\").get_data(as_text=True)\n        assert '648' in L #test display genus representatives\n\n    def test_lattice_classnumber_large_download(self):\n        L = self.tc.get(\"/Lattice/3.1942.3884.56.13/download/sage/genus_reps\").get_data(as_text=True)\n        assert 'Matrix([[2, 0, 0], [0, 14, -3], [0, -3, 70]]),' in L #test download genus representatives\n\n    def test_lattice_search(self):\n        L = self.tc.get(\"/Lattice/?dim=&det=&level=&gram=&minimum=&class_number=1&aut=&count=50\").get_data(as_text=True)\n        assert '56' in L #search\n\n    def test_lattice_search_next(self):\n        L = self.tc.get(\"/Lattice/?start=50&dim=&det=&level=&gram=&minimum=&class_number=&aut=2&count=50\").get_data(as_text=True)\n        assert '145' in L #search on the next page\n\n    def test_lattice_searchdim(self):\n        L = self.tc.get(\"/Lattice/?dim=3\").get_data(as_text=True)\n        assert '3.1.2.1.1' in L #dimension search\n\n    def test_lattice_searchlevel(self):\n        L = self.tc.get(\"/Lattice/?start=&dim=&det=&level=90&gram=&minimum=&class_number=&aut=\").get_data(as_text=True)\n        assert '16' in L #level search\n\n    def test_lattice_searchminvectlength(self):\n        L = self.tc.get(\"/Lattice/?dim=&det=&level=&gram=&minimum=3&class_number=&aut=\").get_data(as_text=True)\n        assert '2.42.84.1.3' in L #search minimum vector length\n\n    def test_lattice_searchGM(self):\n        L = self.tc.get(\"/Lattice/?dim=&det=&level=&gram=[17%2C6%2C138]&minimum=&class_number=&aut=\").get_data(as_text=True)\n        assert '4620' in L #gram matrix search\n\n    def test_lattice_searchGM_2(self):\n        L = self.tc.get(\"/Lattice/?dim=&det=&level=&gram=5%2C3%2C2&minimum=&class_number=&aut=\").get_data(as_text=True)\n        assert '2.1.2.1.1' in L #gram matrix search through isometries\n\n    def test_latticeZ2(self):\n        L = self.tc.get(\"/Lattice/2.1.2.1.1\").get_data(as_text=True)\n        assert r'0.785398163397448309615660845820\\dots' in L #Z2 lattice\n\n    def test_lattice_thetadisplay(self):\n        L = self.tc.get(\"/Lattice/theta_display/7.576.18.1.1/40\").get_data(as_text=True)\n        assert '41' in L # theta display\n        assert '1848' in L # theta display\n        assert '11466' in L # theta display\n\n    def test_lattice_random(self):\n        L = self.tc.get(\"/Lattice/random\").get_data(as_text=True)\n        assert 'redirected automatically' in L # random lattice\n        L = self.tc.get(\"/Lattice/random\", follow_redirects=True)\n        assert 'Normalized minimal vectors' in L.get_data(as_text=True) # check redirection\n\n    def test_downloadstring(self):\n        L = self.tc.get(\"/Lattice/5.648.12.1.1\").get_data(as_text=True)\n        assert 'matrix' in L\n\n    def test_downloadstring2(self):\n        L = self.tc.get(\"/Lattice/2.156.312.1.2\").get_data(as_text=True)\n        assert 'vector' in L\n        assert 'Underlying data' in L and 'data/2.156.312.1.2' in L\n\n    def test_downloadstring_search(self):\n        L = self.tc.get(\"/Lattice/?class_number=8\").get_data(as_text=True)\n        assert 'displayed columns' in L\n\n    def test_download_shortest(self):\n        L = self.tc.get(\"/Lattice/13.14.28.8.1/download/magma/shortest_vectors\").get_data(as_text=True)\n        assert 'data := ' in L\n\n    def test_download_genus(self):\n        L = self.tc.get(\"/Lattice/4.5.5.1.1/download/gp/genus_reps\").get_data(as_text=True)\n        assert ']~)' in L\n\n    def test_favorite(self):\n        for elt in ['A2', 'Z2', 'D3', 'D3*', '3.1942.3884.56.1', 'A5',\n                    'E8', 'A14', 'Leech']:\n            L = self.tc.get(\n                    \"/Lattice/?label={}\".format(elt),\n                    follow_redirects=True)\n            assert elt in L.get_data(as_text=True)\n            L = self.tc.get(\n                    \"/Lattice/{}\".format(elt),\n                    follow_redirects=True)\n            assert elt in L.get_data(as_text=True)"
  },
  {
    "type": "function",
    "file": "lmfdb/tests/test_utils.py",
    "name": "test_integer_set",
    "line_start": 210,
    "line_end": 310,
    "lines": 101,
    "bytes": 4791,
    "has_71": true,
    "code": "    def test_integer_set(self):\n        A = IntegerSet([2, 4])\n        B = IntegerSet([6, 9])\n        C = IntegerSet([-11, 5])\n        self.assertEqual(str(A + A), \"[4, 8]\")\n        self.assertEqual(str(A - A), \"[-2, 2]\")\n        self.assertEqual(str(A * A), \"[4, 16]\")\n        self.assertEqual(str(A / A), \"[1, 2]\")\n        self.assertEqual(str(-A), \"[-4, -2]\")\n        self.assertEqual(str(~A), \"[1/4, 1/2]\")\n        self.assertEqual(str(A + B), \"[8, 13]\")\n        self.assertEqual(str(A - B), \"[-7, -2]\")\n        self.assertEqual(str(A * B), \"[12, 36]\")\n        self.assertEqual(str(A / B), \"{}\")\n        self.assertEqual(str(A + C), \"[-9, 9]\")\n        self.assertEqual(str(A - C), \"[-3, 15]\")\n        self.assertEqual(str(A * C), \"[-44, 20]\")\n        self.assertEqual(str(A / C), \"[-4, -1] \u222a [1, 4]\")\n        self.assertEqual(str(B + A), \"[8, 13]\")\n        self.assertEqual(str(B - A), \"[2, 7]\")\n        self.assertEqual(str(B * A), \"[12, 36]\")\n        self.assertEqual(str(B / A), \"[2, 4]\")\n        self.assertEqual(str(B + B), \"[12, 18]\")\n        self.assertEqual(str(B - B), \"[-3, 3]\")\n        self.assertEqual(str(B * B), \"[36, 81]\")\n        self.assertEqual(str(B / B), \"{1}\")\n        self.assertEqual(str(-B), \"[-9, -6]\")\n        self.assertEqual(str(~B), \"[1/9, 1/6]\")\n        self.assertEqual(str(B + C), \"[-5, 14]\")\n        self.assertEqual(str(B - C), \"[1, 20]\")\n        self.assertEqual(str(B * C), \"[-99, 45]\")\n        self.assertEqual(str(B / C), \"[-9, -1] \u222a [2, 9]\")\n        self.assertEqual(str(C + A), \"[-9, 9]\")\n        self.assertEqual(str(C - A), \"[-15, 3]\")\n        self.assertEqual(str(C * A), \"[-44, 20]\")\n        self.assertEqual(str(C / A), \"[-5, 2]\")\n        self.assertEqual(str(C + B), \"[-5, 14]\")\n        self.assertEqual(str(C - B), \"[-20, -1]\")\n        self.assertEqual(str(C * B), \"[-99, 45]\")\n        self.assertEqual(str(C / B), \"[-1, 0]\")\n        self.assertEqual(str(C + C), \"[-22, 10]\")\n        self.assertEqual(str(C - C), \"[-16, 16]\")\n        self.assertEqual(str(C * C), \"[-55, 121]\")\n        self.assertEqual(str(C / C), \"[-11, 11]\")\n        self.assertEqual(str(-C), \"[-5, 11]\")\n        self.assertEqual(str(~C), \"(-oo, -1/11] \u222a [1/5, +oo)\")\n        self.assertEqual(str(abs(C)), \"[0, 11]\")\n\n        self.assertEqual(str(B.pow_cap(A, 1.5)), \"[6, 8]\")\n        self.assertEqual(str(A.union(B, C)), \"[-11, 9]\")\n        self.assertEqual(str(C.intersection(A * A)), \"[4, 5]\")\n        self.assertEqual(str(C.difference(-A,A)), \"[-11, -5] \u222a [-1, 1] \u222a {5}\")\n        self.assertEqual(A.is_subset(C), True)\n        self.assertEqual(B.is_subset(A + A), False)\n        self.assertEqual(A <= B, True)\n        self.assertEqual(A <= A + A, True)\n        self.assertEqual(C <= A + A, False)\n        self.assertEqual(A < B, True)\n        self.assertEqual(A < A + A, False)\n        self.assertEqual(A.bounded(5), True)\n        self.assertEqual(A.bounded(4), True)\n        self.assertEqual(A.bounded(3), False)\n        self.assertEqual(A.bounded(2,4), True)\n        self.assertEqual(A.restricted(), True)\n        self.assertEqual(IntegerSet(None).restricted(), False)\n        self.assertEqual(A.min(), 2)\n        self.assertEqual(A.max(), 4)\n        self.assertEqual(top(4).min(), -infinity)\n        self.assertEqual(top(4).max(), 4)\n\n        self.assertEqual(list(IntegerSet([5, 40]).stickelberger(2, [0])), [(5,), (2,), (2, 3), (13,), (17,), (3, 7), (2, 3), (2, 7), (29,), (3, 11), (37,), (2, 5)])\n        self.assertEqual(list(IntegerSet([3, 40]).stickelberger(2, [1])), [(3,), (2,), (7,), (2,), (11,), (3, 5), (19,), (2, 5), (23,), (2, 3), (31,), (5, 7), (3, 13), (2, 5)])\n        self.assertEqual(list(IntegerSet([200, 220]).stickelberger(3, [0])), [(2, 5), (3, 67), (2, 3, 17), (5, 41), (2, 13), (11, 19), (2, 53), (3, 71), (2, 3), (7, 31), (2, 5, 11)])\n\n        self.assertEqual(A.is_finite(), True)\n        self.assertEqual(IntegerSet(None).is_finite(), False)\n        self.assertEqual(top(4).is_finite(), False)\n        self.assertEqual(bottom(4).is_finite(), False)\n\n        X = [\n            (3, 150000), # 3\n            (4, 100000), # 4\n            ([5,14], 50000), # 7,8,11\n            (15, 1000), # 15\n            ([16,19], 15000), # 19\n            (20, 1000), # 20\n            ([21,23], 3000), # 23\n            (24, 1000), # 24\n            ([25,34], 5000), # 31\n            ([35,40], 1000), # 35,39,40\n            ([41,46], 15000), # 43\n            ([47, 59], 1000), # 47,51,52,55,56,59\n            ([60, 67], 10000), # 67\n            ([68, 120], 1000),\n            ([121, 159], 100),\n            ([160, 163], 5000), # 163\n            ([164, 702], 100), # 703 is the first missing\n        ]\n        self.assertEqual(A.bound_under(X), None)\n        self.assertEqual((A + A).bound_under(X), 50000)\n        self.assertEqual((A * B).bound_under(X), 1000)"
  },
  {
    "type": "function",
    "file": "lmfdb/number_fields/number_field.py",
    "name": "statistics",
    "line_start": 267,
    "line_end": 370,
    "lines": 104,
    "bytes": 5622,
    "has_71": true,
    "code": "def statistics():\n    fields = db.nf_fields\n    nfstatdb = fields.stats\n    title = 'Number field statistics'\n    bread = bread_prefix() + [('Statistics', '')]\n    init_nf_count()\n    ntrans = [0, 1, 1, 2, 5, 5, 16, 7, 50, 34, 45, 8, 301, 9, 63, 104, 1954,\n              10, 983, 8, 1117, 164, 59, 7, 25000, 211, 96, 2392, 1854, 8, 5712]\n    degree_stats = nfstatdb.column_counts('degree')\n    n = [degree_stats[elt + 1] for elt in range(23)]\n\n    degree_r2_stats = nfstatdb.column_counts(['degree', 'r2'])\n    # if a count is missing it is because it is zero\n    nsig = [[degree_r2_stats.get((deg+1, s), 0) for s in range((deg+3)//2)]\n            for deg in range(23)]\n    # Galois groups\n    nt_stats = nfstatdb.column_counts(['degree', 'galois_label'])\n    nt_stats = {(key[0], int(key[1].split('T')[1])): value for key, value in nt_stats.items()}\n    # if a count is missing it is because it is zero\n    nt_all = [[nt_stats.get((deg+1, t+1), 0) for t in range(ntrans[deg+1])]\n              for deg in range(23)]\n    nt = [nt_all[j] for j in range(7)]\n    # Galois group families\n    cn = galstatdict([u[0] for u in nt_all], n, [1 for u in nt_all])\n    sn = galstatdict([u[max(len(u)-1,0)] for u in nt_all], n, [len(u) for u in nt_all])\n    an = galstatdict([u[max(len(u)-2,0)] for u in nt_all], n, [len(u)-1 for u in nt_all])\n    # t-numbers for D_n\n    dn_tlist = [1, 1, 2, 3, 2, 3, 2, 6, 3, 3, 2, 12, 2, 3, 2, 56, 2, 13, 2, 10,\n                5, 3, 2]\n    dn = galstatdict([nt_stats[(j+1,dn_tlist[j])] for j in range(len(dn_tlist))], n, dn_tlist)\n\n    hdeg_stats = {j: nfstatdb.column_counts('degree', {'class_number': {'$lt': 1+10**j, '$gt': 10**(j-1)}}) for j in range(1, 12)}\n    hdeg_stats[0] = nfstatdb.column_counts('degree', {'class_number': 1})\n    h = [sum(hdeg_stats[j].get(k+1,0) for k in range(max_deg)) for j in range(12)]\n    # if a count is missing it is because it is zero\n    hdeg = [[hdeg_stats[j].get(deg+1, 0) for j in range(12)] for deg in range(23)]\n    has_hdeg_stats = nfstatdb.column_counts('degree', {'class_number': {'$exists': True}})\n    has_hdeg = [has_hdeg_stats[deg+1] for deg in range(23)]\n    has_h = sum(has_hdeg[j] for j in range(len(has_hdeg)))\n    hdeg = [[{'cnt': comma(hdeg[nn][j]),\n              'prop': format_percentage(hdeg[nn][j], has_hdeg[nn]),\n              'query': url_for(\".number_field_render_webpage\")+'?degree=%d&class_number=%s' % (nn + 1, str(1 + 10**(j - 1)) + '-' + str(10**j))}\n             for j in range(len(h))]\n            for nn in range(len(hdeg))]\n\n    has_hdeg = [{'cnt': comma(has_hdeg[nn]),\n                 'prop': format_percentage(has_hdeg[nn], n[nn]),\n                 'query': url_for(\".number_field_render_webpage\")+'?degree=%d&class_number=1-10000000000000' % (nn + 1)} for nn in range(len(has_hdeg))]\n    maxt = 1+max([len(entry) for entry in nt])\n\n    nt = [[{'cnt': comma(nt[nn][tt]),\n            'prop': format_percentage(nt[nn][tt], n[nn]),\n            'query': url_for(\".number_field_render_webpage\")+'?degree=%d&galois_group=%s' % (nn + 1, \"%dt%d\" % (nn + 1, tt + 1))}\n           for tt in range(len(nt[nn]))]\n          for nn in range(len(nt))]\n    # Totals for signature table\n    sigtotals = [comma(\n                 sum([nsig[nn][r2]\n                 for nn in range(max(r2*2 - 1, 0), 23)]))\n                 for r2 in range(12)]\n    nsig = [[{'cnt': comma(nsig[nn][r2]),\n             'prop': format_percentage(nsig[nn][r2], n[nn]),\n             'query': url_for(\".number_field_render_webpage\")+'?degree=%d&signature=[%d,%d]' % (nn+1,nn+1-2*r2,r2)} for r2 in range(len(nsig[nn]))] for nn in range(len(nsig))]\n    h = [{'cnt': comma(h[j]),\n          'prop': format_percentage(h[j], has_h),\n          'label': '$10^{' + str(j - 1) + r'}<h\\leq 10^{' + str(j) + '}$',\n          'query': url_for(\".number_field_render_webpage\")+'?class_number=%s' % (str(1 + 10**(j - 1)) + '-' + str(10**j))} for j in range(len(h))]\n    h[0]['label'] = '$h=1$'\n    h[1]['label'] = r'$1<h\\leq 10$'\n    h[2]['label'] = r'$10<h\\leq 10^2$'\n    h[0]['query'] = url_for(\".number_field_render_webpage\")+'?class_number=1'\n\n    # Class number 1 by signature\n    sigclass1 = nfstatdb.column_counts(['degree', 'r2'], {'class_number': 1})\n    sighasclass = nfstatdb.column_counts(['degree', 'r2'], {'class_number': {'$exists': True}})\n    sigclass1 = [[{'cnt': comma(sigclass1.get((nn+1,r2),0)),\n                   'prop': format_percentage(sigclass1.get((nn+1,r2),0), sighasclass.get((nn+1,r2),0)) if sighasclass.get((nn+1,r2),0) > 0 else 0,\n                   'show': sighasclass.get((nn+1,r2),0) > 0,\n                   'query': url_for(\".number_field_render_webpage\")+'?degree=%d&signature=[%d,%d]&class_number=1' % (nn + 1, nn + 1 - 2*r2, r2)}\n                  for r2 in range(len(nsig[nn]))] for nn in range(len(nsig))]\n\n    n = [{'cnt': comma(n[nn]),\n          'prop': format_percentage(n[nn], nfields),\n          'query': url_for(\".number_field_render_webpage\")+'?degree=%d' % (nn + 1)}\n         for nn in range(len(n))]\n\n    info = {'degree': n,\n            'nt': nt,\n            'nsig': nsig,\n            'sigtotals': sigtotals,\n            'h': h,\n            'has_h': comma(has_h),\n            'has_h_pct': format_percentage(has_h, nfields),\n            'hdeg': hdeg,\n            'has_hdeg': has_hdeg,\n            'sigclass1': sigclass1,\n            'total': comma(nfields),\n            'maxt': maxt,\n            'cn': cn, 'dn': dn, 'an': an, 'sn': sn,\n            'maxdeg': max_deg}\n    return render_template(\"nf-statistics.html\",\n                           info=info,\n                           title=title,\n                           bread=bread)"
  },
  {
    "type": "class",
    "file": "lmfdb/siegel_modular_forms/test_siegel_modular_forms.py",
    "name": "HomePageTest",
    "line_start": 6,
    "line_end": 163,
    "lines": 158,
    "bytes": 6400,
    "has_71": true,
    "code": "class HomePageTest(LmfdbTest):\n    def check(self, url, text):\n        data = self.tc.get(\"/ModularForm/GSp/Q/\" + url, follow_redirects=True).get_data(as_text=True)\n        if isinstance(text, list):\n            for t in text:\n                assert t in data, (\n                    \"expected string '%s' not found in page /ModularForm/GSp/Q/%s\"\n                    % (t, url)\n                )\n        else:\n            assert text in data\n\n    def test_random_page(self):\n        \"\"\"\n        Test 3 random sample pages\n        \"\"\"\n        self.check(\"random\", \"Hecke eigenform\")\n        self.check(\"random\", \"Hecke eigenform\")\n        self.check(\"random\", \"Hecke eigenform\")\n\n    def test_browse_page(self):\n        \"\"\"\n        Test the top level browse pages\n        \"\"\"\n        self.check(\"Sp4Z_j/\", \"Upsilon\")\n        self.check(\n            \"Sp4Z/\",\n            [\"Galois orbits\", \"Klingen\", \"Eisenstein\", \"Maass\", \"Saito-Kurokawa\"],\n        )\n        self.check(\"Sp4Z_2/\", [\"Galois orbits\", \"Cusp\", \"Non cusp\", \"Satoh bracket\"])\n        self.check(\"Kp/\", \"in level 277, the\")\n        self.check(\"Sp6Z/\", \"Miyawaki (1)\")\n        self.check(\"Sp8Z/\", \"Other_II (2)\")\n        self.check(\"Gamma0_2/\", \"Gamma_0(2)\")\n        self.check(\"Gamma1_2/\", \"Gamma_1(2)\")\n        self.check(\"Gamma_2/\", \"Gamma(2)\")\n        self.check(\"Gamma0_3/\", \"Gamma_0(3)\")\n        self.check(\"Gamma0_3_psi_3/\", \"Gamma_0(3)\")\n        self.check(\"Gamma0_4/\", \"Gamma_0(4)\")\n        self.check(\"Gamma0_4_psi_4/\", \"Gamma_0(4)\")\n        self.check(\"Gamma0_4_half/\", \"k-1/2\")\n        self.check(\"Sp4Z_j/10/10/\", \"M_{10,10}\")\n        self.check(\"Sp4Z/10/\", \"M_{10,0}\")\n        self.check(\"Sp4Z_2/10/\", \"M_{10,2}\")\n\n    def test_dimension_tables(self):\n        \"\"\"\n        Test dimension table pages\n        \"\"\"\n        self.check(\"?family=Sp4Z_j&k=&j=&table=1\", [\"Cusp\", \"Non cusp\"])\n        self.check(\"?family=Sp4Z_j&k=&j=2&table=1\", [\"Cusp\", \"Non cusp\"])\n        self.check(\"?family=Gamma0_2&k=&j=&table=1\", [\"Cusp\", \"Non cusp\"])\n        self.check(\"?family=Gamma0_2&k=&j=2&table=1\", [\"Cusp\", \"Non cusp\"])\n        self.check(\"?family=Gamma1_2&k=&j=&table=1\", [\"111\", \"21\"])\n        self.check(\"?family=Gamma1_2&k=&j=2&table=1\", [\"111\", \"21\"])\n        self.check(\"?family=Gamma_2&k=&j=&table=1\", [\"111111\", \"3111\"])\n        self.check(\"?family=Gamma_2&k=&j=2&table=1\", [\"111111\", \"3111\"])\n        self.check(\"?family=Gamma0_3&k=&j=&table=1\", [\"Total\", \"74\"])\n        self.check(\"?family=Gamma0_3&k=&j=2&table=1\", \"should not be specified\")\n        self.check(\"?family=Gamma0_3_psi_3&k=&j&table=1\", [\"Total\", \"68\"])\n        self.check(\"?family=Gamma0_3_psi_3&k=&j=2&table=1\", \"should not be specified\")\n        self.check(\"?family=Gamma0_4&k=&j=&table=1\", [\"Total\", \"192\"])\n        self.check(\"?family=Gamma0_4&k=&j=2&table=1\", \"should not be specified\")\n        self.check(\"?family=Gamma0_4_psi_4&k=&j&table=1\", [\"Total\", \"495\"])\n        self.check(\"?family=Gamma0_4_psi_4&k=&j=2&table=1\", \"should not be specified\")\n        self.check(\"?family=Gamma0_4_half&k=&j&table=1\", [\"Cusp\", \"129\"])\n        self.check(\"?family=Gamma0_4_half&k=&j=2&table=1\", \"should not be specified\")\n        self.check(\"?family=Sp6Z&k=&j&table=1\", [\"Miyawaki lifts\", \"conjectured\"])\n        self.check(\"?family=Sp6Z&k=&j=2&table=1\", \"should not be specified\")\n        self.check(\"?family=Sp8Z&k=&j&table=1\", [\"Ikeda lifts\", \"Miyawaki lifts\"])\n        self.check(\"?family=Sp8Z&k=&j=2&table=1\", \"should not be specified\")\n\n    def test_sample_page_Q(self):\n        \"\"\"\n        Test eigenvalue, Fourier coefficient, and modulus selection on a sample page with coefficient field Q\n        \"\"\"\n        self.check(\n            \"Sp4Z.24_E\",\n            [\"35184384671745\", \"19664276334286895123835070363311360\", \"...\"],\n        )\n        self.check(\n            \"Sp4Z.24_E?ev_index=19&fc_det=0&modulus=&update=1\",\n            [\n                \"3498743002442937227729601361394364486949008189359690164120\",\n                \"3398215376663749994606261280\",\n                \"(0, 0, 25)\",\n            ],\n        )\n        self.check(\n            \"Sp4Z.24_E/?ev_index=&fc_det=&modulus=1000000007&update=1\",\n            [\"384425457\", \"(1, 1, 1)\", \"384425457\"],\n        )\n\n    def test_sample_page_nf(self):\n        \"\"\"\n        Test eigenvalue, Fourier coefficient, and modulus selection on a sample page with quadratic coefficient field\n        \"\"\"\n        self.check(\n            \"Sp4Z.18_Maass/\",\n            [\n                \"Maass spezialschaar\",\n                \"x^{2} - x - 589050\",\n                \"$-144 a + 135840$\",\n                \"$10 a - 8340$\",\n            ],\n        )\n        self.check(\n            \"Sp4Z.18_Maass/?ev_index=&fc_det=&modulus=17%2Ca%2B1&update=1\",\n            \"is the unit ideal, please specify\",\n        )\n        self.check(\n            \"Sp4Z.18_Maass/?ev_index=&fc_det=&modulus=65537&update=1\",\n            [\"$5$\", \"$-1378 a - 22820$\", \"(2, 2, 2)\", \"$32016 a + 5274$\"],\n        )\n\n    def test_huge_sample(self):\n        \"\"\"\n        Test sample page with defining equation and explicit formula too large to display\n        \"\"\"\n        self.check(\n            \"Sp4Z.56_Ups\", [\"interesting cusp form\", \"6085 bytes\", \"7912968 bytes\"]\n        )\n\n    def test_all_sample_pages(self):\n        \"\"\"\n        Verify that every sample form home page loads OK (should take under 10s on atkin)\n        \"\"\"\n        errors = []\n        data = list(\n            db.smf_samples.search(\n                {\"collection\": {\"$exists\": True}, \"name\": {\"$exists\": True}},\n                [\"collection\", \"name\"],\n            )\n        )\n        assert len(data) >= 129\n        n = 0\n        print()\n        import sys\n\n        for s in data:\n            full_label = s[\"collection\"][0] + \".\" + s[\"name\"]\n            sys.stdout.write(\"Checking {}...\".format(full_label))\n            sys.stdout.flush()\n            try:\n                n = n + 1\n                self.check(full_label, [full_label, \"Hecke eigenform\"])\n            except Exception:\n                print(\"\\nError on page \" + full_label)\n                errors.append(full_label)\n        if not errors:\n            print(\"\\nTested %s SMF pages with no errors\" % n)\n        else:\n            print(\n                \"\\nTested %d pages with %d errors occurring on the following pages:\"\n                % (n, len(errors))\n            )\n            for label in errors:\n                print(label)"
  },
  {
    "type": "function",
    "file": "lmfdb/lfunctions/test_lfunctions.py",
    "name": "test_Lec",
    "line_start": 40,
    "line_end": 151,
    "lines": 112,
    "bytes": 6891,
    "has_71": true,
    "code": "    def test_Lec(self):\n        L = self.tc.get('/L/EllipticCurve/Q/11/a/', follow_redirects=True)\n        assert '0.253841' in L.get_data(as_text=True)\n        assert 'Elliptic curve 11.a' in L.get_data(as_text=True)\n        assert 'Modular form 11.2.a.a' in L.get_data(as_text=True)\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n        assert '2-11-1.1-c1-0-0' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/2/11/1.1/c1/0/0/')\n        assert '6.362613894713' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/Q/27/a/', follow_redirects=True)\n        assert '0.5888795834' in L.get_data(as_text=True)\n        assert 'Elliptic curve 27.a' in L.get_data(as_text=True)\n        assert 'Modular form 27.2.a.a' in L.get_data(as_text=True)\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n        assert '2-3e3-1.1-c1-0-0' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/2/3e3/1.1/c1/0/0/')\n        assert '4.043044013797' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/Q/379998/d/', follow_redirects=True)\n        assert '9.364311197' in L.get_data(as_text=True)\n        assert 'Elliptic curve 379998.d' in L.get_data(as_text=True)\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n        assert '2-379998-1.1-c1-0-2' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/2/379998/1.1/c1/0/2/')\n        assert '0.8292065891985' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/2.2.5.1/31.1/a/', follow_redirects=True)\n        assert '0.3599289594' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.2.5.1-31.1-a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.2.5.1-31.2-a' in L.get_data(as_text=True)\n        assert 'Hilbert modular form 2.2.5.1-31.1-a' in L.get_data(as_text=True)\n        assert 'Hilbert modular form 2.2.5.1-31.2-a' in L.get_data(as_text=True)\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n        assert '4-775-1.1-c1e2-0-0' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/2.2.5.1/80.1/a/', follow_redirects=True)\n        assert '0.5945775518' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.2.5.1-80.1-a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 20.a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 100.a' in L.get_data(as_text=True)\n        assert 'Hilbert modular form 2.2.5.1-80.1-a' in L.get_data(as_text=True)\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n        assert '4-2000-1.1-c1e2-0-0' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/2.0.11.1/256.1/a/', follow_redirects=True)\n        assert 'Elliptic curve 2.0.11.1-256.1-a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.0.11.1-256.1-b' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.2.44.1-16.1-a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.2.44.1-16.1-c' in L.get_data(as_text=True)\n        assert 'Hilbert modular form 2.2.44.1-16.1-a' in L.get_data(as_text=True)\n        assert 'Hilbert modular form 2.2.44.1-16.1-c' in L.get_data(as_text=True)\n        assert 'Bianchi modular form 2.0.11.1-256.1-a' in L.get_data(as_text=True)\n        assert 'Bianchi modular form 2.0.11.1-256.1-b' in L.get_data(as_text=True)\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n        assert '4-176e2-1.1-c1e2-0-4' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/2.0.1879.1/1.1/a/', follow_redirects=True)\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.0.1879.1-1.1-a' in L.get_data(as_text=True)\n        assert '4-1879e2-1.1-c1e2-0-0' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/2.0.4.1/100.2/a/', follow_redirects=True)\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n        assert '0.5352579714' in L.get_data(as_text=True)\n        assert 'Bianchi modular form 2.0.4.1-100.2-a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.0.4.1-100.2-a' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Elliptic curve 20.a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 80.b' in L.get_data(as_text=True)\n        assert 'Modular form 20.2.a.a' in L.get_data(as_text=True)\n        assert 'Modular form 80.2.a.b' in L.get_data(as_text=True)\n        assert '4-40e2-1.1-c1e2-0-1' in L.get_data(as_text=True)\n        # check the zeros across factors\n        assert '2.76929890617261215013507568311' in L.get_data(as_text=True)\n        assert '4.78130792717525308450176413839' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/20/2/a/a/', follow_redirects=True)\n        assert '4.78130792717525308450176413839' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/Q/20/a/', follow_redirects=True)\n        assert '4.781307927175253' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/80/2/a/b/', follow_redirects=True)\n        assert '2.76929890617261215013507568311' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/Q/80/b/', follow_redirects=True)\n        assert '2.769298906172612' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/2.0.3.1/75.1/a/', follow_redirects=True)\n        assert 'Bianchi modular form 2.0.3.1-75.1-a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.0.3.1-75.1-a' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Elliptic curve 15.a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 45.a' in L.get_data(as_text=True)\n        assert 'Modular form 15.2.a.a' in L.get_data(as_text=True)\n        assert 'Modular form 45.2.a.a' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/2.0.8.1/2592.3/c/', follow_redirects=True)\n        assert 'Bianchi modular form 2.0.8.1-2592.3-c' in L.get_data(as_text=True)\n        assert 'Hilbert modular form 2.2.8.1-2592.1-f' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.0.8.1-2592.3-c' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.2.8.1-2592.1-f' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Elliptic curve 288.a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 576.i' in L.get_data(as_text=True)\n        assert 'Modular form 288.2.a.a' in L.get_data(as_text=True)\n\n        # check we get same L-fcn across 2 instances\n        for url in ['EllipticCurve/2.0.11.1/11.1/a/', 'ModularForm/GL2/ImaginaryQuadratic/2.0.11.1/11.1/a/']:\n            L = self.tc.get('/L/' + url, follow_redirects=True)\n            assert '4-11e3-1.1-c1e2-0-0' in L.get_data(as_text=True)"
  },
  {
    "type": "function",
    "file": "lmfdb/galois_groups/transitive_group.py",
    "name": "get_aliases",
    "line_start": 756,
    "line_end": 982,
    "lines": 227,
    "bytes": 7129,
    "has_71": true,
    "code": "def get_aliases():\n    aliases = {}\n\n    # Do all cyclic groups as once\n    for j in range(1,48):\n        if j != 32:\n            aliases['C'+str(j)] = [(j,1)]\n    aliases['C32'] = [(32,33)]\n\n    # For direct products, factors must be reverse-sorted\n    # All nicknames here must be all upper-case\n\n    aliases['S1'] = [(1, 1)]\n    aliases['A1'] = [(1, 1)]\n    aliases['A2'] = [(1, 1)]\n    aliases['S2'] = [(2, 1)]\n    aliases['D1'] = [(2, 1)]\n    aliases['A3'] = [(3, 1)]\n    aliases['S3'] = [(3, 2)]\n    aliases['D3'] = [(3, 2)]\n    aliases['V4'] = [(4, 2)]\n    aliases['D2'] = [(4, 2)]\n    aliases['D4'] = [(4, 3)]\n    aliases['C2XC2'] = [(4, 2)]\n    aliases['A4'] = [(4, 4)]\n    aliases['S4'] = [(4, 5)]\n    aliases['D5'] = [(5, 2)]\n    aliases['F5'] = [(5, 3)]\n    aliases['A5'] = [(5, 4)]\n    aliases['S5'] = [(5, 5)]\n    aliases['D6'] = [(6, 3)]\n    aliases['PSL(2,5)'] = aliases['A5']\n    aliases['PGL(2,5)'] = aliases['S5']\n    aliases['A6'] = [(6, 15)]\n    aliases['S6'] = [(6, 16)]\n    aliases['D7'] = [(7, 2)]\n    aliases['F7'] = [(7, 4)]\n    aliases['GL(3,2)'] = [(7, 5)]\n    aliases['A7'] = [(7, 6)]\n    aliases['S7'] = [(7, 7)]\n    aliases['C4XC2'] = [(8, 2)]\n    aliases['C2XC2XC2'] = [(8, 3)]\n    aliases['Q8'] = [(8, 5)]\n    aliases['D8'] = [(8, 6),(16,7)]\n    aliases['SL(2,3)'] = [(8, 12)]\n    aliases['GL(2,3)'] = [(8, 23)]\n    aliases['PSL(2,7)'] = aliases['GL(3,2)']\n    aliases['PGL(2,7)'] = [(8, 43)]\n    aliases['A8'] = [(8, 49)]\n    aliases['S8'] = [(8, 50)]\n    aliases['C3XC3'] = [(9, 2)]\n    aliases['D9'] = [(9, 3)]\n    aliases['S3XC3'] = [(6, 5)]\n    aliases['S3XS3'] = [(6, 9)]\n    aliases['M9'] = [(9, 14)]\n    aliases['PSL(2,8)'] = [(9, 27)]\n    aliases['A9'] = [(9, 33)]\n    aliases['S9'] = [(9, 34)]\n    aliases['D10'] = [(10, 3)]\n    aliases['PSL(2,9)'] = aliases['A6']\n    aliases['PGL(2,9)'] = [(10, 30)]\n    aliases['M10'] = [(10, 31)]\n    aliases['A10'] = [(10, 44)]\n    aliases['S10'] = [(10, 45)]\n    aliases['D11'] = [(11, 2)]\n    aliases['F11'] = [(11, 4)]\n    aliases['PSL(2,11)'] = [(11, 5)]\n    aliases['M11'] = [(11, 6)]\n    aliases['A11'] = [(11, 7)]\n    aliases['S11'] = [(11, 8)]\n    aliases['C6XC2'] = [(12, 2)]\n    aliases['C3:C4'] = [(12, 5)]\n    aliases['D12'] = [(12,12)]\n    aliases['A12'] = [(12, 300)]\n    aliases['S12'] = [(12, 301)]\n    aliases['F13'] = [(13, 6)]\n    aliases['A13'] = [(13, 8)]\n    aliases['S13'] = [(13, 9)]\n    aliases['PGL(2,13)'] = [(14, 39)]\n    aliases['A14'] = [(14, 62)]\n    aliases['S14'] = [(14, 63)]\n    aliases['A15'] = [(15, 103)]\n    aliases['S15'] = [(15, 104)]\n    aliases['Q8XC2'] = [(16, 7)]\n    aliases['C4:C4'] = [(16, 8)]\n    aliases['Q16'] = [(16, 14)]\n    aliases['A16'] = [(16, 1953)]\n    aliases['S16'] = [(16, 1954)]\n    aliases['F17'] = [(17, 5)]\n    aliases['PSL(2,17)'] = [(17, 6)]\n    aliases['A17'] = [(17, 9)]\n    aliases['S17'] = [(17, 10)]\n    aliases['PGL(2,17)'] = [(18, 468)]\n    aliases['A18'] = [(18, 982)]\n    aliases['S18'] = [(18, 983)]\n    aliases['A19'] = [(19, 7)]\n    aliases['S19'] = [(19, 8)]\n    aliases['C5:C4'] = [(20, 2)]\n    aliases['PGL(2,19)'] = [(20, 362)]\n    aliases['A20'] = [(20, 1116)]\n    aliases['S20'] = [(20, 1117)]\n    aliases['A21'] = [(21, 163)]\n    aliases['S21'] = [(21, 164)]\n    aliases['A22'] = [(22, 58)]\n    aliases['S22'] = [(22, 59)]\n    aliases['F23'] = [(23, 3)]\n    aliases['M23'] = [(23, 5)]\n    aliases['A23'] = [(23, 6)]\n    aliases['S23'] = [(23, 7)]\n    aliases['Q8XC3'] = [(24, 4)]\n    aliases['C3:Q8'] = [(24, 5)]\n    aliases['C3:C8'] = [(24, 8)]\n    aliases['A24'] = [(24,24999)]\n    aliases['S24'] = [(24,25000)]\n    aliases['A25'] = [(25,210)]\n    aliases['S25'] = [(25,211)]\n    aliases['A26'] = [(26,95)]\n    aliases['S26'] = [(26,96)]\n    aliases['A27'] = [(27,2391)]\n    aliases['S27'] = [(27,2392)]\n    aliases['C7:C4'] = [(28, 3)]\n    aliases['A28'] = [(28,1853)]\n    aliases['S28'] = [(28,1854)]\n    aliases['A29'] = [(29,7)]\n    aliases['S29'] = [(29,8)]\n    aliases['A30'] = [(30,5711)]\n    aliases['S30'] = [(30,5712)]\n    aliases['A31'] = [(31,11)]\n    aliases['S31'] = [(31,12)]\n    aliases['Q32'] = [(32, 51)]\n    aliases['A32'] = [(32,2801323)]\n    aliases['S32'] = [(32,2801324)]\n    aliases['A33'] = [(33,161)]\n    aliases['S33'] = [(33,162)]\n    aliases['A34'] = [(34,114)]\n    aliases['S34'] = [(34,115)]\n    aliases['A35'] = [(35,406)]\n    aliases['S35'] = [(35,407)]\n    aliases['A36'] = [(36,121278)]\n    aliases['S36'] = [(36,121279)]\n    aliases['A37'] = [(37,10)]\n    aliases['S37'] = [(37,11)]\n    aliases['A38'] = [(38,75)]\n    aliases['S38'] = [(38,76)]\n    aliases['A39'] = [(39,305)]\n    aliases['S39'] = [(39,306)]\n    aliases['C5:C8'] = [(40, 3)]\n    aliases['A40'] = [(40,315841)]\n    aliases['S40'] = [(40,315842)]\n    aliases['A41'] = [(41,9)]\n    aliases['S41'] = [(41,10)]\n    aliases['A42'] = [(42,9490)]\n    aliases['S42'] = [(42,9491)]\n    aliases['A43'] = [(43,9)]\n    aliases['S43'] = [(43,10)]\n    aliases['A44'] = [(44,2112)]\n    aliases['S44'] = [(44,2113)]\n    aliases['A45'] = [(45,10922)]\n    aliases['S45'] = [(45,10923)]\n    aliases['A46'] = [(46,55)]\n    aliases['S46'] = [(46,56)]\n    aliases['A47'] = [(47,5)]\n    aliases['S47'] = [(47,6)]\n\n    aliases['D13'] = [(13,2)]\n    aliases['D14'] = [(14,3)]\n    aliases['D15'] = [(15,2)]\n    aliases['D16'] = [(16,56)]\n    aliases['D17'] = [(17,2)]\n    aliases['D18'] = [(18,13)]\n    aliases['D19'] = [(19,2)]\n    aliases['D20'] = [(20,10)]\n    aliases['D21'] = [(21,5)]\n    aliases['D22'] = [(22,3)]\n    aliases['D23'] = [(23,2)]\n    aliases['D24'] = [(24,34)]\n    aliases['D25'] = [(25,4)]\n    aliases['D26'] = [(26,3)]\n    aliases['D27'] = [(27,8)]\n    aliases['D28'] = [(28,10)]\n    aliases['D29'] = [(29,2)]\n    aliases['D30'] = [(30,14)]\n    aliases['D31'] = [(31,2)]\n    aliases['D32'] = [(32,374)]\n    aliases['D33'] = [(33,3)]\n    aliases['D34'] = [(34,3)]\n    aliases['D35'] = [(35,4)]\n    aliases['D36'] = [(36,47)]\n    aliases['D37'] = [(37,2)]\n    aliases['D38'] = [(38,3)]\n    aliases['D39'] = [(39,4)]\n    aliases['D40'] = [(40,46)]\n    aliases['D41'] = [(41,2)]\n    aliases['D42'] = [(42,11)]\n    aliases['D43'] = [(43,2)]\n    aliases['D44'] = [(44,9)]\n    aliases['D45'] = [(45,4)]\n    aliases['D46'] = [(46,3)]\n    aliases['D47'] = [(47,2)]\n\n    aliases['M12'] = [(12,295)]\n    aliases['M22'] = [(22,38)]\n    aliases['M23'] = [(23,5)]\n    aliases['M24'] = [(24,24680)]\n    aliases['PSL(3,3)'] = [(13,7)]\n    aliases['PSL(2,13)'] = [(14,30)]\n    aliases['PSP(4,3)'] = [(27,993)]\n    aliases['PSU(3,3)'] = [(28,323)]\n    aliases['SL(2,5)'] = [(24,201)]\n    aliases['GL(2,5)'] = [(24,1353)]\n\n    # Load all sibling representations from the database\n    labels = [\"%sT%s\" % elt[0] for elt in aliases.values()]\n    siblings = {\n        elt[\"label\"]: [tuple(z[0]) for z in elt[\"siblings\"]]\n        for elt in db.gps_transitive.search(\n                {\"label\": {\"$in\": labels}}, [\"label\", \"siblings\"]\n        )\n    }\n    for ky in aliases:\n        nt = aliases[ky][0]\n        label = \"%sT%s\" % nt\n        aliases[ky] = siblings[label][:]\n        if nt not in aliases[ky]:\n            aliases[ky].append(nt)\n        aliases[ky].sort()\n    return aliases"
  },
  {
    "type": "class",
    "file": "lmfdb/abvar/fq/test_av.py",
    "name": "AVTest",
    "line_start": 4,
    "line_end": 167,
    "lines": 164,
    "bytes": 7813,
    "has_71": true,
    "code": "class AVTest(LmfdbTest):\n    # All tests should pass\n    def test_polynomial(self):\n        r\"\"\"\n        Check that the formatted polynomial displays correctly\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/2/9/aj_bl\", \"1 - 9 x + 37 x^{2} - 81 x^{3} + 81 x^{4}\")\n\n    def test_display_field(self):\n        r\"\"\"\n        Check that the base field gets displayed correctly\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/2/25/ac_b\", r\"\\F_{5^{2}}\")\n\n    def test_frob_angles(self):\n        r\"\"\"\n        Check that the Frobenius angles display correctly\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/3/4/ab_a_i\", \"0.206216850513\")\n\n    def test_is_simple(self):\n        r\"\"\"\n        Check that is_simple is computed correctly, and that the decomposition information displays correctly\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/4/3/ab_d_ad_g\", \">simple\")\n        self.check_args(\"/Variety/Abelian/Fq/3/4/e_q_bg\", \"1.4.a\")\n        self.check_args(\"/Variety/Abelian/Fq/3/4/e_q_bg\", '<a title=\"Simple abelian variety [av.simple]\" knowl=\"av.simple\" kwargs=\"\">not simple</a>')\n\n    def test_is_ordinary(self):\n        r\"\"\"\n        Check that is_ordinary is computed correctly\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/3/3/ad_i_aq\", \">ordinary\")\n        self.check_args(\"/Variety/Abelian/Fq/2/61/ah_a\", \">not ordinary\")\n\n    def test_is_supersingular(self):\n        r\"\"\"\n        Check that is_supersingular is computed correctly\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/2/7/a_a\", \">supersingular\")\n        self.check_args(\"/Variety/Abelian/Fq/2/71/ah_a\", \">not supersingular\")\n\n    def test_slopes(self):\n        r\"\"\"\n        Check that display_slopes works\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/2/71/ah_a\", \"[0, 1/2, 1/2, 1]\")\n\n    def test_counts(self):\n        r\"\"\"\n        Check that length_A_counts and length_C_counts work\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/2/79/az_lj\", \"9468043770876073552\")\n        self.check_args(\"/Variety/Abelian/Fq/2/79/az_lj\", \"9468276088941449902\")\n\n    def test_display_number_fld(self):\n        r\"\"\"\n        Check that display_number_field works\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/2/4/ac_e\", \"4.0.125.1\")\n        # self.check_args(\"/Variety/Abelian/Fq/3/9/d_h_bb\",'The number field of this isogeny class is not in the database.')\n        # self.not_check_args(\"/Variety/Abelian/Fq/2/7/g_v\", 'The number field of this isogeny class is not in the database.')\n\n    def test_display_gal_gp(self):\n        r\"\"\"\n        Check that display_galois_group works\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/2/19/g_bt\", \"n=4&t=3\")\n        # self.check_args(\"/Variety/Abelian/Fq/3/9/d_h_bb\",'The Galois group of this isogeny class is not in the database.')\n        # self.not_check_args(\"/Variety/Abelian/Fq/2/27/f_n\",'The Galois group of this isogeny class is not in the database.')\n\n    def test_is_primitive(self):\n        r\"\"\"\n        Check that is_primitive is computed correctly, and that the base change information displays correctly\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/2/9/e_l\", \"primitive\")\n        self.check_args(\"/Variety/Abelian/Fq/3/9/ai_bc_acx\", \"3.3.ac_ac_j\")\n\n    def test_newton_polygon_plot(self):\n        r\"\"\"\n        Check that the plot of the Newton polygon is included and computed correctly\n        \"\"\"\n        page = self.tc.get(\"/Variety/Abelian/Fq/2/4/ad_g\").get_data(as_text=True)\n        # The following is part of the base64 encoded image of the Newton\n        # polygon for this isogeny class.\n        assert r\"data:image/png;base64,iVBORw0KGgo\" in page\n\n    def test_circle_plot(self):\n        r\"\"\"\n        Check that the plot showing the roots of the Weil polynomial displays correctly\n        \"\"\"\n        page = self.tc.get(\"/Variety/Abelian/Fq/2/4/ad_g\").get_data(as_text=True)\n        # The following is part of the base64 encoded image of the circle plot\n        # for this isogeny class.\n        assert r\"data:image/png;base64,iVBORw0KGgo\" in page\n\n    def test_property_box(self):\n        r\"\"\"\n        Check that the property box displays.\n        \"\"\"\n        page = self.tc.get(\"/Variety/Abelian/Fq/2/4/ad_g\").get_data(as_text=True).replace(\"\\n\", \"\").replace(\" \", \"\")\n        assert r'<divclass=\"properties-body\"><table><tr><tdclass=\"label\">Label</td><td>2.4.ad_g</td></tr><tr>' in page\n        assert r'<tdclass=\"label\">Basefield</td><td>$\\F_{2^{2}}$</td></tr><tr><tdclass=\"label\">Dimension</td><td>' in page\n        self.check_args(\"/Variety/Abelian/Fq/2/79/ar_go\", \"Principally polarizable\")\n\n    def test_split_Frobenius_angles(self):\n        r\"\"\"\n        Check that the Frobenius angles are split into multiple math elements\n        \"\"\"\n        page = self.tc.get(\"/Variety/Abelian/Fq/2/4/ad_g\").get_data(as_text=True)\n        assert r\"$\\pm0.150432950460$, $\\pm0.544835058382$\" in page\n\n    def test_av_download(self):\n        r\"\"\"\n        Test downloading on search results page.\n        \"\"\"\n        data = self.tc.get(\"Variety/Abelian/Fq/5/2/?Submit=sage&download=1&query=%7B%27q%27%3A+2%2C+%27g%27%3A+5%7D\").get_data(as_text=True)\n        self.assertTrue(\"Each entry in the following data list\" in data)\n        self.assertTrue(\"[1, -10, 50, -160, 360, -592, 720, -640, 400, -160, 32]\" in data)\n        response = self.tc.get(\"Variety/Abelian/Fq/5/2/?Submit=gp&download=1&query=%7B%27q%27%3A+2%2C+%27g%27%3A+5%7D\")\n        self.assertTrue(\"Each entry in the following data list\" in response.get_data(as_text=True))\n        self.assertTrue(\"[1, -10, 50, -160, 360, -592, 720, -640, 400, -160, 32]\" in response.get_data(as_text=True))\n        response = self.tc.get(\"Variety/Abelian/Fq/5/2/?Submit=magma&download=1&query=%7B%27q%27%3A+2%2C+%27g%27%3A+5%7D\")\n        self.assertTrue(\"Each entry in the following data list\" in response.get_data(as_text=True))\n        self.assertTrue(\"[1, -10, 50, -160, 360, -592, 720, -640, 400, -160, 32]\" in response.get_data(as_text=True))\n\n    def test_download_all(self):\n        r\"\"\"\n        Test downloading all stored data to text\n        \"\"\"\n\n        page = self.tc.get('Variety/Abelian/Fq/download_all/1.81.r', follow_redirects=True)\n        assert '\"abvar_counts\": [99, 6435, 532224, 43043715,' in page.get_data(as_text=True)\n\n        page = self.tc.get('Variety/Abelian/Fq/download_all/3.17.d_b_act', follow_redirects=True)\n        assert '\"curve_counts\": [21, 283, 4719, 84395' in page.get_data(as_text=True)\n\n        text = self.tc.get('Variety/Abelian/Fq/data/3.17.d_b_act', follow_redirects=True).get_data(as_text=True)\n        assert 'dim4_factors' in text and 'multiplicity' in text and 'brauer_invariants' in text\n\n    def test_download_curves(self):\n        r\"\"\"\n        Test downloading all stored data to text\n        \"\"\"\n\n        page = self.tc.get('Variety/Abelian/Fq/2.19.ae_w', follow_redirects=True)\n        assert 'Curves to text' in page.get_data(as_text=True)\n\n        page = self.tc.get('Variety/Abelian/Fq/download_curves/2.19.ae_w', follow_redirects=True)\n        assert 'y^2=3*x^6+18*x^5+15*x^4+12*x^3+x^2+5*x+18' in page.get_data(as_text=True)\n\n        page = self.tc.get('Variety/Abelian/Fq/5/3/ac_e_ai_v_abl', follow_redirects=True)\n        assert 'Curves to text' not in page.get_data(as_text=True)\n\n        page = self.tc.get('Variety/Abelian/Fq/download_curves/5.3.ac_e_ai_v_abl', follow_redirects=True)\n        assert 'No curves for abelian variety isogeny class 5.3.ac_e_ai_v_abl' in page.get_data(as_text=True)\n\n    def test_cyclic_group_of_points_display(self):\n        r\"\"\"\n        Check that the cyclic group of points information is displayed\n        on the isogeny-class page.\n        \"\"\"\n        page = self.tc.get(\"/Variety/Abelian/Fq/2/9/aj_bl\").get_data(as_text=True)\n        assert \"Cyclic\" in page"
  },
  {
    "type": "function",
    "file": "lmfdb/lfunctions/test_lfunctions.py",
    "name": "test_Lcmf",
    "line_start": 153,
    "line_end": 285,
    "lines": 133,
    "bytes": 8237,
    "has_71": true,
    "code": "    def test_Lcmf(self):\n        # test old links\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/11/2/1/a/0/', follow_redirects=True)\n        assert \"Modular form 11.2.a.a.1.1\" in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/13/12/a/a/1/1/', follow_redirects=True)\n        assert '4.84e4' in L.get_data(as_text=True) # a_7\n        assert '71.7' in L.get_data(as_text=True) # a_2\n        assert '1.51472556377341264746894823521' in L.get_data(as_text=True) # first zero\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/13/12/a/a/', follow_redirects=True)\n        assert '1.51472556377341264746894823521' in L.get_data(as_text=True) # first zero\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        for i in range(1,6):\n            assert 'Modular form 13.12.a.a.1.%d' % i in L.get_data(as_text=True)\n        assert '371293' in L.get_data(as_text=True) # L_3 root\n        assert '2.54e3' in L.get_data(as_text=True) # a_13\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/7/3/b/a/', follow_redirects=True)\n        assert '0.332981' in L.get_data(as_text=True)\n        assert '2-7-7.6-c2-0-0' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/2/7/7.6/c2/0/0/')\n        assert '7.21458918128718444354242474222' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/1/18/a/a/', follow_redirects=True)\n        assert '1.34e12' in L.get_data(as_text=True) # a26\n        assert '2-1-1.1-c17-0-0' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/2/1/1.1/c17/0/0/')\n        assert '18.17341115038590061946085869072' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/13/4/c/a/3/1/', follow_redirects=True)\n        assert '0.523757' in L.get_data(as_text=True) and '0.530517' in L.get_data(as_text=True)\n        assert '(16 + 27.7<em>i</em>)' in L.get_data(as_text=True)\n        assert 'Dual L-function' in L.get_data(as_text=True)\n        assert '2-13-13.3-c3-0-2' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/2/13/13.3/c3/0/2/')\n        assert '5.68016097036963500634962429051' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/11/2/a/a/', follow_redirects=True)\n        assert '0.253841' in L.get_data(as_text=True)\n        assert 'Elliptic curve 11.a' in L.get_data(as_text=True)\n        assert 'Modular form 11.2.a.a' in L.get_data(as_text=True)\n        #FIXME fill ST info in origins = CMFs\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/13/2/e/a/', follow_redirects=True)\n        assert 'Genus 2 curve 169.a' in L.get_data(as_text=True)\n        assert 'Modular form 13.2.e.a' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Modular form 13.2.e.a.4.1' in L.get_data(as_text=True)\n        assert 'Modular form 13.2.e.a.10.1' in L.get_data(as_text=True)\n        #assert '/SatoTateGroup/1.4.E_6' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/18/2/c/a/', follow_redirects=True)\n        assert 'Genus 2 curve 324.a' in L.get_data(as_text=True)\n        assert 'Modular form 18.2.c.a' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Modular form 18.2.c.a.7.1' in L.get_data(as_text=True)\n        assert 'Modular form 18.2.c.a.13.1' in L.get_data(as_text=True)\n        #assert '/SatoTateGroup/1.4.E_3' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/490/2/a/a/', follow_redirects=True)\n        assert 'Modular form 490.2.a.a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 490.a' in L.get_data(as_text=True)\n        assert '0.729971' in L.get_data(as_text=True)\n        assert r'(2,\\ 490,\\ (\\ :1/2),\\ 1)' in L.get_data(as_text=True)\n        assert '0.940863335931152039286421559408' in L.get_data(as_text=True)\n        assert '1 + 7 T + p T^{2}' in L.get_data(as_text=True)\n        assert 'Trivial' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/Q/490/a/', follow_redirects=True)\n        assert '0.9408633359311520' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/350/2/e/k/51/1/', follow_redirects=True)\n        assert 'Modular form 350.2.e.k.51.1' in L.get_data(as_text=True)\n        assert 'Dual L-function' in L.get_data(as_text=True)\n        assert r'\\chi_{350} (51, \\cdot )' in L.get_data(as_text=True)\n        assert r'(2,\\ 350,\\ (\\ :1/2),\\ 0.991 + 0.126i)' in L.get_data(as_text=True)\n        assert '2.00692' in L.get_data(as_text=True)\n        assert '0.127359' in L.get_data(as_text=True)\n        assert '1 + 6T + 29T^{2}' in L.get_data(as_text=True)\n        assert '1.68486586956382681209348921118' in L.get_data(as_text=True)\n        assert '3.10207045712088492456262227600' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/350/2/e/k/151/1/', follow_redirects=True)\n        assert 'Modular form 350.2.e.k.151.1' in L.get_data(as_text=True)\n        assert 'Dual L-function' in L.get_data(as_text=True)\n        assert r'\\chi_{350} (151, \\cdot )' in L.get_data(as_text=True)\n        assert r'(2,\\ 350,\\ (\\ :1/2),\\ 0.991 - 0.126i)' in L.get_data(as_text=True)\n        assert '2.00692' in L.get_data(as_text=True)\n        assert '0.127359' in L.get_data(as_text=True)\n        assert '1 + 6T + 29T^{2}' in L.get_data(as_text=True)\n        assert '1.68486586956382681209348921118' in L.get_data(as_text=True)\n        assert '3.10207045712088492456262227600' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/350/2/e/k/', follow_redirects=True)\n        assert 'Modular form 350.2.e.k.151.1' in L.get_data(as_text=True)\n        assert 'Modular form 350.2.e.k.51.1' in L.get_data(as_text=True)\n        assert 'Modular form 350.2.e.k' in L.get_data(as_text=True)\n        assert r'(4,\\ 122500,\\ (\\ :1/2, 1/2),\\ 1)' in L.get_data(as_text=True)\n        assert '4.04397' in L.get_data(as_text=True)\n        assert '1.68486586956382681209348921118' in L.get_data(as_text=True)\n        assert '3.10207045712088492456262227600' in L.get_data(as_text=True)\n        assert '( 1 + T + p T^{2} )( 1 + 7 T + p T^{2} )' in L.get_data(as_text=True)\n        assert '( 1 - 2 T + p T^{2} )^{2}' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/129/2/a/d/', follow_redirects=True)\n        assert 'Modular form 129.2.a.d' in L.get_data(as_text=True)\n        for i in range(1,4):\n            assert 'Modular form 129.2.a.d.1.%d' % i in L.get_data(as_text=True)\n\n        assert '1.04395' in L.get_data(as_text=True)\n        assert '( 1 + T )^{3}' in L.get_data(as_text=True)\n        assert '1.55341889806322957326786121161' in L.get_data(as_text=True)\n        assert r'S_4\\times C_2' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/60/2/i/a/', follow_redirects=True)\n        assert 'Modular form 60.2.i.a' in L.get_data(as_text=True)\n        for c in [17, 53]:\n            for i in range(1,3):\n                assert 'Modular form 60.2.i.a.%d.%d' % (c,i) in L.get_data(as_text=True), 'Modular form 60.2.%d.a.%d' % (c,i)\n        assert '0.676894' in L.get_data(as_text=True)\n        assert '2.15777231959226116393597609132' in L.get_data(as_text=True)\n        assert '1 - 2 T + 2 T^{2} - 2 p T^{3} + p^{2} T^{4}' in L.get_data(as_text=True)\n        assert r'(8,\\ 12960000,\\ (\\ :1/2, 1/2, 1/2, 1/2),\\ 1)' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/207/2/i/b/', follow_redirects=True)\n        for c in [55,64,73,82,100,118,127,154,163,190]:\n            assert 'Modular form 207.2.i.b.%d.1' % c in L.get_data(as_text=True), 'Modular form 207.2.%d.d.1' % c\n        assert '0.233961' in L.get_data(as_text=True)\n        assert '0.096070203083029088532433951629' in L.get_data(as_text=True)\n        assert 'T + T^{2} + 21 T^{3} - 219 T^{4} - 1365 T^{5} - 219 p T^{6} + 21 p^{2} T^{7} + p^{3} T^{8}' in L.get_data(as_text=True)\n        assert 'Plot not available' in L.get_data(as_text=True)"
  },
  {
    "type": "class",
    "file": "lmfdb/hilbert_modular_forms/test_hmf.py",
    "name": "HMFTest",
    "line_start": 4,
    "line_end": 169,
    "lines": 166,
    "bytes": 8532,
    "has_71": true,
    "code": "class HMFTest(LmfdbTest):\n    def test_home(self):\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/')\n        assert 'Hilbert' in L.get_data(as_text=True)\n        assert 'modular' in L.get_data(as_text=True)\n        assert 'Browse' in L.get_data(as_text=True)\n        assert 'Search' in L.get_data(as_text=True)\n        assert 'Find' in L.get_data(as_text=True)\n        assert r'\\sqrt{2}' in L.get_data(as_text=True) #552\n\n    def test_random(self): #993\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/random')\n        assert 'edirect' in L.get_data(as_text=True)\n\n    def test_EC(self): #778\n        L = self.tc.get('ModularForm/GL2/TotallyReal/5.5.126032.1/holomorphic/5.5.126032.1-82.1-b')\n        assert 'EllipticCurve/5.5.126032.1/82.1/b/' in L.get_data(as_text=True)\n\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/2.2.89.1/holomorphic/2.2.89.1-2.1-a')\n        assert 'Elliptic curve' in L.get_data(as_text=True)\n        assert 'EllipticCurve/2.2.89.1/2.1/a' in L.get_data(as_text=True)\n\n    def test_typo(self): #771\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/?field_label=2.2.5.1')\n        assert 'Search again' in L.get_data(as_text=True)\n\n    def test_large(self): #616\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/?field_label=4.4.2000.1&count=1200')\n        assert '719.2-c' in L.get_data(as_text=True)\n\n    def test_range_search(self): #547\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/?disc=1..100&count=100')\n        assert '209.1-b' in L.get_data(as_text=True)\n        assert 'Next' in L.get_data(as_text=True) #435\n\n    def test_bad_input_search(self): #547\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/?field_label=hello&count=100')\n        assert 'not a valid input' in L.get_data(as_text=True)\n\n    def test_search(self):\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/?start=0&deg=2..5&disc=60-200&level_norm=40-90&dimension=3..5&count=100')\n        assert '70.1-o' in L.get_data(as_text=True)\n\n    def test_search_CM(self):\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/?start=0&field_label=&deg=5&disc=&weight=2&level_norm=&dimension=&cm=only&bc=include&count=100')\n        assert '121.1-b' in L.get_data(as_text=True)\n\n    def test_search_base_change(self):\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/?start=0&field_label=&deg=5&disc=&cm=include&bc=exclude&count=100')\n        assert '/ModularForm/GL2/TotallyReal/5.5.14641.1/holomorphic/5.5.14641.1-67.5-a' in L.get_data(as_text=True)\n\n    def test_hmf_page(self):\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/2.2.73.1/holomorphic/2.2.73.1-48.4-b')\n        s = L.get_data(as_text=True).replace(\" \", \"\")\n        assert 'no' in s\n        assert '-6' in s\n        assert '2w+10' in s\n        assert r'\\Q' in s\n        assert '[2,2]' in s\n\n    def test_hmf_page_higherdim(self):\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/2.2.60.1/holomorphic/2.2.60.1-44.1-c')\n        s = L.get_data(as_text=True).replace(\" \", \"\")\n        assert '-2w-4' in s\n        assert '2e' in s\n        assert 'definingpolynomial' in s\n\n    def test_by_field(self):\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/?field_label=4.4.725.1')\n        assert 'w - 4' in L.get_data(as_text=True)\n\n    def test_download_sage(self):\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/4.4.725.1/holomorphic/4.4.725.1-31.1-a/download/sage')\n        assert 'NN = ZF.ideal([31, 31, w^3 - 4*w + 1])' in L.get_data(as_text=True)\n        assert '[89, 89, 3*w^3 - 2*w^2 - 7*w],\\\\' in L.get_data(as_text=True)\n        assert 'hecke_eigenvalues_array = [4, -4,' in L.get_data(as_text=True)\n\n    def test_Lfun_link(self):\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/2.2.5.1/holomorphic/2.2.5.1-31.1-a')\n        assert 'L/ModularForm/GL2/TotallyReal/2.2.5.1/holomorphic/2.2.5.1-31.1-a' in L.get_data(as_text=True)\n\n    def test_browse(self):\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/browse/')\n        assert 'by field degree' in L.get_data(as_text=True)\n        assert 'database contains' in L.get_data(as_text=True)\n        assert 'data is complete up to' in L.get_data(as_text=True)\n\n    def test_browse_by_degree(self):\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/browse/2/')\n        assert 'Number of newforms' in L.get_data(as_text=True)\n\n    def test_missing_AL(self):\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/3.3.49.1/holomorphic/3.3.49.1-512.1-a')\n        assert 'The Atkin-Lehner eigenvalues for this form are not in the database' in L.get_data(as_text=True)\n\n    def test_level_one_AL(self):\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/2.2.173.1/holomorphic/2.2.173.1-1.1-a')\n        assert 'This form has no Atkin-Lehner eigenvalues' in L.get_data(as_text=True)\n\n    def test_friends(self):\n        for url, texts, notitself in [\n                ('/ModularForm/GL2/TotallyReal/2.2.5.1/holomorphic/2.2.5.1-31.1-a',\n                    ('Hilbert modular form 2.2.5.1-31.2-a',\n                        'Elliptic curve 2.2.5.1-31.1-a',\n                        'Elliptic curve 2.2.5.1-31.2-a'),\n                    'Hilbert modular form 2.2.5.1-31.1-a'),\n                ('/ModularForm/GL2/TotallyReal/2.2.5.1/holomorphic/2.2.5.1-31.2-a',\n                    ('Hilbert modular form 2.2.5.1-31.1-a',\n                        'Elliptic curve 2.2.5.1-31.1-a',\n                        'Elliptic curve 2.2.5.1-31.2-a'),\n                    'Hilbert modular form 2.2.5.1-31.2-a'),\n                ('/ModularForm/GL2/TotallyReal/2.2.497.1/holomorphic/2.2.497.1-1.1-a',\n                    ('Elliptic curve 2.0.7.1-5041.1-CMa',\n                        'Elliptic curve 2.0.7.1-5041.3-CMa',\n                        'Elliptic curve 2.2.497.1-1.1-a',\n                        'Modular form 497.2.b.a'),\n                    'Hilbert modular form 2.2.497.1-1.1-a'),\n                ('/ModularForm/GL2/TotallyReal/2.2.8.1/holomorphic/2.2.8.1-32.1-a',\n                    ('Bianchi modular form 2.0.8.1-32.1-a',\n                        'Elliptic curve 2.0.8.1-32.1-a',\n                        'Elliptic curve 2.2.8.1-32.1-a'),\n                    'Hilbert modular form 2.2.8.1-32.1-a')\n                ]:\n            L = self.tc.get(url)\n            for t in texts:\n                assert t in L.get_data(as_text=True)\n            assert 'L-function' in L.get_data(as_text=True)\n\n            # this test isn't very specific\n            # but the goal is to test that itself doesn't show in the friends list\n            assert notitself not in L.get_data(as_text=True)\n\n    def test_download_magma(self):\n\n        L = self.tc.get('/ModularForm/GL2/TotallyReal/4.4.725.1/holomorphic/4.4.725.1-31.1-a/download/magma').get_data(as_text=True)\n        assert 'NN := ideal<ZF | {31, 31, w^3 - 4*w + 1}>;' in L\n        assert '[89, 89, 3*w^3 - 2*w^2 - 7*w],' in L\n        assert 'heckeEigenvaluesArray := [4, -4,' in L\n\n        page = self.tc.get('ModularForm/GL2/TotallyReal/3.3.837.1/holomorphic/3.3.837.1-48.3-z/download/magma').get_data(as_text=True)\n        assert 'No such form' in page\n\n        # We run the following tests when magma is installed\n        for field, label, expected in [\n                ['2.2.28.1', '2.2.28.1-531.1-m',\n                 'heckeEigenvaluesArray := [e, -1, -1, e^7 - 1/2*e^6 - 10*e^5 + 11/2*e^4 + 27*e^3 - 15*e^2 - 15*e + 4'],\n                ['3.3.837.1', '3.3.837.1-2.1-b',\n                 'heckeEigenvaluesArray := [1, e, e^2 - e - 7, -e^2 + 6, -e + 2, 2*e + 2, -e^2 + 2*e + 8, 2*e^2 - 4*e - 16'],\n                ['4.4.725.1', '4.4.725.1-31.1-a',\n                 'heckeEigenvaluesArray := [4, -4, -7, -4, 4, 2, -2, -1, -8, 2, 10']\n        ]:\n            page = self.tc.get('/ModularForm/GL2/TotallyReal/{}/holomorphic/{}/download/magma'.format(field, label)).get_data(as_text=True)\n            assert expected in page\n            assert 'make_newform' in page\n\n            magma_code = page + '\\n'\n            magma_code += 'f, iso := Explode(make_newform());\\n'\n            magma_code += 'assert(&and([iso(heckeEigenvalues[P]) eq HeckeEigenvalue(f,P): P in primes[1..10]]));\\n'\n            magma_code += 'f;\\n'\n            self.assert_if_magma('success', magma_code, mode='in')\n\n    def test_underlying_data(self):\n        data = self.tc.get('/ModularForm/GL2/TotallyReal/data/2.2.5.1-31.1-a').get_data(as_text=True)\n        assert ('hmf_forms' in data and 'level_bad_primes' in data\n                and 'hmf_hecke' in data and 'AL_eigenvalues' in data\n                and 'hmf_fields' in data and 'ideals' in data)"
  },
  {
    "type": "function",
    "file": "lmfdb/classical_modular_forms/test_cmf.py",
    "name": "test_satake",
    "line_start": 418,
    "line_end": 575,
    "lines": 158,
    "bytes": 9212,
    "has_71": true,
    "code": "    def test_satake(self):\n        for url in ['/ModularForm/GL2/Q/holomorphic/11/2/a/a/?format=satake',\n                '/ModularForm/GL2/Q/holomorphic/11/2/a/a/1/1/']:\n            page = self.tc.get(url)\n            assert r'0.707107' in page.get_data(as_text=True)\n            assert r'0.957427' in page.get_data(as_text=True)\n            assert r'0.223607' in page.get_data(as_text=True)\n            assert r'0.974679' in page.get_data(as_text=True)\n            assert r'0.288675' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/7/3/b/a/?&format=satake',\n                '/ModularForm/GL2/Q/holomorphic/7/3/b/a/6/1/']:\n            page = self.tc.get(url)\n            assert r'0.750000' in page.get_data(as_text=True)\n            assert r'0.661438' in page.get_data(as_text=True)\n            assert r'0.272727' in page.get_data(as_text=True)\n            assert r'0.962091' in page.get_data(as_text=True)\n        assert r'1.00000' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/7/3/b/a/?&format=satake_angle',\n                '/ModularForm/GL2/Q/holomorphic/7/3/b/a/6/1/']:\n            page = self.tc.get(url)\n            assert r'\\(\\pi\\)' in page.get_data(as_text=True)\n            assert r'\\(0.769947\\pi\\)' in page.get_data(as_text=True)\n            assert r'\\(0.587926\\pi\\)' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/21/2/e/a/?format=satake',\n                '/ModularForm/GL2/Q/holomorphic/21/2/e/a/4/1/',\n                '/ModularForm/GL2/Q/holomorphic/21/2/e/a/16/1/',\n                ]:\n            page = self.tc.get(url)\n            assert r'0.965926' in page.get_data(as_text=True)\n            assert r'0.258819' in page.get_data(as_text=True)\n            assert r'0.990338' in page.get_data(as_text=True)\n            assert r'0.550990' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/5/9/c/a/?n=2-10&m=1-6&prec=6&format=satake',\n                '/ModularForm/GL2/Q/holomorphic/5/9/c/a/2/1/',\n                '/ModularForm/GL2/Q/holomorphic/5/9/c/a/3/1/',\n                ]:\n            page = self.tc.get(url)\n            assert '0.972878' in page.get_data(as_text=True)\n            assert '0.231320' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/5/9/c/a/?n=2-10&m=1-6&prec=6&format=satake',\n                '/ModularForm/GL2/Q/holomorphic/5/9/c/a/2/3/',\n                '/ModularForm/GL2/Q/holomorphic/5/9/c/a/3/3/',\n                ]:\n            page = self.tc.get(url)\n            assert '0.00593626' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/31/2/c/a/?m=1-4&n=2-10&prec=6&format=satake',\n                '/ModularForm/GL2/Q/holomorphic/31/2/c/a/5/1/',\n                '/ModularForm/GL2/Q/holomorphic/31/2/c/a/25/1/',\n                ]:\n            page = self.tc.get(url)\n            assert '0.998759' in page.get_data(as_text=True)\n            assert '0.0498090' in page.get_data(as_text=True)\n            assert '0.542515' in page.get_data(as_text=True)\n            assert '0.840046' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/31/2/c/a/?m=1-4&n=2-10&prec=6&format=satake_angle',\n                '/ModularForm/GL2/Q/holomorphic/31/2/c/a/5/1/',\n                '/ModularForm/GL2/Q/holomorphic/31/2/c/a/25/1/',\n                ]:\n            page = self.tc.get(url)\n            assert r'0.984139\\pi' in page.get_data(as_text=True)\n            assert r'0.317472\\pi' in page.get_data(as_text=True)\n\n        #test large floats\n        for url in ['/ModularForm/GL2/Q/holomorphic/1/36/a/a/?m=1-3&n=695-696&prec=6&format=embed',\n                    '/ModularForm/GL2/Q/holomorphic/1/36/a/a/1/1/']:\n            page = self.tc.get(url)\n            assert '213.765' in page.get_data(as_text=True)\n            assert '5.39613e49' in page.get_data(as_text=True)\n            assert '7.61562e49' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/1/36/a/a/?m=1-3&n=695-696&prec=6&format=embed',\n                    '/ModularForm/GL2/Q/holomorphic/1/36/a/a/1/2/']:\n            page = self.tc.get(url)\n            assert '3412.77' in page.get_data(as_text=True)\n            assert '1.55372e49' in page.get_data(as_text=True)\n            assert '1.00032e49' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/1/36/a/a/?m=1-3&n=695-696&prec=6&format=embed',\n                    '/ModularForm/GL2/Q/holomorphic/1/36/a/a/1/3/']:\n            page = self.tc.get(url)\n            assert '3626.53' in page.get_data(as_text=True)\n            assert '1.17540e49' in page.get_data(as_text=True)\n            assert '1.20001e50' in page.get_data(as_text=True)\n\n        # same numbers but normalized\n        for url in ['/ModularForm/GL2/Q/holomorphic/1/36/a/a/?m=1-3&n=695-696&prec=6&format=analytic_embed',\n                    '/ModularForm/GL2/Q/holomorphic/1/36/a/a/1/1/']:\n            page = self.tc.get(url)\n            assert '0.993913' in page.get_data(as_text=True)\n            assert '1.36787' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/1/36/a/a/?m=1-3&n=695-696&prec=6&format=analytic_embed',\n                    '/ModularForm/GL2/Q/holomorphic/1/36/a/a/1/2/']:\n            page = self.tc.get(url)\n            assert '0.286180' in page.get_data(as_text=True)\n            assert '0.179671' in page.get_data(as_text=True)\n        for url in ['/ModularForm/GL2/Q/holomorphic/1/36/a/a/?m=1-3&n=695-696&prec=6&format=analytic_embed',\n                    '/ModularForm/GL2/Q/holomorphic/1/36/a/a/1/3/']:\n            page = self.tc.get(url)\n            assert '0.216496' in page.get_data(as_text=True)\n            assert '2.15537' in page.get_data(as_text=True)\n\n        # test some exact values\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/25/2/e/a/?n=97&m=8&prec=6&format=satake_angle')\n        assert '0.0890699' in page.get_data(as_text=True)\n        assert '0.689070' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/25/2/d/a/?m=4&n=97&prec=6&format=satake_angle')\n        assert '0.237314' in page.get_data(as_text=True)\n        assert '0.637314' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/210/2/a/a/?format=satake&n=2-20')\n        # alpha_11\n        assert '0.603023' in page.get_data(as_text=True)\n        assert '0.797724' in page.get_data(as_text=True)\n        # alpha_13\n        assert '0.277350' in page.get_data(as_text=True)\n        assert '0.960769' in page.get_data(as_text=True)\n        # alpha_17\n        assert '0.727607' in page.get_data(as_text=True)\n        assert '0.685994' in page.get_data(as_text=True)\n\n        # specifying embeddings\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/99/2/p/a/?n=2-10&m=2.1%2C+95.10&prec=6&format=embed')\n        for elt in ['2.1','95.10','1.05074','0.946093', '2.90568', '0.305399']:\n            assert elt in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/13/2/e/a/?m=1-2&n=2-10000&prec=6&format=embed')\n        assert \"Only\" in page.get_data(as_text=True)\n        assert \"up to 1000 are available\" in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/7524/2/l/b/?n=5000&m=&prec=&format=embed')\n        assert \"Only\" in page.get_data(as_text=True)\n        assert \"up to 3000 are available\" in page.get_data(as_text=True)\n        assert \"in specified range; resetting to default\" in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/7524/2/l/b/?n=1500-4000&m=&prec=&format=embed')\n        assert \"Only\" in page.get_data(as_text=True)\n        assert \"up to 3000 are available\" in page.get_data(as_text=True)\n        assert \"limiting to\" in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/13/2/e/a/?m=1-2&n=3.5&prec=6&format=embed')\n        assert \"must be an integer, range of integers or comma separated list of integers\" in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/419/3/h/a/?n=2-10&m=1-20000&prec=6&format=embed', follow_redirects=True)\n        assert \"Web interface only supports 1000 embeddings at a time.  Use download link to get more (may take some time).\" in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/419/3/h/a/?n=3.14&format=embed', follow_redirects=True)\n        assert \"must be an integer, range of integers or comma separated list of integers\" in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/99/2/p/a/?n=2-10&m=1-20&prec=16&format=embed')\n        assert 'must be a positive integer, at most 15 (for higher precision, use the download button)' in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/99/2/p/a/?n=999-1001&m=1-20&prec=6&format=embed')\n        assert 'Only' in page.get_data(as_text=True)\n        assert 'up to 1000 are available' in page.get_data(as_text=True)\n        assert 'a_{1000}' in page.get_data(as_text=True)"
  },
  {
    "type": "function",
    "file": "scripts/ecnf/hmf_check_find.py",
    "name": "find_curves",
    "line_start": 484,
    "line_end": 697,
    "lines": 214,
    "bytes": 9312,
    "has_71": true,
    "code": "def find_curves(field_label='2.2.5.1', min_norm=0, max_norm=None, label=None, outfilename=None, verbose=False, effort=500):\n    r\"\"\" Go through all Hilbert Modular Forms with the given field label,\n    assumed totally real, for level norms in the given range, test\n    whether an elliptic curve exists with the same label; if not, find\n    the curves using Magma; output these to a file.\n    \"\"\"\n    print(\"Checking forms over {}, norms from {} to {}\".format(field_label,min_norm,max_norm))\n    if outfilename:\n        print(\"Output of curves found to {}\".format(outfilename))\n    else:\n        print(\"No curve search or output, just checking\")\n    query = {}\n    query['field_label'] = field_label\n    if not fields.exists({'label': field_label}):\n        if verbose:\n            print(\"No HMF data for field %s\" % field_label)\n        return None\n\n    query['dimension'] = 1  # only look at rational newforms\n    if label:\n        print(\"looking for {} only\".format(label))\n        query['short_label'] = label # e.g. '91.1-a'\n    else:\n        query['level_norm'] = {'$gte': int(min_norm)}\n        if max_norm:\n            query['level_norm']['$lte'] = int(max_norm)\n    cursor = forms.search(query, sort=['level_norm'])\n    labels = [f['label'] for f in cursor]\n    nfound = 0\n    nnotfound = 0\n    nok = 0\n    missing_curves = []\n    K = HilbertNumberField(field_label)\n    primes = [P['ideal'] for P in K.primes_iter(1000)]\n    curve_ap = {}  # curve_ap[conductor_label] will be a dict iso -> ap\n    form_ap = {}  # form_ap[conductor_label]  will be a dict iso -> ap\n\n    # Step 1: look at all newforms, check that there is an elliptic\n    # curve of the same label, and if so compare ap-lists.  The\n    # dicts curve_ap and form_ap store these when there is\n    # disagreement: e.g. curve_ap[conductor_label][iso_label] =\n    # aplist.\n\n    print(\"looping through {} forms\".format(len(labels)))\n    for curve_label in labels:\n        # We find the forms again since otherwise the cursor might timeout during the loop.\n        f = get_hmf(curve_label)\n        ec = nfcurves.lucky({'field_label': field_label, 'class_label': curve_label, 'number': 1})\n        if ec:\n            if verbose:\n                print(\"curve with label %s found in the database\" % curve_label)\n            nfound += 1\n            ainvsK = parse_ainvs(K.K(), ec['ainvs'])\n            E = EllipticCurve(ainvsK)\n            if verbose:\n                print(\"constructed elliptic curve {}\".format(E.ainvs()))\n            good_flags = [E.has_good_reduction(P) for P in primes]\n            good_primes = [P for (P, flag) in zip(primes, good_flags) if flag]\n            aplist = [E.reduction(P).trace_of_frobenius() for P in good_primes]\n            if verbose:\n                print(\"computed ap from elliptic curve\")\n            f_aplist = [int(a) for a in f['hecke_eigenvalues']]\n            f_aplist = [ap for ap, flag in zip(f_aplist, good_flags) if flag]\n            if verbose:\n                print(\"recovered ap from HMF\")\n            nap = min(len(aplist), len(f_aplist))\n            if aplist[:nap] == f_aplist[:nap]:\n                nok += 1\n                if verbose:\n                    print(\"Curve {} and newform agree! (checked {} ap)\".format(ec['short_label'],nap))\n            else:\n                print(\"Curve {} does NOT agree with newform\".format(ec['short_label']))\n                if verbose:\n                    for P,aPf,aPc in zip(good_primes[:nap], f_aplist[:nap], aplist[:nap]):\n                        if aPf!=aPc:\n                            print(\"P = {} with norm {}\".format(P,P.norm().factor()))\n                            print(\"ap from curve: %s\" % aPc)\n                            print(\"ap from  form: %s\" % aPf)\n                if not ec['conductor_label'] in curve_ap:\n                    curve_ap[ec['conductor_label']] = {}\n                    form_ap[ec['conductor_label']] = {}\n                curve_ap[ec['conductor_label']][ec['iso_label']] = aplist\n                form_ap[ec['conductor_label']][f['label_suffix']] = f_aplist\n        else:\n            if verbose:\n                print(\"No curve with label %s found in the database!\" % curve_label)\n            missing_curves.append(f['short_label'])\n            nnotfound += 1\n\n    # Report progress:\n\n    n = nfound + nnotfound\n    if nnotfound:\n        print(\"Out of %s newforms, %s curves were found in the database and %s were not found\" % (n, nfound, nnotfound))\n    else:\n        print(\"Out of %s newforms, all %s had curves with the same label and ap\" % (n, nfound))\n    if nfound == nok:\n        print(\"All curves agree with matching newforms\")\n    else:\n        print(\"%s curves agree with matching newforms, %s do not\" % (nok, nfound - nok))\n    if nnotfound:\n        print(\"%s missing curves\" % len(missing_curves))\n    else:\n        return\n\n    # Step 2: for each newform for which there was no curve, call interface to Magma's EllipticCurveSearch()\n    # (unless outfilename is None in which case just dump the missing labels to a file)\n\n    if outfilename:\n        outfile = open(outfilename, mode=\"w\")\n    else:\n        t = open(\"curves_missing.{}\".format(field_label), mode=\"w\")\n        for c in missing_curves:\n            t.write(c)\n            t.write(\"\\n\")\n        t.close()\n        return\n\n    def output(L):\n        if outfilename:\n            outfile.write(L)\n        if verbose:\n            sys.stdout.write(L)\n\n    bad_p = []\n    #if field_label=='4.4.1600.1': bad_p = [7**2,13**2,29**2]\n    if field_label=='4.4.2304.1': bad_p = [19**2,29**2]\n    if field_label=='4.4.4225.1': bad_p = [17**2,23**2]\n    if field_label=='4.4.7056.1': bad_p = [29**2,31**2]\n    if field_label=='4.4.7168.1': bad_p = [29**2]\n    if field_label=='4.4.9248.1': bad_p = [23**2]\n    if field_label=='4.4.11025.1': bad_p = [17**2,37**2,43**2]\n    if field_label=='4.4.13824.1': bad_p = [19**2]\n    if field_label=='4.4.12400.1': bad_p = [23**2]\n    if field_label=='4.4.180769.1': bad_p = [23**2]\n    if field_label=='6.6.905177.1': bad_p = [2**3]\n    bad_p = []\n\n    effort0 = effort\n    for nf_label in missing_curves:\n        if verbose:\n            print(\"Curve %s is missing from the database...\" % nf_label)\n        form_label = field_label+\"-\"+nf_label\n        form = get_hmf(form_label)\n        if not form:\n            print(\"... form %s not found!\" % nf_label)\n        else:\n            if verbose:\n                print(\"... found form, calling Magma search\")\n\n            print(\"Conductor = %s\" % form['level_ideal'].replace(\" \",\"\"))\n            N = K.ideal(form['level_label'])\n            neigs = len(f['hecke_eigenvalues'])\n            Plist = [P['ideal'] for P in K.primes_iter(neigs)]\n            goodP = [(i, P) for i, P in enumerate(Plist)\n                     if not P.divides(N)\n                     and not P.norm() in bad_p\n                     and P.residue_class_degree()==1]\n            aplist = [int(f['hecke_eigenvalues'][i]) for i, P in goodP]\n            Plist = [P for i,P in goodP]\n            nap = len(Plist)\n            neigs0 = min(nap,100)\n            effort=effort0\n            if verbose:\n                print(\"Using %s ap from Hilbert newform and effort %s\" % (neigs0,effort))\n                if bad_p:\n                    print(\"( excluding primes with norms {})\".format(bad_p))\n            #inds = list(set([randint(0,nap-1) for _ in range(neigs0)]))\n            inds = range(neigs0)\n            Plist0 = [Plist[i] for i in inds]\n            aplist0 = [aplist[i] for i in inds]\n            curves = EllipticCurveSearch(K.K(), Plist0, N, aplist0, effort)\n            # rep = 0\n            allrep=0\n            while not curves and allrep<10:\n                allrep += 1\n                effort*=2\n                # if rep<2:\n                #     rep += 1\n                # else:\n                #     rep = 1\n                #     effort *=2\n                if verbose:\n                    print(\"No curves found by Magma, trying again with effort %s...\" % effort)\n                curves = EllipticCurveSearch(K.K(), Plist0, N, aplist0, effort)\n                if verbose:\n                    if curves:\n                        print(\"Success!\")\n                    else:\n                        print(\"Still no success\")\n            E = None\n            if curves:\n                E = curves[0]\n                print(\"%s curves for %s found, first is %s\" % (len(curves),nf_label,E.ainvs()))\n            else:\n                print(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\")\n                print(\"!!! No curves for %s found (using %s ap) !!!\" % (nf_label,len(aplist)))\n                print(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\")\n\n        if E is not None:\n            ec = {}\n            ec['field_label'] = field_label\n            ec['conductor_label'] = form['level_label']\n            ec['iso_label'] = form['label_suffix']\n            ec['number'] = int(1)\n            ec['conductor_ideal'] = form['level_ideal'].replace(\" \",\"\")\n            ec['conductor_norm'] = form['level_norm']\n            ai = E.ainvs()\n            ec['ainvs'] = \";\".join([\",\".join([str(c) for c in list(a)]) for a in ai])\n            ec['cm'] = '?'\n            ec['base_change'] = []\n            output(make_curves_line(ec) + \"\\n\")\n            if outfilename:\n                outfile.flush()"
  },
  {
    "type": "class",
    "file": "lmfdb/belyi/test_belyi.py",
    "name": "BelyiTest",
    "line_start": 4,
    "line_end": 226,
    "lines": 223,
    "bytes": 10295,
    "has_71": true,
    "code": "class BelyiTest(LmfdbTest):\n    def test_stats(self):\n        L = self.tc.get(\"/Belyi/stats\")\n        assert \"Galois orbits of Belyi maps\" in L.get_data(as_text=True) and \"proportion\" in L.get_data(as_text=True)\n\n    def test_random(self):\n        self.check_args(\"/Belyi/random\", \"Monodromy group\")\n\n    def test_by_galmap_label(self):\n        self.check_args(\"/Belyi/6T15-5.1_4.2_4.2-b\", \"A_6\")\n\n    def test_passport_label(self):\n        self.check_args(\"/Belyi/5T4-5_3.1.1_3.1.1-a\", \"5T4-5_3.1.1_3.1.1\")\n\n    def test_passport(self):\n        self.check_args(\"/Belyi/9T33-5.2.2_5.3.1_2.2.2.2.1-a\", \"3.1.14175.1\")\n\n    def test_smooth_equation(self):\n        self.check_args(\"/Belyi/7T5-7_7_3.3.1-a\", r\"\\frac{50000 x^{5} + 60000 x^{4} + \\left(7000 \\nu + 5000\\right) x^{3} + 50000 x^{2} y + \\left(7000 \\nu - 11400\\right) x^{2} + 40000 x y + \\left(455 \\nu - 1725\\right) x + \\left(500 \\nu + 2500\\right) y - 532 \\nu + 284}{50000 x^{5} + 60000 x^{4} + \\left(7000 \\nu + 5000\\right) x^{3} + \\left(7000 \\nu - 11400\\right) x^{2} + \\left(455 \\nu - 1725\\right) x - 532 \\nu + 284}\")\n        self.check_args(\"/Belyi/7T5-7_7_3.3.1-a\", r\"y^{2} = x^{6} + \\frac{4}{5} x^{5} + \\left(\\frac{13}{50} \\nu - \\frac{19}{50}\\right) x^{4} + \\left(\\frac{21}{125} \\nu - \\frac{7}{25}\\right) x^{3} + \\left(-\\frac{709}{10000} \\nu + \\frac{279}{10000}\\right) x^{2} + \\left(-\\frac{153}{6250} \\nu + \\frac{67}{6250}\\right) x + \\frac{83}{15625} \\nu + \\frac{47}{15625}\")\n\n    def test_plane_equation(self):\n        self.check_args(\"/Belyi/9T33-9_5.1.1.1.1_5.1.1.1.1-a\", r\"x^{9} t + \\left(-126 x^{4} + 420 x^{3} - 540 x^{2} + 315 x - 70\")\n\n    # web pages\n\n    def test_urls(self):\n        # galmap\n        self.check_args(\n            \"/Belyi/4T5-4_3.1_2.1.1-a\", \"Belyi map orbit 4T5-4_3.1_2.1.1-a\"\n        )\n        # passport\n        self.check_args(\n            \"/Belyi/4T5-4_3.1_2.1.1\", \"Passport 4T5-4_3.1_2.1.1\"\n        )\n\n    # searches\n\n    # for galmaps\n\n    def test_deg_range(self):\n        self.check_args(\"/Belyi/?deg=2-7\", \"5T3-4.1_4.1_2.2.1\")\n        self.not_check_args(\"/Belyi/?deg=2-7\", \"1T1-1_1_1\")\n\n    def test_group_search(self):\n        self.check_args(\"/Belyi/?group=7T5\", \"7T5-7_7_3.3.1-a\")\n        self.not_check_args(\"/Belyi/?group=7T5\", \"1T1-1_1_1-a\")\n\n    def test_abc_search(self):\n        self.check_args(\"/Belyi/?abc=2-4\", \"6T10-4.2_4.2_3.3-a\")\n\n    def test_abc_list_search(self):\n        self.check_args(\"/Belyi/?abc_list=[7,6,6]\", \"7T7-7_3.2.1.1_3.2.1.1-a\")\n        self.not_check_args(\"/Belyi/?abc_list=[7,6,6]\", \"1T1-1_1_1-a\")\n\n    def test_genus_search(self):\n        self.check_args(\"/Belyi/?g=2\", \"6T6-6_6_3.3-a\")\n        self.not_check_args(\"/Belyi/?g=2\", \"1T1-1_1_1-a\")\n\n    def test_orbit_size_search(self):\n        self.check_args(\"/Belyi/?orbit_size=20-\", \"7T7-6.1_5.2_4.2.1-a\")\n        self.not_check_args(\"/Belyi/?orbit_size=20-\", \"1T1-1_1_1-a\")\n\n    def test_pass_size_search(self):\n        self.check_args(\"/Belyi/?pass_size=6\", \"7T6-4.2.1_4.2.1_3.2.2-a\")\n        self.not_check_args(\"/Belyi/?pass_size=6\", \"1T1-1_1_1-a\")\n\n    def test_geom_type_search(self):\n        self.check_args(\"/Belyi/?geomtype=H\", \"6T8-4.1.1_4.1.1_3.3-a\")\n        self.not_check_args(\"/Belyi/?pass_size=6\", \"1T1-1_1_1-a\")\n\n    def test_count_search(self):\n        self.check_args(\"/Belyi/?count=20\", \"5T1-5_5_5-c\")\n\n    def test_field_search(self):\n        self.check_args(\"Belyi/?field=Qsqrt-3\", \"6T15-4.2_4.2_4.2-a\")\n        self.not_check_args(\"Belyi/?field=Qsqrt-3\", \"1T1-1_1_1-a\")\n\n    def test_primitive_search(self):\n        self.check_args(\"Belyi/?is_primitive=no\", \"4T1-4_4_1.1.1.1-a\")\n        self.not_check_args(\"Belyi/?is_primitive=no\", \"1T1-1_1_1-a\")\n        self.check_args(\"Belyi/?is_primitive=yes\", \"1T1-1_1_1-a\")\n\n    def test_primitivization_search(self):\n        self.check_args(\"/Belyi/?primitivization=2T1-2_2_1.1-a\", \"4T1-4_4_1.1.1.1-a\")\n        self.not_check_args(\"/Belyi/?primitivization=2T1-2_2_1.1-a\", \"1T1-1_1_1-a\")\n\n    # for passports\n\n    def test_deg_range_passports(self):\n        self.check_args(\"/Belyi/?hst=Passports&deg=2-7\", \"5T3-4.1_4.1_2.2.1\")\n        self.not_check_args(\"/Belyi/?hst=Passports&deg=2-7\", \"1T1-1_1_1\")\n\n    def test_group_search_passports(self):\n        self.check_args(\"/Belyi/?hst=Passports&group=7T5\", \"7T5-7_7_3.3.1\")\n        self.not_check_args(\"/Belyi/?hst=Passports&group=7T5\", \"1T1-1_1_1\")\n\n    def test_abc_search_passports(self):\n        self.check_args(\"/Belyi/?hst=Passports&abc=2-4\", \"6T10-4.2_4.2_3.3\")\n\n    def test_abc_list_search_passports(self):\n        self.check_args(\"/Belyi/?hst=Passports&abc_list=[7,6,6]\", \"7T7-7_3.2.1.1_3.2.1.1\")\n        self.not_check_args(\"/Belyi/?abc_list=[7,6,6]\", \"1T1-1_1_1\")\n\n    def test_genus_search_passports(self):\n        self.check_args(\"/Belyi/?hst=Passports&g=2\", \"6T6-6_6_3.3\")\n        self.not_check_args(\"/Belyi/?hst=Passports&g=2\", \"1T1-1_1_1\")\n\n    def test_max_orbit_size_search_passports(self):\n        self.check_args(\"/Belyi/?hst=Passports&maxdegbf=10\", \"7T7-6.1_3.3.1_5.2\")\n        self.not_check_args(\"/Belyi/?hst=Passports&maxdegbf=10\", \"1T1-1_1_1\")\n\n    def test_pass_size_search_passports(self):\n        self.check_args(\"/Belyi/?hst=Passports&pass_size=6\", \"7T6-4.2.1_4.2.1_3.2.2\")\n        self.not_check_args(\"/Belyi/?hst=Passports&pass_size=6\", \"1T1-1_1_1\")\n\n    def test_geom_type_search_passports(self):\n        self.check_args(\"/Belyi/?hst=Passports&geomtype=H\", \"6T8-4.1.1_4.1.1_3.3\")\n        self.not_check_args(\"/Belyi/?hst=Passports&pass_size=6\", \"1T1-1_1_1\")\n\n    def test_count_search_passports(self):\n        self.check_args(\"/Belyi/?hst=Passports&count=20\", \"5T1-5_5_5\")\n\n    def test_primitive_search_passports(self):\n        self.check_args(\"Belyi/?hst=Passports&is_primitive=no\", \"4T1-4_4_1.1.1.1\")\n        self.not_check_args(\"Belyi/?hst=Passports&is_primitive=no\", \"1T1-1_1_1\")\n        self.check_args(\"Belyi/?hst=Passports&is_primitive=yes\", \"1T1-1_1_1\")\n\n    def test_primitivization_search_passports(self):\n        self.check_args(\"/Belyi/?hst=Passports&primitivization=2T1-2_2_1.1\", \"4T1-4_4_1.1.1.1\")\n        self.not_check_args(\"/Belyi/?hst=Passports&primitivization=2T1-2_2_1.1\", \"1T1-1_1_1\")\n\n    # downloads\n\n    def test_download(self):\n        r\"\"\"\n        Test download function\n        \"\"\"\n        # genus 0 example\n        # in magma\n        page = self.tc.get(\n            \"/Belyi/download_galmap_to_magma/7T6-7_2.2.1.1.1_3.2.2-a\",\n            follow_redirects=True,\n        )\n        assert (\n            \"phi := 1/2*(7*nu-15)*x^7/(x^7+1/10*(28*nu+7)*x^6+1/100*(-56*nu+511)*x^5+1/40*(-672*nu-1323)*x^4+1/20*(-42*nu-63)*x^3+1/40*(1701*nu+3024)*x^2+1/200*(-6237*nu-11178));\"\n            in page.get_data(as_text=True)\n        )\n        # in sage\n        page = self.tc.get(\n            \"/Belyi/download_galmap_to_sage/7T6-7_2.2.1.1.1_3.2.2-a\",\n            follow_redirects=True,\n        )\n        assert (\n            \"phi = 1/2*(7*nu-15)*x^7/(x^7+1/10*(28*nu+7)*x^6+1/100*(-56*nu+511)*x^5+1/40*(-672*nu-1323)*x^4+1/20*(-42*nu-63)*x^3+1/40*(1701*nu+3024)*x^2+1/200*(-6237*nu-11178))\"\n            in page.get_data(as_text=True)\n        )\n\n        # genus 1 example\n        # in magma\n        page = self.tc.get(\n            \"/Belyi/download_galmap_to_magma/6T15-5.1_5.1_5.1-c\",\n            follow_redirects=True,\n        )\n        assert (\n            \"phi := (1/3125*(162*nu-81)*x^2+1/78125*(972*nu-486)*x+1/390625*(-1458*nu+729))/(x^6-9/25*x^5+27/125*x^4+1/3125*(-162*nu-54)*x^3+1/78125*(729*nu-486)*x^2+1/9765625*(-2187*nu+5832)*x+1/244140625*(-2187*nu-1458))*y+(1/3125*(-162*nu+81)*x^3+1/156250*(1458*nu-729)*x^2+1/9765625*(-2187*nu+10935)*x+1/488281250*(-4374*nu-76545))/(x^6-9/25*x^5+27/125*x^4+1/3125*(-162*nu-54)*x^3+1/78125*(729*nu-486)*x^2+1/9765625*(-2187*nu+5832)*x+1/244140625*(-2187*nu-1458));\"\n            in page.get_data(as_text=True)\n        )\n        # in sage\n        page = self.tc.get(\n            \"/Belyi/download_galmap_to_sage/6T15-5.1_5.1_5.1-c\",\n            follow_redirects=True,\n        )\n        assert (\n           \"phi = (1/3125*(162*nu-81)*x^2+1/78125*(972*nu-486)*x+1/390625*(-1458*nu+729))/(x^6-9/25*x^5+27/125*x^4+1/3125*(-162*nu-54)*x^3+1/78125*(729*nu-486)*x^2+1/9765625*(-2187*nu+5832)*x+1/244140625*(-2187*nu-1458))*y+(1/3125*(-162*nu+81)*x^3+1/156250*(1458*nu-729)*x^2+1/9765625*(-2187*nu+10935)*x+1/488281250*(-4374*nu-76545))/(x^6-9/25*x^5+27/125*x^4+1/3125*(-162*nu-54)*x^3+1/78125*(729*nu-486)*x^2+1/9765625*(-2187*nu+5832)*x+1/244140625*(-2187*nu-1458))\"\n            in page.get_data(as_text=True)\n        )\n        # genus 2 example\n        # in magma\n        page = self.tc.get(\n            \"/Belyi/download_galmap_to_magma/7T5-7_7_3.3.1-a\",\n            follow_redirects=True,\n        )\n        assert (\n            \"phi := (1/2*x^2+2/5*x+1/200*(nu+5))/(x^5+6/5*x^4+1/50*(7*nu+5)*x^3+1/250*(35*nu-57)*x^2+1/10000*(91*nu-345)*x+1/12500*(-133*nu+71))*y+1/2;\"\n            in page.get_data(as_text=True)\n        )\n        # in sage\n        page = self.tc.get(\n            \"/Belyi/download_galmap_to_sage/7T5-7_7_3.3.1-a\",\n            follow_redirects=True,\n        )\n        assert (\n            \"phi = (1/2*x^2+2/5*x+1/200*(nu+5))/(x^5+6/5*x^4+1/50*(7*nu+5)*x^3+1/250*(35*nu-57)*x^2+1/10000*(91*nu-345)*x+1/12500*(-133*nu+71))*y+1/2\"\n            in page.get_data(as_text=True)\n        )\n\n        # Underlying data link\n        data = self.tc.get(\"/Belyi/data/7T5-7_7_3.3.1\", follow_redirects=True).get_data(as_text=True)\n        assert \"maxdegbf\" in data and \"orbit_size\" in data\n\n        data = self.tc.get(\"/Belyi/data/7T5-7_7_3.3.1-a\", follow_redirects=True).get_data(as_text=True)\n        assert \"friends\" in data and \"maxdegbf\" in data and \"portrait\" in data\n\n    # friends\n    def test_friends(self):\n        for url, friends in [\n            ('/Belyi/4T5/4/4/3.1/a',\n                ('Passport',\n                    'Elliptic curve 48.a6',)\n             ),\n            ('/Belyi/5T3/5/4.1/4.1/a',\n                ('Passport',\n                    'Elliptic curve 2.0.4.1-1250.3-a3',)\n             ),\n            ('/Belyi/6T6/6/6/3.3/a',\n                ('Passport',\n                    'Genus 2 curve 1728.b.442368.1',)\n             )\n        ]:\n            data = self.tc.get(url, follow_redirects=True).get_data(as_text=True)\n            for friend in friends:\n                assert friend in data"
  },
  {
    "type": "class",
    "file": "lmfdb/characters/test_characters.py",
    "name": "DirichletCharactersTest",
    "line_start": 68,
    "line_end": 253,
    "lines": 186,
    "bytes": 11001,
    "has_71": true,
    "code": "class DirichletCharactersTest(LmfdbTest):\n\n    def test_navig(self):\n        W = self.tc.get('/Character/', follow_redirects=True)\n        assert 'Browse' in W.get_data(as_text=True) and 'search' in W.get_data(as_text=True)\n\n    def test_dirichletfamily(self):\n        W = self.tc.get('/Character/Dirichlet/')\n        assert 'Find' in W.get_data(as_text=True)\n        assert r'13.2' in W.get_data(as_text=True)\n\n    def test_dirichletgroup(self):\n        W = self.tc.get('/Character/Dirichlet/23', follow_redirects=True)\n        assert bool_string(True) in W.get_data(as_text=True)\n        assert 'DirichletGroup(23)' in W.get_data(as_text=True)\n        assert 'e\\\\left(\\\\frac{7}{11}\\\\right)' in W.get_data(as_text=True)\n        assert '\\\\chi_{23}(10,\\\\cdot)' in W.get_data(as_text=True)\n\n        W = self.tc.get('/Character/Dirichlet/91', follow_redirects=True)\n        assert bool_string(True) in W.get_data(as_text=True)\n        assert 'Properties' in W.get_data(as_text=True), \"properties box\"\n        assert 'DirichletGroup(91)' in W.get_data(as_text=True), \"sage code example\"\n        assert r'\\chi_{91}(15,' in W.get_data(as_text=True) and r'\\chi_{91}(66' in W.get_data(as_text=True), \"generators\"\n        assert r'e\\left(\\frac{7}{12}\\right)' in W.get_data(as_text=True), \"contents table\"\n        assert '/Character/Dirichlet/91/6' in W.get_data(as_text=True), \"link in contents table\"\n\n        W = self.tc.get('/Character/Dirichlet/999999999', follow_redirects=True)\n        assert 'Properties' in W.get_data(as_text=True), \"properties box\"\n        assert '648646704' in W.get_data(as_text=True), \"order\"\n        assert 'C_{333666}' in W.get_data(as_text=True), \"structure\"\n        assert r'\\chi_{999999999}(234567902,' in W.get_data(as_text=True) and r'\\chi_{999999999}(432432433,' in W.get_data(as_text=True) and r'\\chi_{999999999}(332999668,' in W.get_data(as_text=True)\n\n    def test_dirichletgalorbs(self):\n        W = self.tc.get('/Character/Dirichlet/289/j').get_data(as_text=True)\n        assert r'&rarr; <a href=\"/Character/Dirichlet/289/j\"> j</a>' in W\n        table_row = (r'<td class=\"center\">\\(-1\\)</td>  '\n                    r'<td class=\"center\">\\(1\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{57}{136}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{191}{272}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{57}{68}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{219}{272}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{33}{272}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{229}{272}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{35}{136}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{55}{136}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{61}{272}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{41}{272}\\right)\\)</td>')\n        assert table_row in W\n        assert \"Underlying data\" in W and \"data/289.j\" in W\n\n        W = self.tc.get('/Character/Dirichlet/7145/da')\n        assert r'&rarr; <a href=\"/Character/Dirichlet/7145/da\"> da</a>' in W.get_data(as_text=True)\n        table_row = (r'<td class=\"center\">\\(-1\\)</td>  '\n                    r'<td class=\"center\">\\(1\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{19}{84}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{481}{714}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{19}{42}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{1285}{1428}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{341}{357}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{19}{28}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{124}{357}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{779}{1428}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{15}{119}\\right)\\)</td>  '\n                    r'<td class=\"center\">\\(e\\left(\\frac{115}{714}\\right)\\)</td>')\n        assert table_row in W.get_data(as_text=True)\n\n        # Tests for URL behaviour of characters\n\n        W = self.tc.get('/Character/Dirichlet/5489/banana/100', follow_redirects=True)\n        assert bool_string(True) in W.get_data(as_text=True)\n        assert r\"The URL has been duly corrected.\" in W.get_data(as_text=True)\n\n        W = self.tc.get('/Character/Dirichlet/254/banana', follow_redirects=True)\n        assert 'Error: No Galois orbit of Dirichlet characters with' in W.get_data(as_text=True)\n\n        W = self.tc.get('/Character/Dirichlet/10001/banana/100', follow_redirects=True)\n        assert r'10001.i' in W.get_data(as_text=True)\n\n        W = self.tc.get('/Character/Dirichlet/9999999999/banana', follow_redirects=True)\n        assert 'Error: Galois orbits have only been computed for modulus up to 100,000' in W.get_data(as_text=True)\n\n        W = self.tc.get('/Character/Dirichlet/58589/50021', follow_redirects=True)\n        assert 'Number field defined by a degree 1428 polynomial' in W.get_data(as_text=True)\n\n    def test_dirichletchar11(self):\n        W = self.tc.get('/Character/Dirichlet/1/1')\n        assert '/NumberField/1.1.1.1' in W.get_data(as_text=True)\n\n    def test_dirichletchar21(self):\n        W = self.tc.get('/Character/Dirichlet/2/1')\n        assert '/NumberField/1.1.1.1' in W.get_data(as_text=True)\n\n    def test_valuefield(self):\n        W = self.tc.get('/Character/Dirichlet/13/2')\n        assert 'Value field' in W.get_data(as_text=True)\n\n    def test_dirichletcharbig(self):\n        \"\"\" nice example to check the Conrey naming scheme\n            for p = 40487, 5 generates Z/pZ but not Z/p^2Z\n            the next one is OK, namely 10.\n            This test also makes sure the code scales a little bit.\n        \"\"\"\n        W = self.tc.get('/Character/Dirichlet/40487/5')\n        assert '40486' in W.get_data(as_text=True), \"order\"\n        assert '12409' in W.get_data(as_text=True), \"log on generator\"\n        assert '20243' in W.get_data(as_text=True), \"field of values\"\n        W = self.tc.get('/Character/Dirichlet/40487.5', follow_redirects=True)\n        assert '40486' in W.get_data(as_text=True), \"order\"\n        assert '20243' in W.get_data(as_text=True), \"field of values\"\n\n    def test_dirichletchar43(self):\n        W = self.tc.get('/Character/Dirichlet/4/3')\n        assert 'Kronecker symbol' in W.get_data(as_text=True)\n        assert r'\\left(\\frac{-4}{\\bullet}\\right)' in W.get_data(as_text=True)\n        W = self.tc.get('/Character/Dirichlet/4.3', follow_redirects=True)\n        assert 'Kronecker symbol' in W.get_data(as_text=True)\n        assert r'\\left(\\frac{-4}{\\bullet}\\right)' in W.get_data(as_text=True)\n\n    def test_dirichlet_calc(self):\n        W = self.tc.get('/Character/calc-gauss/Dirichlet/4/3?val=3')\n        assert '-2.0i' in W.get_data(as_text=True), \"calc gauss\"\n        assert r'\\Z/4\\Z' in W.get_data(as_text=True)\n\n        W = self.tc.get('/Character/calc-kloosterman/Dirichlet/91/3?val=52,34')\n        assert '3.774980868' in W.get_data(as_text=True), \"kloosterman\"\n\n        W = self.tc.get('Character/calc-jacobi/Dirichlet/91/3?val=37')\n        assert r'-11 \\zeta_{6} + 5' in W.get_data(as_text=True)\n\n        W = self.tc.get('Character/calc-value/Dirichlet/107/7?val=32')\n        assert 'frac{3}{106}' in W.get_data(as_text=True)\n\n    def test_dirichletchar531(self):\n        W = self.tc.get('/Character/Dirichlet/531/40')\n        assert '/Character/Dirichlet/531/247' in W.get_data(as_text=True)\n        assert '(119,415)' in W.get_data(as_text=True), \"generators\"\n        assert 'Kloosterman sum' in W.get_data(as_text=True)\n        assert r'(\\zeta_{87})' in W.get_data(as_text=True), \"field of values\"\n\n    def test_dirichletchar6000lfunc(self):\n        \"\"\" Check Sato-Tate group and L-function link for 6000/11  \"\"\"\n        W = self.tc.get('/Character/Dirichlet/6000/11')\n        assert '/SatoTateGroup/0.1.100' in W.get_data(as_text=True)\n        assert 'L/1-6000-6000.11-r0-0-0' in W.get_data(as_text=True)\n        W = self.tc.get('L/1-6000-6000.11-r0-0-0', follow_redirects=True)\n        assert '1.076603021' in W.get_data(as_text=True)\n\n    def test_dirichletchar9999lfunc(self):\n        \"\"\" Check that the L-function link for 9999/2 is displayed if and only if the L-function data is present\"\"\"\n        W = self.tc.get('/Character/Dirichlet/9999/2')\n        assert '/SatoTateGroup/0.1.300' in W.get_data(as_text=True)\n        b = get_lfunction_by_url('Character/Dirichlet/9999/2')\n        assert bool(b) == ('L/Character/Dirichlet/9999/2' in W.get_data(as_text=True))\n\n    def test_dirichletchar99999999999999999lfunc(self):\n        \"\"\" Check Dirichlet character with very large modulus\"\"\"\n        W = self.tc.get('/Character/Dirichlet/99999999999999999999/2')\n        assert r'e\\left(\\frac{881}{1818}\\right)' in W.get_data(as_text=True), \"value on a generator is wrong\"\n        assert r'\\(e\\left(\\frac{782530507}{937201725}\\right)\\)' in W.get_data(as_text=True), \"one of the first values is wrong\"\n        assert r'$\\Q(\\zeta_{3748806900})$' in W.get_data(as_text=True), \"field of values is wrong\"\n        assert r'/SatoTateGroup/0.1.3748806900' in W.get_data(as_text=True), \"Sato-Tate related object link is wrong\"\n\n    def test_sage_code_gens(self):\n        \"\"\"Test that the sage code stubs generate the correct character. This\n           is important because the same logic for generating the display code\n           is used to generate the character for computing gauss/kloosterman\n           sums etc. The three tests below have been chosen for issues\n           identified with previous versions of the sage generating code.\n        \"\"\"\n        W = self.tc.get('/Character/Dirichlet/163/4')\n        assert 'H = DirichletGroup(163, base_ring=CyclotomicField(162))' in W.get_data(as_text=True), \"sage code group is wrong\"\n        assert 'chi = DirichletCharacter(H, M([2]))' in W.get_data(as_text=True), \"sage code generator is wrong\"\n\n        W = self.tc.get('/Character/Dirichlet/16/15')\n        assert 'H = DirichletGroup(16, base_ring=CyclotomicField(2))' in W.get_data(as_text=True), \"sage code group is wrong\"\n        assert 'chi = DirichletCharacter(H, M([1,0]))' in W.get_data(as_text=True), \"sage code generator is wrong\"\n\n        W = self.tc.get('/Character/Dirichlet/91/3')\n        assert 'H = DirichletGroup(91, base_ring=CyclotomicField(6))' in W.get_data(as_text=True), \"sage code group is wrong\"\n        assert 'chi = DirichletCharacter(H, M([1,2]))' in W.get_data(as_text=True), \"sage code generator is wrong\"\n\n    def test_underlying_data(self):\n        W = self.tc.get('/Character/Dirichlet/data/289.j.7').get_data(as_text=True)\n        assert 'is_minimal' in W and 'last' in W\n        W = self.tc.get('/Character/Dirichlet/data/289.j').get_data(as_text=True)\n        assert 'is_minimal' in W"
  },
  {
    "type": "function",
    "file": "lmfdb/abvar/fq/main.py",
    "name": "__init__",
    "line_start": 187,
    "line_end": 563,
    "lines": 377,
    "bytes": 12060,
    "has_71": true,
    "code": "    def __init__(self):\n        qshort = display_knowl(\"ag.base_field\", \"Base field\")\n        q = TextBox(\n            \"q\",\n            label=\"Cardinality of the %s\" % (qshort),\n            short_label=qshort,\n            example=\"81\",\n            example_span=\"81 or 3-49\",\n        )\n        pshort = display_knowl(\"ag.base_field\", \"Base char.\")\n        p = TextBox(\n            \"p\",\n            label=\"Characteristic of the %s\" % (qshort),\n            short_label=pshort,\n            example=\"3\",\n            example_span=\"3 or 2-5\",\n        )\n        g = TextBox(\n            \"g\",\n            label=\"Dimension\",\n            knowl=\"ag.dimension\",\n            example=\"2\",\n            example_span=\"2 or 3-5\"\n        )\n        p_rank = TextBox(\n            \"p_rank\",\n            label=\"$p$-rank\",\n            knowl=\"av.fq.p_rank\",\n            example=\"2\"\n        )\n        p_corank = TextBox(\n            \"p_corank\",\n            label=\"$p$-corank\",\n            knowl=\"av.fq.p_rank\",\n            example=\"2\",\n            advanced=True,\n        )\n        angle_rank = TextBox(\n            \"angle_rank\",\n            label=\"Angle rank\",\n            knowl=\"av.fq.angle_rank\",\n            example=\"3\",\n            example_col=False,\n            advanced=True,\n        )\n        angle_corank = TextBox(\n            \"angle_corank\",\n            label=\"Angle corank\",\n            knowl=\"av.fq.angle_rank\",\n            example=\"3\",\n            example_col=False,\n            advanced=True,\n        )\n        newton_elevation = TextBox(\n            \"newton_elevation\",\n            label=\"Newton elevation\",\n            knowl=\"av.fq.newton_elevation\",\n            example=\"1\",\n            example_col=False,\n            advanced=True,\n        )\n        newton_polygon = TextBox(\n            \"newton_polygon\",\n            label=\"Slopes of Newton polygon\",\n            knowl=\"lf.newton_polygon\",\n            example=\"[0,0,1/2]\",\n            colspan=(1, 3, 1),\n            width=3*190 - 30,\n            short_width=160,\n            short_label=\"Slopes\",\n            advanced=True,\n        )\n        initial_coefficients = TextBox(\n            \"initial_coefficients\",\n            label=\"Initial coefficients\",\n            knowl=\"av.fq.initial_coefficients\",\n            example=\"[2, -1, 3, 9]\",\n        )\n        abvar_point_count = TextBox(\n            \"abvar_point_count\",\n            label=\"Point counts of the variety\",\n            knowl=\"ag.fq.point_counts\",\n            example=\"[75,7125]\",\n            colspan=(1, 3, 1),\n            width=3*190 - 30,\n            short_width=160,\n            short_label=\"Points on variety\",\n            advanced=True,\n        )\n        curve_point_count = TextBox(\n            \"curve_point_count\",\n            label=\"Point counts of the curve\",\n            knowl=\"av.fq.curve_point_counts\",\n            example=\"[9,87]\",\n            colspan=(1, 3, 1),\n            width=3*190 - 30,\n            short_width=160,\n            short_label=\"Points on curve\",\n            advanced=True,\n        )\n\n        def nbsp(knowl, label):\n            return \"&nbsp;&nbsp;&nbsp;&nbsp;\" + display_knowl(knowl, label)\n        number_field = TextBox(\n            \"number_field\",\n            label=nbsp(\"av.fq.number_field\", \"Number field\"),\n            short_label=display_knowl(\"av.fq.number_field\", \"Number field\"),\n            example=\"4.0.29584.2\",\n            example_span=\"4.0.29584.2 or Qzeta8\",\n            colspan=(1, 3, 1),\n            width=3*190 - 30,\n            short_width=160,\n            advanced=True,\n        )\n        galois_group = TextBox(\n            \"galois_group\",\n            label=nbsp(\"nf.galois_group\", \"Galois group\"),\n            short_label=display_knowl(\"nf.galois_group\", \"Galois group\"),\n            example=\"4T3\",\n            example_span=\"C4, or 8T12, a list of \"\n            + display_knowl(\"nf.galois_group.name\", \"group names\"),\n            colspan=(1, 3, 1),\n            width=3*190 - 30,\n            short_width=160,\n            advanced=True,\n        )\n        #size = TextBox(\n        #    \"size\",\n        #    label=\"Isogeny class size\",\n        #    knowl=\"av.fq.isogeny_class_size\",\n        #    example=\"1\",\n        #    example_col=False,\n        #    advanced=True,\n        #)\n        gdshort = display_knowl(\"av.endomorphism_field\", \"End.\") + \" degree\"\n        gdlong = \"Degree of \" + display_knowl(\"av.endomorphism_field\", \"endomorphism_field\")\n        geom_deg = TextBox(\n            \"geom_deg\",\n            label=gdlong,\n            short_label=gdshort,\n            example=\"168\",\n            example_span=\"6-12, 168\",\n            advanced=True,\n        )\n        jac_cnt = TextBox(\n            \"jac_cnt\",\n            label=\"Number of Jacobians\",\n            knowl=\"av.jacobian_count\",\n            example=\"6\",\n            short_label=\"# Jacobians\",\n            advanced=True,\n        )\n        hyp_cnt = TextBox(\n            \"hyp_cnt\",\n            label=\"Number of hyperelliptic Jacobians\",\n            knowl=\"av.hyperelliptic_count\",\n            example=\"6\",\n            example_col=False,\n            short_label=\"# Hyp. Jacobians\",\n            advanced=True,\n        )\n        tcshort = display_knowl(\"av.twist\", \"# twists\")\n        tclong = \"Number of \" + display_knowl(\"av.twist\", \"twists\")\n        twist_count = TextBox(\n            \"twist_count\",\n            label=tclong,\n            short_label=tcshort,\n            example=\"390\",\n            advanced=True,\n        )\n        max_twist_degree = TextBox(\n            \"max_twist_degree\",\n            label=\"Max twist degree\",\n            knowl=\"av.twist\",\n            example=\"16\",\n            example_col=False,\n            advanced=True,\n        )\n        simple = YesNoBox(\n            \"simple\",\n            label=\"Simple\",\n            knowl=\"av.simple\",\n        )\n        geom_simple = YesNoBox(\n            \"geom_simple\",\n            label=\"Geometrically simple\",\n            knowl=\"av.geometrically_simple\",\n            short_label=\"Geom. simple\",\n        )\n        geom_squarefree = SelectBox(\n            name=\"geom_squarefree\",\n            knowl=\"av.geometrically_squarefree\",\n            label=\"(Geometrically) Squarefree\",\n            short_label=\"(Geom.) Sq.free\",\n            options=[('', ''),\n            ('Yes', 'yes'),\n            ('YesAndGeom', 'yes; and geom.'),\n            ('YesNotGeom', 'yes; not geom.'),\n            ('No', 'no'),\n            ('NotGeom', 'not geom.')],\n            advanced=True\n        )\n        primitive = YesNoBox(\n            \"primitive\",\n            label=\"Primitive\",\n            knowl=\"ag.primitive\",\n        )\n        polarizable = YesNoMaybeBox(\n            \"polarizable\",\n            label=\"Principally polarizable\",\n            knowl=\"av.princ_polarizable\",\n            short_label=\"Princ. polarizable\",\n        )\n        jacobian = YesNoMaybeBox(\n            \"jacobian\",\n            label=\"Jacobian\",\n            knowl=\"ag.jacobian\",\n        )\n\n        # Cyclic group of points (advanced yes/no box)\n        cyclic = YesNoBox(\n            \"cyclic\",\n            label=\"Cyclic group of points\",\n            knowl=\"av.fq.cyclic_group_points\",\n            advanced=True,\n        )\n\n        # Non-cyclic primes with mode selector (include / exactly / subset)\n        noncyclic_mode = SubsetBox(\n            \"noncyclic_primes_mode\",\n            advanced=True,\n        )\n        noncyclic_primes = TextBoxWithSelect(\n            \"noncyclic_primes\",\n            label=\"Non-cyclic primes\",\n            select_box=noncyclic_mode,\n            knowl=\"av.fq.noncyclic_primes\",\n            example=\"2 or 2,3,5\",\n            advanced=True,\n        )\n\n        uglabel = \"Use %s in the following inputs\" % display_knowl(\"av.decomposition\", \"Geometric decomposition\")\n        use_geom_decomp = CheckBox(\n            \"use_geom_decomp\",\n            label=uglabel,\n            short_label=uglabel\n        )\n        use_geom_index = CheckboxSpacer(use_geom_decomp, colspan=4, advanced=True)\n        use_geom_refine = CheckboxSpacer(use_geom_decomp, colspan=5, advanced=True)\n\n        def long_label(d):\n            return nbsp(\"av.decomposition\", f\"Dimension {d} factors\")\n\n        def short_label(d):\n            return display_knowl(\"av.decomposition\", f\"Dim {d} factors\")\n\n        dim1 = TextBox(\n            \"dim1_factors\",\n            label=long_label(1),\n            example=\"1-3\",\n            example_col=False,\n            short_label=short_label(1),\n            advanced=True,\n        )\n        dim1d = TextBox(\n            \"dim1_distinct\",\n            label=\"Distinct factors\",\n            knowl=\"av.decomposition\",\n            example=\"1-2\",\n            example_span=\"2 or 1-3\",\n            short_label=\"(distinct)\",\n            advanced=True,\n        )\n        dim2 = TextBox(\n            \"dim2_factors\",\n            label=long_label(2),\n            example=\"1-3\",\n            example_col=False,\n            short_label=short_label(2),\n            advanced=True,\n        )\n        dim2d = TextBox(\n            \"dim2_distinct\",\n            label=\"Distinct factors\",\n            knowl=\"av.decomposition\",\n            example=\"1-2\",\n            example_span=\"2 or 1-3\",\n            short_label=\"(distinct)\",\n            advanced=True,\n        )\n        dim3 = TextBox(\n            \"dim3_factors\",\n            label=long_label(3),\n            example=\"2\",\n            example_col=False,\n            short_label=short_label(3),\n            advanced=True,\n        )\n        dim3d = TextBox(\n            \"dim3_distinct\",\n            label=\"Distinct factors\",\n            knowl=\"av.decomposition\",\n            example=\"1\",\n            example_span=\"2 or 0-1\",\n            short_label=\"(distinct)\",\n            advanced=True,\n        )\n        dim4 = TextBox(\n            \"dim4_factors\",\n            label=long_label(4),\n            example=\"2\",\n            example_col=False,\n            short_label=short_label(4),\n            advanced=True,\n        )\n        dim5 = TextBox(\n            \"dim5_factors\",\n            label=long_label(5),\n            example=\"2\",\n            example_col=False,\n            short_label=short_label(5),\n            advanced=True,\n        )\n        dim4d = dim5d = SkipBox(example_span=\"0 or 1\", advanced=True)\n        simple_quantifier = SubsetBox(\n            \"simple_quantifier\",\n        )\n        simple_factors = TextBoxWithSelect(\n            \"simple_factors\",\n            label=\"Simple factors\",\n            select_box=simple_quantifier,\n            knowl=\"av.decomposition\",\n            colspan=(1, 3, 2),\n            width=3*190 - 30,\n            short_width=2*190 - 30,\n            example=\"1.2.b,1.2.b,2.2.a_b\",\n            advanced=True,\n        )\n        count = CountBox()\n\n        self.refine_array = [\n            [q, p, g, p_rank, initial_coefficients],\n            [simple, geom_simple, primitive, polarizable, jacobian],\n            [newton_polygon, abvar_point_count, curve_point_count, simple_factors],\n            [newton_elevation, jac_cnt, hyp_cnt, twist_count, max_twist_degree],\n            [angle_rank, angle_corank, geom_deg, p_corank, geom_squarefree],\n            [cyclic, noncyclic_primes],\n            use_geom_refine,\n            [dim1, dim2, dim3, dim4, dim5],\n            [dim1d, dim2d, dim3d, number_field, galois_group],\n        ]\n        self.browse_array = [\n            [q, primitive],\n            [p, simple],\n            [g, geom_simple],\n            [initial_coefficients, polarizable],\n            [p_rank, jacobian],\n            [cyclic, noncyclic_primes],\n            [p_corank, geom_squarefree],\n            [jac_cnt, hyp_cnt],\n            [angle_rank, angle_corank],\n            [twist_count, max_twist_degree],\n            [newton_elevation, geom_deg],\n            [newton_polygon],\n            [abvar_point_count],\n            [curve_point_count],\n            [simple_factors],\n            use_geom_index,\n            [dim1, dim1d],\n            [dim2, dim2d],\n            [dim3, dim3d],\n            [dim4, dim4d],\n            [dim5, dim5d],\n            [number_field],\n            [galois_group],\n            [count],\n        ]"
  },
  {
    "type": "class",
    "file": "lmfdb/symL/sympowlmfdb.py",
    "name": "SympowLMFDB",
    "line_start": 57,
    "line_end": 458,
    "lines": 402,
    "bytes": 13062,
    "has_71": true,
    "code": "class SympowLMFDB(SageObject):\n    r\"\"\"\n    Watkins Symmetric Power `L`-function Calculator\n\n    Type ``sympow.[tab]`` for a list of useful commands\n    that are implemented using the command line interface, but return\n    objects that make sense in Sage.\n\n    You can also use the complete command-line interface of sympow via\n    this class. Type ``sympow.help()`` for a list of\n    commands and how to call them.\n    \"\"\"\n    def _repr_(self):\n        \"\"\"\n        Returns a string describing this calculator module\n        \"\"\"\n        return \"Watkins Symmetric Power L-function Calculator\"\n\n    def __call__(self, args):\n        \"\"\"\n        Used to call sympow with given args\n        \"\"\"\n        cmd = 'sympow %s' % args\n        v = os.popen(cmd).read().strip()\n        verbose(v, level=2)\n        return v\n\n    def _fix_err(self, err):\n        w = err\n        j = w.rfind('./sympow')\n        if j != -1:\n            w = w[:j - 1] + \"sympow('\" + w[j + 9:] + ')'\n        return w\n\n    def _curve_str(self, E):\n        return '-curve \"%s\"' % (str(list(E.minimal_model().a_invariants())).replace(' ', ''))\n\n    def L(self, E, n, prec):\n        r\"\"\"\n        Return `L(\\mathrm{Sym}^{(n)}(E, \\text{edge}))` to prec digits of\n        precision, where edge is the *right* edge. Here `n` must be\n        even.\n\n        INPUT:\n\n\n        -  ``E`` - elliptic curve\n\n        -  ``n`` - even integer\n\n        -  ``prec`` - integer\n\n\n        OUTPUT:\n\n\n        -  ``string`` - real number to prec digits of precision\n           as a string.\n\n\n        .. note::\n\n           Before using this function for the first time for a given\n           `n`, you may have to type ``sympow('-new_data n')``,\n           where ``n`` is replaced by your value of `n`.\n\n        If you would like to see the extensive output sympow prints when\n        running this function, just type ``set_verbose(2)``.\n\n        EXAMPLES::\n\n            sage: a = sympow.L(EllipticCurve('11a'), 2, 16); a   # optional\n            '1.057599244590958E+00'\n            sage: RR(a)                    # optional -- requires precomputations\n            1.05759924459096\n        \"\"\"\n        if n % 2 == 1:\n            raise ValueError(\"n (=%s) must be even\" % n)\n        if prec > 64:\n            raise ValueError(\"prec (=%s) must be at most 64\" % prec)\n        if prec < 1:\n            raise ValueError(\"prec (=%s) must be at least 1\" % prec)\n        v = self('-sp %sp%s %s' % (n, prec, self._curve_str(E)))\n        i = v.rfind(': ')\n        if i == -1:\n            print(self._fix_err(v))\n            raise RuntimeError(\"failed to compute symmetric power\")\n        x = v[i + 2:]\n        return x\n\n    def local_data(self, E, n, prec=64):\n        import re\n        R = PolynomialRing(RationalField(), 'x')\n\n        if prec > 64:\n            raise ValueError(\"prec (=%s) must be at most 64\" % prec)\n        if prec < 1:\n            raise ValueError(\"prec (=%s) must be at least 1\" % prec)\n\n        if n % 2 != 1:\n            v = self('-sp %sp%s -local  %s' % (n, prec, self._curve_str(E)))\n        else:\n            v = self('-sp %sp%sd0 -local  %s' % (n, prec, self._curve_str(E)))\n\n        vv = v.split('\\n')\n\n        bad_primes_l = [i for i in vv if re.match(r'sp %d: Euler' % n, i)]\n\n        bad_primes = [(Integer(i.split()[5]),\n                       R(i.split()[7]).coefficients(sparse=False)) for i in bad_primes_l]\n\n        cond_rootn_string = [i for i in vv if re.search('conductor', i)].pop()\n        cond_rootn_string = cond_rootn_string.replace(',', ' ')\n\n        conductor, root = Integer(\n            cond_rootn_string.split()[5]), Integer(cond_rootn_string.split()[-1])\n\n        return bad_primes, conductor, root\n        # j = v.rfind(': ')\n        # if i == -1:\n            # print self._fix_err(v)\n            # raise RuntimeError, \"failed to compute symmetric power\"\n        # x = v[i+2:]\n\n    def Lderivs(self, E, n, prec, d):\n        r\"\"\"\n        Return `0^{th}` to `d^{th}` derivatives of\n        `L(\\mathrm{Sym}^{(n)}(E,s)` to prec digits of precision, where\n        `s` is the right edge if `n` is even and the center\n        if `n` is odd.\n\n        INPUT:\n\n\n        -  ``E`` - elliptic curve\n\n        -  ``n`` - integer (even or odd)\n\n        -  ``prec`` - integer\n\n        -  ``d`` - integer\n\n\n        OUTPUT: a string, exactly as output by sympow\n\n        .. note::\n\n           To use this function you may have to run a few commands\n           like ``sympow('-new_data 1d2')``, each which takes a\n           few minutes. If this function fails it will indicate what commands\n           have to be run.\n\n        EXAMPLES::\n\n            sage: print(sympow.Lderivs(EllipticCurve('11a'), 1, 16, 2))  # not tested\n            ...\n             1n0: 2.538418608559107E-01\n             1w0: 2.538418608559108E-01\n             1n1: 1.032321840884568E-01\n             1w1: 1.059251499158892E-01\n             1n2: 3.238743180659171E-02\n             1w2: 3.414818600982502E-02\n        \"\"\"\n        if prec > 64:\n            raise ValueError(\"prec (=%s) must be at most 64\" % prec)\n        if prec < 1:\n            raise ValueError(\"prec (=%s) must be at least 1\" % prec)\n        v = self('-sp %sp%sd%s %s' % (n, prec, d, self._curve_str(E)))\n        return self._fix_err(v)\n\n    def modular_degree(self, E):\n        \"\"\"\n        Return the modular degree of the elliptic curve E, assuming the\n        Stevens conjecture.\n\n        INPUT:\n\n\n        -  ``E`` - elliptic curve over Q\n\n\n        OUTPUT:\n\n\n        -  ``integer`` - modular degree\n\n\n        EXAMPLES: We compute the modular degrees of the lowest known\n        conductor curves of the first few ranks::\n\n            sage: sympow.modular_degree(EllipticCurve('11a'))\n            1\n            sage: sympow.modular_degree(EllipticCurve('37a'))\n            2\n            sage: sympow.modular_degree(EllipticCurve('389a'))\n            40\n            sage: sympow.modular_degree(EllipticCurve('5077a'))\n            1984\n            sage: sympow.modular_degree(EllipticCurve([1, -1, 0, -79, 289]))\n            334976\n        \"\"\"\n        v = self('%s -moddeg' % self._curve_str(E))\n        s = 'Modular Degree is '\n        i = v.find(s)\n        if i == -1:\n            print(self._fix_err(v))\n            raise RuntimeError(\"failed to compute modular degree\")\n        return Integer(v[i + len(s):])\n\n    def analytic_rank(self, E):\n        r\"\"\"\n        Return the analytic rank and leading `L`-value of the\n        elliptic curve `E`.\n\n        INPUT:\n\n\n        -  ``E`` - elliptic curve over Q\n\n\n        OUTPUT:\n\n\n        -  ``integer`` - analytic rank\n\n        -  ``string`` - leading coefficient (as string)\n\n\n        .. note::\n\n           The analytic rank is *not* computed provably correctly in\n           general.\n\n        .. note::\n\n           In computing the analytic rank we consider\n           `L^{(r)}(E,1)` to be `0` if\n           `L^{(r)}(E,1)/\\Omega_E > 0.0001`.\n\n        EXAMPLES: We compute the analytic ranks of the lowest known\n        conductor curves of the first few ranks::\n\n            sage: sympow.analytic_rank(EllipticCurve('11a'))\n            (0, '2.53842e-01')\n            sage: sympow.analytic_rank(EllipticCurve('37a'))\n            (1, '3.06000e-01')\n            sage: sympow.analytic_rank(EllipticCurve('389a'))\n            (2, '7.59317e-01')\n            sage: sympow.analytic_rank(EllipticCurve('5077a'))\n            (3, '1.73185e+00')\n            sage: sympow.analytic_rank(EllipticCurve([1, -1, 0, -79, 289]))\n            (4, '8.94385e+00')\n            sage: sympow.analytic_rank(EllipticCurve([0, 0, 1, -79, 342]))  # long time\n            (5, '3.02857e+01')\n            sage: sympow.analytic_rank(EllipticCurve([1, 1, 0, -2582, 48720]))  # long time\n            (6, '3.20781e+02')\n            sage: sympow.analytic_rank(EllipticCurve([0, 0, 0, -10012, 346900]))  # long time\n            (7, '1.32517e+03')\n        \"\"\"\n        v = self('%s -analrank' % self._curve_str(E))\n        s = 'Analytic Rank is '\n        i = v.rfind(s)\n        if i == -1:\n            print(self._fix_err(v))\n            raise RuntimeError(\"failed to compute analytic rank\")\n        j = v.rfind(':')\n        r = Integer(v[i + len(s):j])\n        i = v.rfind(' ')\n        L = v[i + 1:]\n        return r, L\n\n    def new_data(self, n):\n        \"\"\"\n        Pre-compute data files needed for computation of n-th symmetric\n        powers.\n        \"\"\"\n        print(self('-new_data %s' % n))\n\n    def help(self):\n        h = \"\"\"\n     sympow('-sp 2p16 -curve \"[1,2,3,4,5]\"')\nwill compute L(Sym^2 E,edge) for E=[1,2,3,4,5] to 16 digits of precision\nThe result\n 2n0: 8.370510845377639E-01\n 2w0: 8.370510845377586E-01\nconsists of two calculations using different parameters to test the\nfunctional equation (to see if these are sufficiently close).\n\n     sympow('-sp 3p12d2,4p8 -curve \"[1,2,3,4,5]\"')\nwill compute the 0th-2nd derivatives of L(Sym^3 E,center) to 12 digits\nand L(Sym^4 E,edge) to 8 digits\n\nSpecial cases: When a curve has CM, Hecke power can be used instead\n\n     sympow('-sp 7p12d1 -hecke -curve \"[0,0,1,-16758,835805]\"')\n\nwill compute the 0th-1st derivatives of L(Sym^7 psi,special) to 12 digits.\n\nBloch-Kato numbers can be obtained for powers not congruent to 0 mod 4:\n\n     sympow('-sp 2bp16 -curve \"[1,2,3,4,5]\"')\n\nshould return\n 2n0: 4.640000000000006E+02\n 2w0: 4.639999999999976E+02\nwhich can be seen to be very close to the integer 464.\n\nModular degrees can be computed with the -moddeg option.\n\n     sympow('-curve \"[1,2,3,4,5]\" -moddeg')\n\nshould return\nModular Degree is 464\n\nAnalytic ranks can be computed with the -analrank option.\n\n     sympow('-curve \"[1,2,3,4,5]\" -analrank')\n\nshould return\nAnalytic Rank is 1 : L'-value 3.51873e+00\n\nand (if the mesh file for the fifth derivative is present)\n\n     sympow('-curve \"[0,0,1,-79,342]\" -analrank')\n\nshould return\nAnalytic Rank is 5 : leading L-term 3.02857e+01\n\n========================================================================\n\nAdding new symmetric powers:\n\nSYMPOW keeps data for symmetric powers in the directory datafiles\nIf a pre-computed mesh of inverse Mellin transform values is not\navailable for a given symmetric power, SYMPOW will fail. The command\n\n     sympow('-new_data 2')\n\nwill add the data the 2nd symmetric power, while\n\n     sympow('-new_data 3d2')\n\nwill add the data for the 2nd derivative and 3rd symmetric power,\n\n     sympow('-new_data 6d0h')\n\nwill add the data for the 0th derivative of the 6th Hecke power, and\n\n     sympow('-new_data 4c')\n\nwill add data for the 4th symmetric power for curves with CM\n(these need to be done separately for powers divisible by 4).\n\nThe mesh files are stored in binary form, and thus endian-ness is a\nworry when moving from one platform to another.\n\nTo enable modular degree computations, the 2nd symmetric power must\nbe extant, and analytic rank requires derivatives of the 1st power.\n\n===================================================================\n\nOutput of \"!sympow -help\":\n\n -bound #      an upper BOUND for how many ap to compute\n -help         print the help message and exit\n -info [] []   only report local information for primes/sympows\n               1st argument is prime range, 2nd is sympow range\n -local        only report local information (bad primes)\n -curve []     input a curve in [a1,a2,a3,a4,a6] form\n -label []     label the given curve\n -quiet        turn off some messages\n -verbose      turn on some messages\n -rootno #     compute the root number of the #th symmetric power\n -moddeg       compute the modular degree\n -analrank     compute the analytic rank\n -sloppy []    for use with -analrank; have X sloppy digits\n -nocm         abort if curve has complex multiplication\n -noqt         ignore even powers of non-minimal quad twists\n -hecke        compute Hecke symmetric powers for a CM curve\n -maxtable     set the max size of factor tables: 2^27 default\n -sp  []       argument to specify which powers\n               this is a comma separated list\n               in each entry, the 1st datum is the sympow\n               then could come b which turns Bloch-Kato on\n               then could come w# which specifies how many tests\n               then could come s# which says # sloppy digits\n               then must come p# which specifies the precision\n                    or P# which says ignore BOUND for this power\n               then must come d# which says the derivative bound\n                    or D# which says do only this derivative\n                    (neither need be indicated for even powers)\n               default is 2w3s1p32,3bp16d1,4p8\n -new_data []  will compute inverse Mellin transform mesh for\n               the given data: the format is [sp]d[dv]{h,c}\n               sp is the symmetric power, dv is the derivative,\n               h indicates Hecke powers, and c indicates CM case\n               d[dv] is given only for odd or Hecke powers\n               Examples: 1d3 2 2d1h 3d2 4 4c 5d0 6 7d0h 11d1 12c\n               NOTE: new_data runs a shell script that uses GP\nOther options are used internally/recursively by -new_data\n\"\"\"\n        pager()(h)"
  },
  {
    "type": "class",
    "file": "lmfdb/abvar/fq/main.py",
    "name": "AbvarSearchArray",
    "line_start": 168,
    "line_end": 569,
    "lines": 402,
    "bytes": 13487,
    "has_71": true,
    "code": "class AbvarSearchArray(SearchArray):\n    sorts = [(\"\", \"dimension\", ['g', 'q', 'poly']),\n             (\"q\", \"field\", ['q', 'g', 'poly']),\n             (\"p\", \"characteristic\", ['p', 'q', 'g', 'poly']),\n             (\"p_rank\", \"p-rank\", ['p_rank', 'g', 'q', 'poly']),\n             (\"angle_rank\", \"angle rank\", ['angle_rank', 'g', 'q', 'poly']),\n             (\"elevation\", \"Newton elevation\", ['newton_elevation', 'g', 'q', 'poly']),\n             (\"curve_count\", \"curve points\", ['curve_count', 'g', 'q', 'poly']),\n             (\"abvar_count\", \"abvar points\", ['abvar_count', 'g', 'q', 'poly']),\n             (\"jacobian_count\", \"Jacobian count\", ['jacobian_count', 'g', 'q', 'poly']),\n             (\"hyp_count\", \"Hyp. Jacobian count\", ['hyp_count', 'g', 'q', 'poly']),\n             (\"twist_count\", \"Num .twists\", ['twist_count', 'g', 'q', 'poly']),\n             (\"max_twist_degree\", \"Max. twist degree\", ['max_twist_degree', 'g', 'q', 'poly']),\n             (\"geom_deg\", \"End. degree\", ['geometric_extension_degree', 'g', 'q', 'poly'])]\n    jump_example = \"2.16.am_cn\"\n    jump_egspan = \"e.g. 2.16.am_cn or 1 - x + 2x^2 or x^2 - x + 2\"\n    jump_knowl = \"av.fq.search_input\"\n    jump_prompt = \"Label or polynomial\"\n\n    def __init__(self):\n        qshort = display_knowl(\"ag.base_field\", \"Base field\")\n        q = TextBox(\n            \"q\",\n            label=\"Cardinality of the %s\" % (qshort),\n            short_label=qshort,\n            example=\"81\",\n            example_span=\"81 or 3-49\",\n        )\n        pshort = display_knowl(\"ag.base_field\", \"Base char.\")\n        p = TextBox(\n            \"p\",\n            label=\"Characteristic of the %s\" % (qshort),\n            short_label=pshort,\n            example=\"3\",\n            example_span=\"3 or 2-5\",\n        )\n        g = TextBox(\n            \"g\",\n            label=\"Dimension\",\n            knowl=\"ag.dimension\",\n            example=\"2\",\n            example_span=\"2 or 3-5\"\n        )\n        p_rank = TextBox(\n            \"p_rank\",\n            label=\"$p$-rank\",\n            knowl=\"av.fq.p_rank\",\n            example=\"2\"\n        )\n        p_corank = TextBox(\n            \"p_corank\",\n            label=\"$p$-corank\",\n            knowl=\"av.fq.p_rank\",\n            example=\"2\",\n            advanced=True,\n        )\n        angle_rank = TextBox(\n            \"angle_rank\",\n            label=\"Angle rank\",\n            knowl=\"av.fq.angle_rank\",\n            example=\"3\",\n            example_col=False,\n            advanced=True,\n        )\n        angle_corank = TextBox(\n            \"angle_corank\",\n            label=\"Angle corank\",\n            knowl=\"av.fq.angle_rank\",\n            example=\"3\",\n            example_col=False,\n            advanced=True,\n        )\n        newton_elevation = TextBox(\n            \"newton_elevation\",\n            label=\"Newton elevation\",\n            knowl=\"av.fq.newton_elevation\",\n            example=\"1\",\n            example_col=False,\n            advanced=True,\n        )\n        newton_polygon = TextBox(\n            \"newton_polygon\",\n            label=\"Slopes of Newton polygon\",\n            knowl=\"lf.newton_polygon\",\n            example=\"[0,0,1/2]\",\n            colspan=(1, 3, 1),\n            width=3*190 - 30,\n            short_width=160,\n            short_label=\"Slopes\",\n            advanced=True,\n        )\n        initial_coefficients = TextBox(\n            \"initial_coefficients\",\n            label=\"Initial coefficients\",\n            knowl=\"av.fq.initial_coefficients\",\n            example=\"[2, -1, 3, 9]\",\n        )\n        abvar_point_count = TextBox(\n            \"abvar_point_count\",\n            label=\"Point counts of the variety\",\n            knowl=\"ag.fq.point_counts\",\n            example=\"[75,7125]\",\n            colspan=(1, 3, 1),\n            width=3*190 - 30,\n            short_width=160,\n            short_label=\"Points on variety\",\n            advanced=True,\n        )\n        curve_point_count = TextBox(\n            \"curve_point_count\",\n            label=\"Point counts of the curve\",\n            knowl=\"av.fq.curve_point_counts\",\n            example=\"[9,87]\",\n            colspan=(1, 3, 1),\n            width=3*190 - 30,\n            short_width=160,\n            short_label=\"Points on curve\",\n            advanced=True,\n        )\n\n        def nbsp(knowl, label):\n            return \"&nbsp;&nbsp;&nbsp;&nbsp;\" + display_knowl(knowl, label)\n        number_field = TextBox(\n            \"number_field\",\n            label=nbsp(\"av.fq.number_field\", \"Number field\"),\n            short_label=display_knowl(\"av.fq.number_field\", \"Number field\"),\n            example=\"4.0.29584.2\",\n            example_span=\"4.0.29584.2 or Qzeta8\",\n            colspan=(1, 3, 1),\n            width=3*190 - 30,\n            short_width=160,\n            advanced=True,\n        )\n        galois_group = TextBox(\n            \"galois_group\",\n            label=nbsp(\"nf.galois_group\", \"Galois group\"),\n            short_label=display_knowl(\"nf.galois_group\", \"Galois group\"),\n            example=\"4T3\",\n            example_span=\"C4, or 8T12, a list of \"\n            + display_knowl(\"nf.galois_group.name\", \"group names\"),\n            colspan=(1, 3, 1),\n            width=3*190 - 30,\n            short_width=160,\n            advanced=True,\n        )\n        #size = TextBox(\n        #    \"size\",\n        #    label=\"Isogeny class size\",\n        #    knowl=\"av.fq.isogeny_class_size\",\n        #    example=\"1\",\n        #    example_col=False,\n        #    advanced=True,\n        #)\n        gdshort = display_knowl(\"av.endomorphism_field\", \"End.\") + \" degree\"\n        gdlong = \"Degree of \" + display_knowl(\"av.endomorphism_field\", \"endomorphism_field\")\n        geom_deg = TextBox(\n            \"geom_deg\",\n            label=gdlong,\n            short_label=gdshort,\n            example=\"168\",\n            example_span=\"6-12, 168\",\n            advanced=True,\n        )\n        jac_cnt = TextBox(\n            \"jac_cnt\",\n            label=\"Number of Jacobians\",\n            knowl=\"av.jacobian_count\",\n            example=\"6\",\n            short_label=\"# Jacobians\",\n            advanced=True,\n        )\n        hyp_cnt = TextBox(\n            \"hyp_cnt\",\n            label=\"Number of hyperelliptic Jacobians\",\n            knowl=\"av.hyperelliptic_count\",\n            example=\"6\",\n            example_col=False,\n            short_label=\"# Hyp. Jacobians\",\n            advanced=True,\n        )\n        tcshort = display_knowl(\"av.twist\", \"# twists\")\n        tclong = \"Number of \" + display_knowl(\"av.twist\", \"twists\")\n        twist_count = TextBox(\n            \"twist_count\",\n            label=tclong,\n            short_label=tcshort,\n            example=\"390\",\n            advanced=True,\n        )\n        max_twist_degree = TextBox(\n            \"max_twist_degree\",\n            label=\"Max twist degree\",\n            knowl=\"av.twist\",\n            example=\"16\",\n            example_col=False,\n            advanced=True,\n        )\n        simple = YesNoBox(\n            \"simple\",\n            label=\"Simple\",\n            knowl=\"av.simple\",\n        )\n        geom_simple = YesNoBox(\n            \"geom_simple\",\n            label=\"Geometrically simple\",\n            knowl=\"av.geometrically_simple\",\n            short_label=\"Geom. simple\",\n        )\n        geom_squarefree = SelectBox(\n            name=\"geom_squarefree\",\n            knowl=\"av.geometrically_squarefree\",\n            label=\"(Geometrically) Squarefree\",\n            short_label=\"(Geom.) Sq.free\",\n            options=[('', ''),\n            ('Yes', 'yes'),\n            ('YesAndGeom', 'yes; and geom.'),\n            ('YesNotGeom', 'yes; not geom.'),\n            ('No', 'no'),\n            ('NotGeom', 'not geom.')],\n            advanced=True\n        )\n        primitive = YesNoBox(\n            \"primitive\",\n            label=\"Primitive\",\n            knowl=\"ag.primitive\",\n        )\n        polarizable = YesNoMaybeBox(\n            \"polarizable\",\n            label=\"Principally polarizable\",\n            knowl=\"av.princ_polarizable\",\n            short_label=\"Princ. polarizable\",\n        )\n        jacobian = YesNoMaybeBox(\n            \"jacobian\",\n            label=\"Jacobian\",\n            knowl=\"ag.jacobian\",\n        )\n\n        # Cyclic group of points (advanced yes/no box)\n        cyclic = YesNoBox(\n            \"cyclic\",\n            label=\"Cyclic group of points\",\n            knowl=\"av.fq.cyclic_group_points\",\n            advanced=True,\n        )\n\n        # Non-cyclic primes with mode selector (include / exactly / subset)\n        noncyclic_mode = SubsetBox(\n            \"noncyclic_primes_mode\",\n            advanced=True,\n        )\n        noncyclic_primes = TextBoxWithSelect(\n            \"noncyclic_primes\",\n            label=\"Non-cyclic primes\",\n            select_box=noncyclic_mode,\n            knowl=\"av.fq.noncyclic_primes\",\n            example=\"2 or 2,3,5\",\n            advanced=True,\n        )\n\n        uglabel = \"Use %s in the following inputs\" % display_knowl(\"av.decomposition\", \"Geometric decomposition\")\n        use_geom_decomp = CheckBox(\n            \"use_geom_decomp\",\n            label=uglabel,\n            short_label=uglabel\n        )\n        use_geom_index = CheckboxSpacer(use_geom_decomp, colspan=4, advanced=True)\n        use_geom_refine = CheckboxSpacer(use_geom_decomp, colspan=5, advanced=True)\n\n        def long_label(d):\n            return nbsp(\"av.decomposition\", f\"Dimension {d} factors\")\n\n        def short_label(d):\n            return display_knowl(\"av.decomposition\", f\"Dim {d} factors\")\n\n        dim1 = TextBox(\n            \"dim1_factors\",\n            label=long_label(1),\n            example=\"1-3\",\n            example_col=False,\n            short_label=short_label(1),\n            advanced=True,\n        )\n        dim1d = TextBox(\n            \"dim1_distinct\",\n            label=\"Distinct factors\",\n            knowl=\"av.decomposition\",\n            example=\"1-2\",\n            example_span=\"2 or 1-3\",\n            short_label=\"(distinct)\",\n            advanced=True,\n        )\n        dim2 = TextBox(\n            \"dim2_factors\",\n            label=long_label(2),\n            example=\"1-3\",\n            example_col=False,\n            short_label=short_label(2),\n            advanced=True,\n        )\n        dim2d = TextBox(\n            \"dim2_distinct\",\n            label=\"Distinct factors\",\n            knowl=\"av.decomposition\",\n            example=\"1-2\",\n            example_span=\"2 or 1-3\",\n            short_label=\"(distinct)\",\n            advanced=True,\n        )\n        dim3 = TextBox(\n            \"dim3_factors\",\n            label=long_label(3),\n            example=\"2\",\n            example_col=False,\n            short_label=short_label(3),\n            advanced=True,\n        )\n        dim3d = TextBox(\n            \"dim3_distinct\",\n            label=\"Distinct factors\",\n            knowl=\"av.decomposition\",\n            example=\"1\",\n            example_span=\"2 or 0-1\",\n            short_label=\"(distinct)\",\n            advanced=True,\n        )\n        dim4 = TextBox(\n            \"dim4_factors\",\n            label=long_label(4),\n            example=\"2\",\n            example_col=False,\n            short_label=short_label(4),\n            advanced=True,\n        )\n        dim5 = TextBox(\n            \"dim5_factors\",\n            label=long_label(5),\n            example=\"2\",\n            example_col=False,\n            short_label=short_label(5),\n            advanced=True,\n        )\n        dim4d = dim5d = SkipBox(example_span=\"0 or 1\", advanced=True)\n        simple_quantifier = SubsetBox(\n            \"simple_quantifier\",\n        )\n        simple_factors = TextBoxWithSelect(\n            \"simple_factors\",\n            label=\"Simple factors\",\n            select_box=simple_quantifier,\n            knowl=\"av.decomposition\",\n            colspan=(1, 3, 2),\n            width=3*190 - 30,\n            short_width=2*190 - 30,\n            example=\"1.2.b,1.2.b,2.2.a_b\",\n            advanced=True,\n        )\n        count = CountBox()\n\n        self.refine_array = [\n            [q, p, g, p_rank, initial_coefficients],\n            [simple, geom_simple, primitive, polarizable, jacobian],\n            [newton_polygon, abvar_point_count, curve_point_count, simple_factors],\n            [newton_elevation, jac_cnt, hyp_cnt, twist_count, max_twist_degree],\n            [angle_rank, angle_corank, geom_deg, p_corank, geom_squarefree],\n            [cyclic, noncyclic_primes],\n            use_geom_refine,\n            [dim1, dim2, dim3, dim4, dim5],\n            [dim1d, dim2d, dim3d, number_field, galois_group],\n        ]\n        self.browse_array = [\n            [q, primitive],\n            [p, simple],\n            [g, geom_simple],\n            [initial_coefficients, polarizable],\n            [p_rank, jacobian],\n            [cyclic, noncyclic_primes],\n            [p_corank, geom_squarefree],\n            [jac_cnt, hyp_cnt],\n            [angle_rank, angle_corank],\n            [twist_count, max_twist_degree],\n            [newton_elevation, geom_deg],\n            [newton_polygon],\n            [abvar_point_count],\n            [curve_point_count],\n            [simple_factors],\n            use_geom_index,\n            [dim1, dim1d],\n            [dim2, dim2d],\n            [dim3, dim3d],\n            [dim4, dim4d],\n            [dim5, dim5d],\n            [number_field],\n            [galois_group],\n            [count],\n        ]\n\n    def search_types(self, info):\n        return self._search_again(info, [\n            ('List', 'List of isogeny classes'),\n            ('Counts', 'Counts table'),\n            ('Random', 'Random isogeny class')])"
  },
  {
    "type": "function",
    "file": "lmfdb/groups/abstract/main.py",
    "name": "__init__",
    "line_start": 2599,
    "line_end": 3025,
    "lines": 427,
    "bytes": 14392,
    "has_71": true,
    "code": "    def __init__(self):\n        order = TextBox(\n            name=\"order\",\n            label=\"Order\",\n            knowl=\"group.order\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n        )\n        exponent = TextBox(\n            name=\"exponent\",\n            label=\"Exponent\",\n            knowl=\"group.exponent\",\n            example=\"2, 3, 7\",\n            example_span=\"2, or list of integers like 2, 3, 7\",\n        )\n        nilpclass = TextBox(\n            name=\"nilpotency_class\",\n            label=\"Nilpotency class\",\n            knowl=\"group.nilpotent\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n        )\n        aut_group = TextBox(\n            name=\"aut_group\",\n            label=\"Automorphism group\",\n            knowl=\"group.automorphism\",\n            example=\"4.2\",\n            example_span=\"4.2\",\n        )\n        aut_order = TextBox(\n            name=\"aut_order\",\n            label=\"Automorphism group order\",\n            short_label=\"Automorphisms\",\n            knowl=\"group.automorphism\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n        )\n        derived_length = TextBox(\n            name=\"derived_length\",\n            label=\"Derived length\",\n            knowl=\"group.derived_series\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n            advanced=True,\n        )\n        frattini_label = TextBox(\n            name=\"frattini_label\",\n            label=\"Frattini subgroup\",\n            knowl=\"group.frattini_subgroup\",\n            example=\"4.2\",\n            example_span=\"4.2\",\n            advanced=True,\n        )\n        outer_group = TextBox(\n            name=\"outer_group\",\n            label=\"Outer aut. group\",\n            knowl=\"group.outer_aut\",\n            example=\"4.2\",\n            example_span=\"4.2\",\n            advanced=True,\n        )\n        outer_order = TextBox(\n            name=\"outer_order\",\n            label=\"Outer aut. group order\",\n            short_label=\"Outer automorphisms\",\n            knowl=\"group.outer_aut\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n            advanced=True,\n        )\n        rank = TextBox(\n            name=\"rank\",\n            label=\"Rank\",\n            knowl=\"group.rank\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n            advanced=True,\n        )\n        abelian = YesNoBox(\n            name=\"abelian\", label=\"Abelian\", knowl=\"group.abelian\", example_col=True\n        )\n        metabelian = YesNoBox(\n            name=\"metabelian\",\n            label=\"Metabelian\",\n            knowl=\"group.metabelian\",\n            advanced=True,\n            example_col=True,\n        )\n        cyclic = YesNoBox(\n            name=\"cyclic\",\n            label=\"Cyclic\",\n            knowl=\"group.cyclic\",\n            example_col=True,\n        )\n        metacyclic = YesNoBox(\n            name=\"metacyclic\",\n            label=\"Metacyclic\",\n            knowl=\"group.metacyclic\",\n            advanced=True,\n            example_col=True,\n        )\n        solvable = YesNoBox(\n            name=\"solvable\",\n            label=\"Solvable\",\n            knowl=\"group.solvable\",\n            example_col=True,\n        )\n        supersolvable = YesNoBox(\n            name=\"supersolvable\",\n            label=\"Supersolvable\",\n            knowl=\"group.supersolvable\",\n            advanced=True,\n            example_col=True,\n        )\n        nilpotent = YesNoBox(\n            name=\"nilpotent\",\n            label=\"Nilpotent\",\n            knowl=\"group.nilpotent\",\n            example_col=True,\n        )\n        simple = YesNoBox(\n            name=\"simple\",\n            label=\"Simple\",\n            knowl=\"group.simple\",\n            example_col=True,\n        )\n        almost_simple = YesNoBox(\n            name=\"almost_simple\",\n            label=\"Almost simple\",\n            knowl=\"group.almost_simple\",\n            example_col=True,\n            advanced=True,\n        )\n        quasisimple = YesNoBox(\n            name=\"quasisimple\",\n            label=\"Quasisimple\",\n            knowl=\"group.quasisimple\",\n            advanced=True,\n            example_col=True,\n        )\n        perfect = YesNoBox(\n            name=\"perfect\",\n            label=\"Perfect\",\n            knowl=\"group.perfect\",\n            example_col=True,\n        )\n        direct_product = YesNoBox(\n            name=\"direct_product\",\n            label=\"Direct product\",\n            knowl=\"group.direct_product\",\n            example_col=True,\n        )\n        semidirect_product = YesNoBox(\n            name=\"semidirect_product\",\n            label=\"Semidirect product\",\n            knowl=\"group.semidirect_product\",\n            example_col=True,\n        )\n        permutation_degree = TextBox(\n            name=\"permutation_degree\",\n            label=\"Min. permutation degree\",\n            knowl=\"group.permutation_degree\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n        )\n        transitive_degree = TextBox(\n            name=\"transitive_degree\",\n            label=\"Min. transitive degree\",\n            knowl=\"group.transitive_degree\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n        )\n        irrC_degree = TextBox(\n            name=\"irrC_degree\",\n            label=r\"Min. degree of $\\C$-irrep\",\n            knowl=\"group.min_faithful_linear\",\n            example=\"3\",\n            example_span=\"-1, or a range like 3..5\",\n            advanced=True,\n        )\n        irrQ_degree = TextBox(\n            name=\"irrQ_degree\",\n            label=r\"Min. degree of $\\Q$-irrep\",\n            knowl=\"group.min_faithful_linear\",\n            example=\"3\",\n            example_span=\"-1, or a range like 3..5\",\n            advanced=True,\n        )\n        linC_degree = TextBox(\n            name=\"linC_degree\",\n            label=r\"Min. degree of $\\C$-rep\",\n            knowl=\"group.min_faithful_linear\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n            advanced=True,\n        )\n        linQ_degree = TextBox(\n            name=\"linQ_degree\",\n            label=r\"Min. degree of $\\Q$-rep\",\n            knowl=\"group.min_faithful_linear\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n            advanced=True,\n        )\n        schur_multiplier = TextBox(\n            name=\"schur_multiplier\",\n            label=\"Schur multiplier\",\n            knowl=\"group.schur_multiplier\",\n            example=\"[2,4,12]\",\n            example_span=\"[2,4,12]\",\n            advanced=True,\n        )\n        Agroup = YesNoBox(\n            name=\"Agroup\",\n            label=\"A-group\",\n            knowl=\"group.a_group\",\n            advanced=True,\n            example_col=True,\n        )\n        Zgroup = YesNoBox(\n            name=\"Zgroup\",\n            label=\"Z-group\",\n            knowl=\"group.z_group\",\n            advanced=True,\n            example_col=True,\n        )\n        monomial = YesNoBox(\n            name=\"monomial\",\n            label=\"Monomial\",\n            knowl=\"group.monomial\",\n            advanced=True,\n        )\n        rational = YesNoBox(\n            name=\"rational\",\n            label=\"Rational\",\n            knowl=\"group.rational_group\",\n            advanced=True,\n            example_col=True,\n        )\n        center_label = TextBox(\n            name=\"center_label\",\n            label=\"Center\",\n            knowl=\"group.center_isolabel\",\n            example=\"4.2, 8\",\n            example_span=\"4 or 4.2 (order or label)\",\n        )\n        commutator_label = TextBox(\n            name=\"commutator_label\",\n            label=\"Commutator\",\n            knowl=\"group.commutator_isolabel\",\n            example=\"4.2, 8\",\n            example_span=\"4 or 4.2 (order or label)\",\n        )\n        abelian_quotient = TextBox(\n            name=\"abelian_quotient\",\n            label=\"Abelianization\",\n            knowl=\"group.abelianization_isolabel\",\n            example=\"4.2, 8\",\n            example_span=\"4 or 4.2 (order or label)\",\n        )\n        central_quotient = TextBox(\n            name=\"central_quotient\",\n            label=\"Central quotient\",\n            knowl=\"group.central_quotient_isolabel\",\n            example=\"4.2, 8\",\n            example_span=\"4 or 4.2 (order or label)\",\n        )\n        order_stats = TextBox(\n            name=\"order_stats\",\n            label=\"Order statistics\",\n            knowl=\"group.order_stats\",\n            example=\"1^1, 2^3, 3^2\",\n            example_span=\"1^1, 2^3, 3^2\",\n        )\n        exponents_of_order = TextBox(\n            name=\"exponents_of_order\",\n            label=\"Order factorization\",\n            knowl=\"group.order_factorization\",\n            example=\"[2,1]\",\n            example_span=\"[2,1] or [8]\",\n            advanced=True,\n        )\n        commutator_count = TextBox(\n            name=\"commutator_count\",\n            label=\"Commutator length\",\n            knowl=\"group.commutator_length\",\n            example=\"2-\",\n            example_span=\"1 or 2-4\",\n            advanced=True,\n        )\n        wreath_product = YesNoBox(\n            name=\"wreath_product\",\n            label=\"Wreath product\",\n            knowl=\"group.wreath_product\",\n            advanced=True,\n        )\n        name = SneakyTextBox(\n            name=\"name\",\n            label=\"Name\",\n            knowl=\"group.find_input\",\n            example=\"C16.D4\",\n        )\n        order_factorization_type = SneakySelectBox(\n            name=\"order_factorization_type\",\n            label=\"Order\",\n            knowl=\"group.order_factorization_type\",\n            options=([(\"\", \"\"),\n                      (\"0\", \"1\"),\n                      (\"1\", \"p\"),\n                      (\"2\", \"p^2\"),\n                      (\"3\", \"p^{3-6}\"),\n                      (\"7\", \"p^{7+}\"),\n                      (\"11\", \"squarefree\"),\n                      (\"22\", \"p^2q,p^2q^2\"),\n                      (\"31\", \"p^3q,p^4q\"),\n                      (\"51\", \"p^{5+}q\"),\n                      (\"32\", \"p^{3+}q^2\"),\n                      (\"33\", \"p^{3+}q^{3+}\"),\n                      (\"222\", \"p^{1,2}q^{1,2}r^{1,2}...\"),\n                      (\"311\", \"p^{3+}qr...\"),\n                      (\"321\", \"other\")]),\n        )\n        # Numbers of things boxes\n        number_subgroups = TextBox(\n            name=\"number_subgroups\",\n            label=\"Number of subgroups\",\n            knowl=\"group.subgroup\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n        )\n        number_normal_subgroups = TextBox(\n            name=\"number_normal_subgroups\",\n            label=\"Num. of normal subs\",\n            knowl=\"group.subgroup.normal\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n        )\n        number_conjugacy_classes = TextBox(\n            name=\"number_conjugacy_classes\",\n            label=\"Num. of conj. classes\",\n            knowl=\"group.conjugacy_class\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n        )\n        number_autjugacy_classes = TextBox(\n            name=\"number_autjugacy_classes\",\n            label=\"Num. of aut. classes\",\n            knowl=\"group.autjugacy_class\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n            advanced=True\n        )\n        number_characteristic_subgroups = TextBox(\n            name=\"number_characteristic_subgroups\",\n            label=\"Num. of char. subgroups\",\n            knowl=\"group.characteristic_subgroup\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n            advanced=True\n        )\n        number_divisions = TextBox(\n            name=\"number_divisions\",\n            label=\"Number of divisions\",\n            knowl=\"group.division\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n            advanced=True\n        )\n        family = SelectBox(\n            name=\"family\",\n            options=[(\"\", \"\"), (\"any\", \"any\")] + group_families(deTeX=True),\n            knowl=\"group.families\",\n            label=\"Family\",\n        )\n        hsh = SneakyTextBox(\n            name=\"hash\",\n            label=\"Hash\",\n            knowl=\"group.hash\",\n            example=\"5120#4714647875464396655\",\n        )\n\n        count = CountBox()\n\n        self.browse_array = [\n            [order, exponent],\n            [aut_group, nilpclass],\n            [aut_order, commutator_label],\n            [center_label, abelian_quotient],\n            [central_quotient, frattini_label],\n            [abelian, direct_product],\n            [cyclic, semidirect_product],\n            [nilpotent, perfect],\n            [simple, solvable],\n            [transitive_degree, permutation_degree],\n            [number_subgroups, number_normal_subgroups],\n            [number_conjugacy_classes, number_autjugacy_classes],\n            [order_stats, rank],\n            [irrC_degree, irrQ_degree],\n            [linC_degree, linQ_degree],\n            [almost_simple, derived_length],\n            [quasisimple, supersolvable],\n            [outer_group, metabelian],\n            [outer_order, metacyclic],\n            [Agroup, monomial],\n            [Zgroup, rational],\n            [schur_multiplier, wreath_product],\n            [number_characteristic_subgroups, number_divisions],\n            [exponents_of_order, commutator_count],\n            [count, family],\n        ]\n\n        self.refine_array = [\n            [order, exponent, nilpclass, nilpotent],\n            [center_label, commutator_label, central_quotient, abelian_quotient],\n            [abelian, cyclic, solvable, simple],\n            [perfect, direct_product, semidirect_product, wreath_product],\n            [aut_group, aut_order, transitive_degree, permutation_degree],\n            [number_subgroups, number_normal_subgroups, number_conjugacy_classes],\n            [order_stats, family, exponents_of_order, commutator_count],\n            [irrC_degree, irrQ_degree, linC_degree, linQ_degree],\n            [outer_group, outer_order, metabelian, metacyclic],\n            [almost_simple, quasisimple, Agroup, Zgroup],\n            [frattini_label, derived_length, rank, schur_multiplier],\n            [supersolvable, monomial, rational],\n            [number_characteristic_subgroups, number_autjugacy_classes, number_divisions],\n            [name, order_factorization_type, hsh],\n        ]"
  },
  {
    "type": "class",
    "file": "lmfdb/abvar/fq/test_browse_page.py",
    "name": "AVHomeTest",
    "line_start": 4,
    "line_end": 340,
    "lines": 337,
    "bytes": 15766,
    "has_71": true,
    "code": "class AVHomeTest(LmfdbTest):\n    # All tests should pass\n    # TODO test link to random isogeny class\n\n    # The pages themselves\n    def test_index_page(self):\n        r\"\"\"\n        Check that the Variety/Abelian/Fq index page works\n        \"\"\"\n        homepage = self.tc.get(\"/Variety/Abelian/Fq/\").get_data(as_text=True)\n        assert \"by dimension and base field\" in homepage\n        assert \"Cyclic group of points\" in homepage\n\n    def test_stats_page(self):\n        self.check_args(\"/Variety/Abelian/Fq/stats\", \"Abelian variety isogeny classes: Statistics\")\n\n    # TODO test dynamic stats\n\n    def test_completeness_page(self):\n        r\"\"\"\n        Check that Variety/Abelian/Fq/Completeness works\n        \"\"\"\n        page = self.tc.get(\"/Variety/Abelian/Fq/Completeness\").get_data(as_text=True)\n        assert \"the collection of isogeny classes is complete\" in page\n\n    def test_further_completeness_page(self):\n        r\"\"\"\n        Check that Variety/Abelian/Fq/Source works\n        \"\"\"\n        page = self.tc.get(\"/Variety/Abelian/Fq/Source\").get_data(as_text=True)\n        assert \"characteristic polynomial\" in page\n\n    def test_labels_page(self):\n        r\"\"\"\n        Check that Variety/Abelian/Fq/Labels works\n        \"\"\"\n        page = self.tc.get(\"/Variety/Abelian/Fq/Labels\").get_data(as_text=True)\n        assert \"label format\" in page\n\n    def test_lookup(self):\n        r\"\"\"\n        Check that Variety/Abelian/Fq/?jump works\n        \"\"\"\n        self.check_args(\n            \"/Variety/Abelian/Fq/?jump=x^6-3*x^5%2B3*x^4-2*x^3%2B6*x^2-12*x%2B8\",\n            \"3.2.ad_d_ac\"\n        )\n\n    # Various searches\n    # Many things are checked twice: Once from main index/browse page, and once from the refining search page\n\n    def test_bad_label(self):\n        r\"\"\"\n        Check the error message for a bad label url\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/2/9/ak_bl\", \"is not in the database\")\n\n    def test_count_table(self):\n        r\"\"\"\n        Check that the count table works\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/?search_type=Counts\", \"132839\")\n        self.check_args(\"/Variety/Abelian/Fq/?search_type=Counts&simple=yes\", \"106706\")\n        self.check_args(\"/Variety/Abelian/Fq/?search_type=Counts&q=32-100&g=2-4\", \"6409\")\n        self.check_args(\"/Variety/Abelian/Fq/?search_type=Counts&q=4..7&g=2..4\", \"2953\")\n        self.check_args(\"/Variety/Abelian/Fq/?search_type=Counts&q=2-27&g=1%2C3%2C5\", \"30543\")\n        # check that the links are functional\n        self.check_args(\"/Variety/Abelian/Fq/?search_type=Counts\", \"/Variety/Abelian/Fq/?g=5&amp;q=3\")\n        # and that it deals with invalid input\n        self.check_args(\"/Variety/Abelian/Fq/?search_type=Counts&q=2-27&g=x\", \"not a valid input\")\n\n    def test_search_dimension(self):\n        r\"\"\"\n        Check that we can search by dimension\n        \"\"\"\n        # check that 2.2.a_a and  2.3.ac_g show up in the first 50 results\n        self.check_args(\"/Variety/Abelian/Fq/?g=2\", \"2.2.a_a\")\n        self.check_args(\"/Variety/Abelian/Fq/?g=2\", \"2.3.ac_g\")\n        # this last one is url only\n        self.check_args(\"/Variety/Abelian/Fq/2/\", \"2.3.ac_e\")\n\n    def test_search_basefield(self):\n        r\"\"\"\n        Check that we can search by base field\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/?q=121\", \"1.121.al\")\n\n    def test_simple_search(self):\n        r\"\"\"\n        Check that we can restrict to simple or non-simple abelian varieties only\n        \"\"\"\n        # search for simple\n        self.check_args(\"/Variety/Abelian/Fq/?q=2&g=2&simple=yes\", \"2.2.ad_f\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?q=2&g=2&simple=yes\", \"2.2.ae_i\")\n        # search for not simple\n        self.check_args(\"/Variety/Abelian/Fq/?q=2&g=2&simple=no\", \"2.2.ae_i\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?q=2&g=2&simple=no\", \"2.2.ad_f\")\n\n    def test_geom_decomp_search(self):\n        r\"\"\"\n        Check that we can restrict to (geometrically) (non) squarefree\n        abelian varieties only.\n        \"\"\"\n        # search for squarefree\n        self.check_args(\"/Variety/Abelian/Fq/?geom_squarefree=Yes\", \"1.3.ab\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?geom_squarefree=Yes\", \"2.2.ae_i\")\n\n        # search for squarefree and geometrically squarefree\n        self.check_args(\"/Variety/Abelian/Fq/?geom_squarefree=YesAndGeom\", \"1.2.ac\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?geom_squarefree=YesAndGeom\", \"2.2.ad_f\")\n\n        # search for squarefree but not geometrically squarefree\n        self.check_args(\"/Variety/Abelian/Fq/?geom_squarefree=YesNotGeom\", \"2.2.ad_f\")\n\n        # search for non squarefree\n        self.check_args(\"/Variety/Abelian/Fq/?geom_squarefree=No\", \"2.2.ae_i\")\n        self.check_args(\"/Variety/Abelian/Fq/?geom_squarefree=No&g=1\", \"No matches\")\n\n        # search for not geometrically squarefree\n        self.check_args(\"/Variety/Abelian/Fq/?geom_squarefree=NotGeom\", \"2.2.ae_i\")\n\n    def test_primitive_search(self):\n        r\"\"\"\n        Check that we can restrict to primitive or non-primitive abelian varieties only\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/?q=4&primitive=no&g=2\", \"2.4.ad_f\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=4&primitive=yes&g=2\", \"2.4.af_o\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?q=4&primitive=yes&g=2\", \"2.4.ad_f\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?q=4&primitive=no&g=2\", \"2.4.ae_j\")\n\n    def test_search_prank(self):\n        r\"\"\"\n        Check that we can search by p-rank\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/?q=9&g=2&p_rank=2\", \"2.9.ah_ba\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=9&g=2&p_rank=2\", \"2.9.af_o\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?q=9&g=2&p_rank=2\", \"2.9.b_ad\")\n\n    def test_search_newton(self):\n        r\"\"\"\n        Check that we can search by newton polygon\n        \"\"\"\n        # [0,1] from browse page\n        self.check_args(\"/Variety/Abelian/Fq/?newton_polygon=%5B0%2C1%5D\", \"1.2.ab\")\n        # 1/3 from browse page, doesn't currently work\n        self.check_args(\"/Variety/Abelian/Fq/?newton_polygon=1%2F3\", \"You cannot specify slopes on their own\")\n        # 1/5 from refine search, doesn't currently work\n        self.check_args(\"/Variety/Abelian/Fq/?newton_polygon=1%2F5\", \"You cannot specify slopes on their own\")\n        # slope not a rational number\n        self.check_args(\"/Variety/Abelian/Fq/?newton_polygon=t\", \"is not a valid input\")\n        # slopes are not increasing\n        self.check_args(\n            \"/Variety/Abelian/Fq/?start=&count=&newton_polygon=%5B1%2C1%2F2%2C0%5D\",\n            \"Slopes must be increasing\"\n        )\n\n    def test_search_initcoeffs(self):\n        r\"\"\"\n        Check that we can search by initial coefficients of the polynomial\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/?initial_coefficients=%5B1%2C-1%2C3%2C9%5D\", \"4.3.b_ab_d_j\")\n        self.check_args(\"/Variety/Abelian/Fq/?initial_coefficients=%5B1%2C-1%2C3%2C9%5D\", \"4.3.b_ab_d_j\")\n        # there should be only one match, if ranges were supported\n        self.check_args(\n            \"/Variety/Abelian/Fq/?angle_ranks=&initial_coefficients=%5B3%2C+9%2C+10%2C+87-100%5D\",\n            \"Ranges not supported\"\n        )\n\n    def test_search_pointcountsav(self):\n        r\"\"\"\n        Check that we can search by the point counts of the abelian variety\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/?abvar_point_count=%5B75%2C7125%5D\", \"2.9.ab_d\")\n        self.check_args(\"/Variety/Abelian/Fq/?abvar_point_count=%5B75%2C7125%5D\", \"2.9.ab_d\")\n\n    def test_search_pointcountscurve(self):\n        r\"\"\"\n        Check that we can search by the point counts of the curve\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/?curve_point_count=%5B9%2C87%5D\", \"3.9.ab_d_abs\")\n        self.check_args(\"/Variety/Abelian/Fq/?curve_point_count=%5B9%2C87%5D\", \"3.9.ab_d_abs\")\n\n    def test_search_anglerank(self):\n        r\"\"\"\n        Check that we can search by angle rank\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/?q=3&g=4&angle_rank=2\", \"4.3.ag_p_au_y\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=3&g=4&angle_rank=2\", \"4.3.ag_p_au_y\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?q=3&g=4&angle_rank=2\", \"4.3.am_co_aii_rr\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?q=3&g=4&angle_rank=2\", \"4.3.am_co_aii_rr\")\n\n    def test_search_isogfactor(self):\n        r\"\"\"\n        Check that we can search by decomposition into isogeny factors\n        \"\"\"\n        # [3.5.ah_y_ach,*]\n        self.check_args(\n            \"/Variety/Abelian/Fq/?simple_quantifier=include&simple_factors=3.5.ah_y_ach\",\n            \"4.5.ak_by_agk_qb\"\n        )\n        self.check_args(\n            \"/Variety/Abelian/Fq/?p_rank=4&dim1_factors=2&dim2_factors=2&dim1_distinct=1&dim2_distinct=1\",\n            \"6.2.ag_p_aw_bh_acu_ey\"\n        )\n        self.check_args(\"/Variety/Abelian/Fq/?dim1_factors=6&dim1_distinct=1\", \"5 matches\")\n\n    def test_search_numberfield(self):\n        r\"\"\"\n        Check that we can search by number field\n        \"\"\"\n        # 4.0.9726525.1\n        self.check_args(\"/Variety/Abelian/Fq/?number_field=4.0.9726525.1\", \"2.193.ax_tn\")\n        self.check_args(\"/Variety/Abelian/Fq/?number_field=4.0.9726525.1\", \"2.193.ax_tn\")\n\n    def test_search_jacobian(self):\n        r\"\"\"\n        Check that we can restrict to Jacobians or non Jacobians\n        \"\"\"\n        # Jacobians only\n        self.check_args(\"/Variety/Abelian/Fq/?q=3&g=2&jacobian=yes\", \"2.3.ae_i\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=3&g=2&jacobian=yes\", \"2.3.ae_i\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?q=3&g=2&jacobian=yes\", \"2.3.a_af\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?q=3&g=2&jacobian=yes\", \"2.3.a_af\")\n        # non Jacobians only\n        self.check_args(\"/Variety/Abelian/Fq/?q=3&g=2&jacobian=no\", \"2.3.a_af\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=3&g=2&jacobian=no\", \"2.3.a_af\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?q=3&g=2&jacobian=no\", \"2.3.ae_i\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?q=3&g=2&jacobian=no\", \"2.3.ae_i\")\n        # unknowns\n        self.check_args(\"/Variety/Abelian/Fq/?g=4&p_rank=4&jacobian=not_yes&polarizable=yes\", \"4.2.ag_t_abq_cr\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=2&g=3&p_rank=0&jacobian=not_no\", \"3.2.c_c_c\")\n\n    def test_search_princpol(self):\n        r\"\"\"\n        Check that we can restrict to principally polarizable or not principally polarizable\n        \"\"\"\n        # princ polarizable only\n        self.check_args(\"/Variety/Abelian/Fq/?q=5&g=2&polarizable=yes\", \"2.5.ab_f\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=5&g=2&polarizable=yes\", \"2.5.ab_f\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?q=5&g=2&polarizable=yes\", \"2.5.ac_ab\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?q=5&g=2&polarizable=yes\", \"2.5.ac_ab\")\n        # not princ polarizable only\n        self.check_args(\"/Variety/Abelian/Fq/?q=5&g=2&polarizable=no\", \"2.5.ac_ab\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=5&g=2&polarizable=no\", \"2.5.ac_ab\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?q=5&g=2&polarizable=no\", \"2.5.ab_f\")\n        self.not_check_args(\"/Variety/Abelian/Fq/?q=5&g=2&polarizable=no\", \"2.5.ab_f\")\n        # unknowns\n        self.check_args(\"/Variety/Abelian/Fq/?q=17&g=2&jacobian=no&polarizable=not_yes\", \"2.17.ae_ab\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=17&g=2&jacobian=no&polarizable=not_no\", \"2.17.aj_cc\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=3&g=3&jacobian=no&polarizable=not_no\", \"3.3.ag_v_abs\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=2&g=3&p_rank=0&jacobian=not_no&polarizable=not_no\", \"3.2.c_e_g\")\n\n    def test_search_galois(self):\n        self.check_args(\"/Variety/Abelian/Fq/?galois_group=4T3\", \"2.4.ab_f\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=9&galois_group=4T3\", \"2.9.af_u\")\n        self.check_args(\"/Variety/Abelian/Fq/?galois_group=8T12\", \"4.2.b_b_e_f\")\n        self.check_args(\"/Variety/Abelian/Fq/?p_rank=0&galois_group=C4\", \"2.64.i_cm\")\n\n    def test_search_maxnumdisplay(self):\n        r\"\"\"\n        Check that we can restrict how many classes get displayed\n        \"\"\"\n        self.check_args(\"/Variety/Abelian/Fq/?q=5&g=2&count=19\", \"19\")\n\n    def test_search_combos(self):\n        r\"\"\"\n        Check that various search combinations work.\n        \"\"\"\n        # dimension and base field, last one is from the table\n        self.check_args(\"/Variety/Abelian/Fq/?q=7&g=1\", \"1.7.f\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=7&g=1\", \"1.7.f\")\n        self.check_args(\"/Variety/Abelian/Fq/1/7/\", \"1.7.af\")\n        # dimension, base field and p-rank\n        self.check_args(\"/Variety/Abelian/Fq/?q=9&g=2&p_rank=2\", \"2.9.ad_b\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=9&g=2&p_rank=2\", \"2.9.af_o\")\n        # dimension, base field and initial coefficients\n        self.check_args(\"/Variety/Abelian/Fq/?q=25&g=2&initial_coefficients=%5B1%2C-13%5D\", \"2.25.b_an\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=25&g=2&initial_coefficients=%5B1%2C-13%5D\", \"2.25.b_an\")\n        # dimension, base field and point counts of the abelian variety\n        self.check_args(\"/Variety/Abelian/Fq/?q=25&g=2&abvar_point_count=%5B373%2C391277%5D\", \"2.25.an_dh\")\n        self.check_args(\"/Variety/Abelian/Fq/?q=25&g=2&abvar_point_count=%5B373%2C391277%5D\", \"2.25.an_dh\")\n        # dimension, base field and point counts of the curve\n        self.check_args(\"/Variety/Abelian/Fq/?q=3&g=4&curve_point_count=%5B0%2C4%2C15%5D\", \"4.3.ae_f_ad_e\")\n        # dimension, base field and maximum number to display\n        self.check_args(\"/Variety/Abelian/Fq/?q=25&g=2&count=100\", \"2.25.an_do\")\n        # p-rank and initial coefficients\n        self.check_args(\"/Variety/Abelian/Fq/?p_rank=2&initial_coefficients=%5B1%2C-1%2C3%2C9%5D\", \"4.3.b_ab_d_j\")\n        self.check_args(\"/Variety/Abelian/Fq/?p_rank=2&initial_coefficients=%5B1%2C-1%2C3%2C9%5D\", \"4.3.b_ab_d_j\")\n        # initial coefficients and point counts of the abelian variety\n        self.check_args(\n            \"/Variety/Abelian/Fq/?initial_coefficients=%5B1%2C-1%2C3%2C9%5D&abvar_point_count=%5B75%2C7125%5D\",\n            \"No matches\"\n        )\n        self.check_args(\n            \"/Variety/Abelian/Fq/?initial_coefficients=%5B1%2C-1%2C3%2C9%5D&abvar_point_count=%5B75%2C7125%5D\",\n            \"No matches\"\n        )\n        # Combining unknown fields on Jacobian and Principal polarization.\n        self.check_args(\"/Variety/Abelian/Fq/?g=3&jacobian=no&polarizable=not_no\", \"3.2.a_a_ae\")\n        self.check_args(\"/Variety/Abelian/Fq/?g=3&jacobian=no&polarizable=yes\", \"3.2.a_ac_a\")\n\n    def test_search_cyclic_group(self):\n        r\"\"\"\n        Check that we can restrict to cyclic or non-cyclic groups of points\n        using the cyclic search parameter.\n        \"\"\"\n        # 1.2.ac has cyclic group of points (is_cyclic = True)\n        self.check_args(\n            \"/Variety/Abelian/Fq/?cyclic=yes\",\n            \">1.2.ac<\",\n        )\n\n        # 1.3.a has non-cyclic group of points (is_cyclic = False)\n        self.check_args(\n            \"/Variety/Abelian/Fq/?cyclic=no\",\n            \">1.3.a<\",\n        )\n\n        # And make sure they do not appear in the wrong list\n        self.not_check_args(\n            \"/Variety/Abelian/Fq/?cyclic=yes\",\n            \">1.3.a<\",\n        )\n        self.not_check_args(\n            \"/Variety/Abelian/Fq/?cyclic=no\",\n            \">1.2.ac<\",\n        )\n\n    def test_search_noncyclic_primes(self):\n        r\"\"\"\n        Check that the noncyclic_primes search parameter is accepted and\n        finds classes that are non-cyclic at p = 2.\n        \"\"\"\n        self.check_args(\n            \"/Variety/Abelian/Fq/?noncyclic_primes=2\",\n            \">1.3.a<\",\n        )"
  },
  {
    "type": "class",
    "file": "lmfdb/groups/abstract/main.py",
    "name": "GroupsSearchArray",
    "line_start": 2569,
    "line_end": 3027,
    "lines": 459,
    "bytes": 16598,
    "has_71": true,
    "code": "class GroupsSearchArray(SearchArray):\n    noun = \"group\"\n    sorts = [\n            (\"\", \"order\", [\"order\", \"counter\"]),\n            (\"exponent\", \"exponent\", [\"exponent\", \"order\", \"counter\"]),\n            (\"nilpotency_class\", \"nilpotency class\", [\"nilpotency_class\", \"order\", \"counter\"]),\n            (\"derived_length\", \"derived length\", [\"derived_length\", \"order\", \"counter\"]),\n            (\"composition_length\", \"composition length\", [\"composition_length\", \"order\", \"counter\"]),\n            (\"rank\", \"rank\", [\"rank\", \"eulerian_function\", \"order\", \"counter\"]),\n            #(\"center_label\", \"center\", [\"center_label\", \"order\", \"counter\"]),\n            #(\"commutator_label\", \"commutator\", [\"commutator_label\", \"order\", \"counter\"]),\n            #(\"central_quotient\", \"central quotient\", [\"central_quotient\", \"order\", \"counter\"]),\n            #(\"abelian_quotient\", \"abelianization\", [\"abelian_quotient\", \"order\", \"counter\"]),\n            (\"aut_order\", \"automorphisms\", [\"aut_order\", \"aut_group\", \"order\", \"counter\"]),\n            (\"number_subgroups\", \"subgroups\", [\"number_subgroups\", \"order\", \"counter\"]),\n            (\"number_subgroup_classes\", \"subgroup classes\", [\"number_subgroup_classes\", \"order\", \"counter\"]),\n            (\"number_normal_subgroups\", \"normal subgroups\", [\"number_normal_subgroups\", \"order\", \"counter\"]),\n            (\"number_conjugacy_classes\", \"conjugacy classes\", [\"number_conjugacy_classes\", \"order\", \"counter\"]),\n            (\"number_autjugacy_classes\", \"autjugacy classes\", [\"number_autjugacy_classes\", \"order\", \"counter\"]),\n            (\"number_divisions\", \"divisions\", [\"number_divisions\", \"order\", \"counter\"]),\n            (\"transitive_degree\", \"transitive degree\", [\"transitive_degree\", \"counter\"]),\n            (\"permutation_degree\", \"permutation degree\", [\"permutation_degree\", \"counter\"]),\n            (\"irrC_degree\", r\"$\\C$-irrep degree\", [\"irrC_degree\", \"counter\"]),\n            (\"irrQ_degree\", r\"$\\Q$-irrep degree\", [\"irrQ_degree\", \"counter\"])\n    ]\n    jump_example = \"8.3\"\n    jump_egspan = \"e.g. 8.3, GL(2,3), 8T34, C3:C4, C2*A5, C16.D4, 6#1, or 12.4.2.b1.a1\"\n    jump_prompt = \"Label or name\"\n    jump_knowl = \"group.find_input\"\n\n    def __init__(self):\n        order = TextBox(\n            name=\"order\",\n            label=\"Order\",\n            knowl=\"group.order\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n        )\n        exponent = TextBox(\n            name=\"exponent\",\n            label=\"Exponent\",\n            knowl=\"group.exponent\",\n            example=\"2, 3, 7\",\n            example_span=\"2, or list of integers like 2, 3, 7\",\n        )\n        nilpclass = TextBox(\n            name=\"nilpotency_class\",\n            label=\"Nilpotency class\",\n            knowl=\"group.nilpotent\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n        )\n        aut_group = TextBox(\n            name=\"aut_group\",\n            label=\"Automorphism group\",\n            knowl=\"group.automorphism\",\n            example=\"4.2\",\n            example_span=\"4.2\",\n        )\n        aut_order = TextBox(\n            name=\"aut_order\",\n            label=\"Automorphism group order\",\n            short_label=\"Automorphisms\",\n            knowl=\"group.automorphism\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n        )\n        derived_length = TextBox(\n            name=\"derived_length\",\n            label=\"Derived length\",\n            knowl=\"group.derived_series\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n            advanced=True,\n        )\n        frattini_label = TextBox(\n            name=\"frattini_label\",\n            label=\"Frattini subgroup\",\n            knowl=\"group.frattini_subgroup\",\n            example=\"4.2\",\n            example_span=\"4.2\",\n            advanced=True,\n        )\n        outer_group = TextBox(\n            name=\"outer_group\",\n            label=\"Outer aut. group\",\n            knowl=\"group.outer_aut\",\n            example=\"4.2\",\n            example_span=\"4.2\",\n            advanced=True,\n        )\n        outer_order = TextBox(\n            name=\"outer_order\",\n            label=\"Outer aut. group order\",\n            short_label=\"Outer automorphisms\",\n            knowl=\"group.outer_aut\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n            advanced=True,\n        )\n        rank = TextBox(\n            name=\"rank\",\n            label=\"Rank\",\n            knowl=\"group.rank\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n            advanced=True,\n        )\n        abelian = YesNoBox(\n            name=\"abelian\", label=\"Abelian\", knowl=\"group.abelian\", example_col=True\n        )\n        metabelian = YesNoBox(\n            name=\"metabelian\",\n            label=\"Metabelian\",\n            knowl=\"group.metabelian\",\n            advanced=True,\n            example_col=True,\n        )\n        cyclic = YesNoBox(\n            name=\"cyclic\",\n            label=\"Cyclic\",\n            knowl=\"group.cyclic\",\n            example_col=True,\n        )\n        metacyclic = YesNoBox(\n            name=\"metacyclic\",\n            label=\"Metacyclic\",\n            knowl=\"group.metacyclic\",\n            advanced=True,\n            example_col=True,\n        )\n        solvable = YesNoBox(\n            name=\"solvable\",\n            label=\"Solvable\",\n            knowl=\"group.solvable\",\n            example_col=True,\n        )\n        supersolvable = YesNoBox(\n            name=\"supersolvable\",\n            label=\"Supersolvable\",\n            knowl=\"group.supersolvable\",\n            advanced=True,\n            example_col=True,\n        )\n        nilpotent = YesNoBox(\n            name=\"nilpotent\",\n            label=\"Nilpotent\",\n            knowl=\"group.nilpotent\",\n            example_col=True,\n        )\n        simple = YesNoBox(\n            name=\"simple\",\n            label=\"Simple\",\n            knowl=\"group.simple\",\n            example_col=True,\n        )\n        almost_simple = YesNoBox(\n            name=\"almost_simple\",\n            label=\"Almost simple\",\n            knowl=\"group.almost_simple\",\n            example_col=True,\n            advanced=True,\n        )\n        quasisimple = YesNoBox(\n            name=\"quasisimple\",\n            label=\"Quasisimple\",\n            knowl=\"group.quasisimple\",\n            advanced=True,\n            example_col=True,\n        )\n        perfect = YesNoBox(\n            name=\"perfect\",\n            label=\"Perfect\",\n            knowl=\"group.perfect\",\n            example_col=True,\n        )\n        direct_product = YesNoBox(\n            name=\"direct_product\",\n            label=\"Direct product\",\n            knowl=\"group.direct_product\",\n            example_col=True,\n        )\n        semidirect_product = YesNoBox(\n            name=\"semidirect_product\",\n            label=\"Semidirect product\",\n            knowl=\"group.semidirect_product\",\n            example_col=True,\n        )\n        permutation_degree = TextBox(\n            name=\"permutation_degree\",\n            label=\"Min. permutation degree\",\n            knowl=\"group.permutation_degree\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n        )\n        transitive_degree = TextBox(\n            name=\"transitive_degree\",\n            label=\"Min. transitive degree\",\n            knowl=\"group.transitive_degree\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n        )\n        irrC_degree = TextBox(\n            name=\"irrC_degree\",\n            label=r\"Min. degree of $\\C$-irrep\",\n            knowl=\"group.min_faithful_linear\",\n            example=\"3\",\n            example_span=\"-1, or a range like 3..5\",\n            advanced=True,\n        )\n        irrQ_degree = TextBox(\n            name=\"irrQ_degree\",\n            label=r\"Min. degree of $\\Q$-irrep\",\n            knowl=\"group.min_faithful_linear\",\n            example=\"3\",\n            example_span=\"-1, or a range like 3..5\",\n            advanced=True,\n        )\n        linC_degree = TextBox(\n            name=\"linC_degree\",\n            label=r\"Min. degree of $\\C$-rep\",\n            knowl=\"group.min_faithful_linear\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n            advanced=True,\n        )\n        linQ_degree = TextBox(\n            name=\"linQ_degree\",\n            label=r\"Min. degree of $\\Q$-rep\",\n            knowl=\"group.min_faithful_linear\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n            advanced=True,\n        )\n        schur_multiplier = TextBox(\n            name=\"schur_multiplier\",\n            label=\"Schur multiplier\",\n            knowl=\"group.schur_multiplier\",\n            example=\"[2,4,12]\",\n            example_span=\"[2,4,12]\",\n            advanced=True,\n        )\n        Agroup = YesNoBox(\n            name=\"Agroup\",\n            label=\"A-group\",\n            knowl=\"group.a_group\",\n            advanced=True,\n            example_col=True,\n        )\n        Zgroup = YesNoBox(\n            name=\"Zgroup\",\n            label=\"Z-group\",\n            knowl=\"group.z_group\",\n            advanced=True,\n            example_col=True,\n        )\n        monomial = YesNoBox(\n            name=\"monomial\",\n            label=\"Monomial\",\n            knowl=\"group.monomial\",\n            advanced=True,\n        )\n        rational = YesNoBox(\n            name=\"rational\",\n            label=\"Rational\",\n            knowl=\"group.rational_group\",\n            advanced=True,\n            example_col=True,\n        )\n        center_label = TextBox(\n            name=\"center_label\",\n            label=\"Center\",\n            knowl=\"group.center_isolabel\",\n            example=\"4.2, 8\",\n            example_span=\"4 or 4.2 (order or label)\",\n        )\n        commutator_label = TextBox(\n            name=\"commutator_label\",\n            label=\"Commutator\",\n            knowl=\"group.commutator_isolabel\",\n            example=\"4.2, 8\",\n            example_span=\"4 or 4.2 (order or label)\",\n        )\n        abelian_quotient = TextBox(\n            name=\"abelian_quotient\",\n            label=\"Abelianization\",\n            knowl=\"group.abelianization_isolabel\",\n            example=\"4.2, 8\",\n            example_span=\"4 or 4.2 (order or label)\",\n        )\n        central_quotient = TextBox(\n            name=\"central_quotient\",\n            label=\"Central quotient\",\n            knowl=\"group.central_quotient_isolabel\",\n            example=\"4.2, 8\",\n            example_span=\"4 or 4.2 (order or label)\",\n        )\n        order_stats = TextBox(\n            name=\"order_stats\",\n            label=\"Order statistics\",\n            knowl=\"group.order_stats\",\n            example=\"1^1, 2^3, 3^2\",\n            example_span=\"1^1, 2^3, 3^2\",\n        )\n        exponents_of_order = TextBox(\n            name=\"exponents_of_order\",\n            label=\"Order factorization\",\n            knowl=\"group.order_factorization\",\n            example=\"[2,1]\",\n            example_span=\"[2,1] or [8]\",\n            advanced=True,\n        )\n        commutator_count = TextBox(\n            name=\"commutator_count\",\n            label=\"Commutator length\",\n            knowl=\"group.commutator_length\",\n            example=\"2-\",\n            example_span=\"1 or 2-4\",\n            advanced=True,\n        )\n        wreath_product = YesNoBox(\n            name=\"wreath_product\",\n            label=\"Wreath product\",\n            knowl=\"group.wreath_product\",\n            advanced=True,\n        )\n        name = SneakyTextBox(\n            name=\"name\",\n            label=\"Name\",\n            knowl=\"group.find_input\",\n            example=\"C16.D4\",\n        )\n        order_factorization_type = SneakySelectBox(\n            name=\"order_factorization_type\",\n            label=\"Order\",\n            knowl=\"group.order_factorization_type\",\n            options=([(\"\", \"\"),\n                      (\"0\", \"1\"),\n                      (\"1\", \"p\"),\n                      (\"2\", \"p^2\"),\n                      (\"3\", \"p^{3-6}\"),\n                      (\"7\", \"p^{7+}\"),\n                      (\"11\", \"squarefree\"),\n                      (\"22\", \"p^2q,p^2q^2\"),\n                      (\"31\", \"p^3q,p^4q\"),\n                      (\"51\", \"p^{5+}q\"),\n                      (\"32\", \"p^{3+}q^2\"),\n                      (\"33\", \"p^{3+}q^{3+}\"),\n                      (\"222\", \"p^{1,2}q^{1,2}r^{1,2}...\"),\n                      (\"311\", \"p^{3+}qr...\"),\n                      (\"321\", \"other\")]),\n        )\n        # Numbers of things boxes\n        number_subgroups = TextBox(\n            name=\"number_subgroups\",\n            label=\"Number of subgroups\",\n            knowl=\"group.subgroup\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n        )\n        number_normal_subgroups = TextBox(\n            name=\"number_normal_subgroups\",\n            label=\"Num. of normal subs\",\n            knowl=\"group.subgroup.normal\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n        )\n        number_conjugacy_classes = TextBox(\n            name=\"number_conjugacy_classes\",\n            label=\"Num. of conj. classes\",\n            knowl=\"group.conjugacy_class\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n        )\n        number_autjugacy_classes = TextBox(\n            name=\"number_autjugacy_classes\",\n            label=\"Num. of aut. classes\",\n            knowl=\"group.autjugacy_class\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n            advanced=True\n        )\n        number_characteristic_subgroups = TextBox(\n            name=\"number_characteristic_subgroups\",\n            label=\"Num. of char. subgroups\",\n            knowl=\"group.characteristic_subgroup\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n            advanced=True\n        )\n        number_divisions = TextBox(\n            name=\"number_divisions\",\n            label=\"Number of divisions\",\n            knowl=\"group.division\",\n            example=\"3\",\n            example_span=\"4, or a range like 3..5\",\n            advanced=True\n        )\n        family = SelectBox(\n            name=\"family\",\n            options=[(\"\", \"\"), (\"any\", \"any\")] + group_families(deTeX=True),\n            knowl=\"group.families\",\n            label=\"Family\",\n        )\n        hsh = SneakyTextBox(\n            name=\"hash\",\n            label=\"Hash\",\n            knowl=\"group.hash\",\n            example=\"5120#4714647875464396655\",\n        )\n\n        count = CountBox()\n\n        self.browse_array = [\n            [order, exponent],\n            [aut_group, nilpclass],\n            [aut_order, commutator_label],\n            [center_label, abelian_quotient],\n            [central_quotient, frattini_label],\n            [abelian, direct_product],\n            [cyclic, semidirect_product],\n            [nilpotent, perfect],\n            [simple, solvable],\n            [transitive_degree, permutation_degree],\n            [number_subgroups, number_normal_subgroups],\n            [number_conjugacy_classes, number_autjugacy_classes],\n            [order_stats, rank],\n            [irrC_degree, irrQ_degree],\n            [linC_degree, linQ_degree],\n            [almost_simple, derived_length],\n            [quasisimple, supersolvable],\n            [outer_group, metabelian],\n            [outer_order, metacyclic],\n            [Agroup, monomial],\n            [Zgroup, rational],\n            [schur_multiplier, wreath_product],\n            [number_characteristic_subgroups, number_divisions],\n            [exponents_of_order, commutator_count],\n            [count, family],\n        ]\n\n        self.refine_array = [\n            [order, exponent, nilpclass, nilpotent],\n            [center_label, commutator_label, central_quotient, abelian_quotient],\n            [abelian, cyclic, solvable, simple],\n            [perfect, direct_product, semidirect_product, wreath_product],\n            [aut_group, aut_order, transitive_degree, permutation_degree],\n            [number_subgroups, number_normal_subgroups, number_conjugacy_classes],\n            [order_stats, family, exponents_of_order, commutator_count],\n            [irrC_degree, irrQ_degree, linC_degree, linQ_degree],\n            [outer_group, outer_order, metabelian, metacyclic],\n            [almost_simple, quasisimple, Agroup, Zgroup],\n            [frattini_label, derived_length, rank, schur_multiplier],\n            [supersolvable, monomial, rational],\n            [number_characteristic_subgroups, number_autjugacy_classes, number_divisions],\n            [name, order_factorization_type, hsh],\n        ]\n\n    sort_knowl = \"group.sort_order\""
  },
  {
    "type": "class",
    "file": "lmfdb/genus2_curves/test_genus2_curves.py",
    "name": "Genus2Test",
    "line_start": 4,
    "line_end": 394,
    "lines": 391,
    "bytes": 17472,
    "has_71": true,
    "code": "class Genus2Test(LmfdbTest):\n\n    # All tests should pass\n    def test_stats(self):\n        L = self.tc.get(\"/Genus2Curve/Q/stats\")\n        assert \"Sato-Tate groups\" in L.get_data(\n            as_text=True\n        ) and \"proportion\" in L.get_data(as_text=True)\n\n    def test_cond_range(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?cond=100000-1000000\")\n        assert \"100000.a.200000.1\" in L.get_data(as_text=True)\n\n    def test_disc_range(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?abs_disc=100000-1000000\")\n        assert \"336.a.172032.1\" in L.get_data(as_text=True)\n\n    def test_by_curve_label(self):\n        L = self.tc.get(\"/Genus2Curve/Q/169.a.169.1\", follow_redirects=True)\n        assert \"square of\" in L.get_data(as_text=True) and \"E_6\" in L.get_data(\n            as_text=True\n        )\n        L = self.tc.get(\"/Genus2Curve/Q/1152.a.147456.1\", follow_redirects=True)\n        assert (\n            \"non-isogenous elliptic curve\" in L.get_data(as_text=True)\n            and \"24.a\" in L.get_data(as_text=True)\n            and \"48.a\" in L.get_data(as_text=True)\n        )\n        L = self.tc.get(\"/Genus2Curve/Q/15360.f.983040.2\", follow_redirects=True)\n        assert (\n            r\"N(\\mathrm{U}(1)\\times\\mathrm{SU}(2))\" in L.get_data(as_text=True)\n            and \"480.b\" in L.get_data(as_text=True)\n            and \"32.a\" in L.get_data(as_text=True)\n        )\n\n    def test_isogeny_class_label(self):\n        L = self.tc.get(\"/Genus2Curve/Q/1369/a/\")\n        assert (\n            \"1369.1\" in L.get_data(as_text=True)\n            and \"50653.1\" in L.get_data(as_text=True)\n            and r\"\\mathrm{SU}(2)\\times\\mathrm{SU}(2)\" in L.get_data(as_text=True)\n        )\n\n    def test_Lfunction_link(self):\n        L = self.tc.get(\"/L/Genus2Curve/Q/1369/a\", follow_redirects=True)\n        assert \"Motivic weight\" in L.get_data(as_text=True)\n\n    def test_twist_link(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?g22=1016576&g20=5071050752/9&g21=195344320/9\")\n        for label in [\n            \"576.b.147456.1\",\n            \"1152.a.147456.1\",\n            \"2304.b.147456.1\",\n            \"4608.a.4608.1\",\n            \"4608.b.4608.1\",\n        ]:\n            assert label in L.get_data(as_text=True)\n\n    def test_by_conductor(self):\n        L = self.tc.get(\"/Genus2Curve/Q/15360/\")\n        for x in \"abcdefghij\":\n            assert \"15360.\" + x in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/15360/?abs_disc=169\")\n        assert \"No matches\" in L.get_data(as_text=True)\n\n    def test_by_url_isogeny_class_label(self):\n        L = self.tc.get(\"/Genus2Curve/Q/336/a/\")\n        assert \"336.a.172032.1\" in L.get_data(as_text=True)\n\n    def test_by_url_curve_label(self):\n        # Two elliptic curve factors and decomposing endomorphism algebra:\n        L = self.tc.get(\"/Genus2Curve/Q/1088/b/2176/1\")\n        assert \"32.a1\" in L.get_data(as_text=True) and \"34.a3\" in L.get_data(\n            as_text=True\n        )\n        # RM curve:\n        L = self.tc.get(\"/Genus2Curve/Q/17689/e/866761/1\")\n        assert (\n            \"simple\" in L.get_data(as_text=True) or \"Simple\" in L.get_data(as_text=True)\n        ) and r\"\\mathrm{SU}(2)\\times\\mathrm{SU}(2)\" in L.get_data(as_text=True)\n        # QM curve:\n        L = self.tc.get(\"Genus2Curve/Q/262144/d/524288/1\")\n        assert \"quaternion algebra\" in L.get_data(\n            as_text=True\n        ) and \"J(E_2)\" in L.get_data(as_text=True)\n        L = self.tc.get(\"Genus2Curve/Q/4096/b/65536/1\")\n        # Square over a quadratic extension that is CM over one extension and\n        # multiplication by a quaternion algebra ramifying at infinity over another\n        assert (\n            \"square of\" in L.get_data(as_text=True)\n            and \"2.2.8.1-64.1-a3\" in L.get_data(as_text=True)\n            and r\"\\H\" in L.get_data(as_text=True)\n            and \"(CM)\" in L.get_data(as_text=True)\n        )\n\n    def test_by_url_isogeny_class_discriminant(self):\n        L = self.tc.get(\"/Genus2Curve/Q/15360/f/983040/\")\n        assert (\n            \"15360.f.983040.1\" in L.get_data(as_text=True)\n            and \"15360.f.983040.2\" in L.get_data(as_text=True)\n            and \"15360.d.983040.1\" not in L.get_data(as_text=True)\n        )\n\n    def test_random(self):\n        for _ in range(5):\n            L = self.tc.get(\"/Genus2Curve/Q/random\", follow_redirects=True)\n            assert \"Sato-Tate group\" in L.get_data(as_text=True)\n\n    def test_conductor_search(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?cond=1225\")\n        assert \"1225.a.6125.1\" in L.get_data(as_text=True)\n\n    def test_disc_search(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?abs_disc=3976\")\n        assert \"1988.a.3976.1\" in L.get_data(as_text=True)\n\n    def test_download(self):\n        self.tc.get(\"/Genus2Curve/Q/?query={'abs_disc':3976}&download=gp\")\n        self.tc.get(\"/Genus2Curve/Q/?query={'abs_disc':3976}&download=sage\")\n        self.tc.get(\"/Genus2Curve/Q/?query={'abs_disc':3976}&download=magma\")\n\n    def test_rational_weierstrass_points_search(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?num_rat_wpts=4\")\n        assert \"360.a.6480.1\" in L.get_data(as_text=True)\n\n    def test_torsion_search(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?torsion=[2,2,2]\")\n        assert \"1584.a.684288.1\" in L.get_data(as_text=True)\n\n    def test_torsion_order_search(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?torsion_order=39\")\n        assert \"1116.a.214272.1\" in L.get_data(as_text=True)\n\n    def test_two_selmer_rank_search(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?two_selmer_rank=6\")\n        assert \"65520.b.131040.1\" in L.get_data(as_text=True)\n\n    def test_analytic_rank_search(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?analytic_rank=4\")\n        assert \"440509.a.440509.1\" in L.get_data(as_text=True)\n\n    def test_gl2_type_search(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?gl2_type=True\")\n        assert \"169.a.169.1\" in L.get_data(as_text=True)\n\n    def test_st_group_search(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?st_group=J(E_6)\")\n        assert \"6075.a.18225.1\" in L.get_data(as_text=True)\n\n    def test_st0_group_search(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?real_geom_end_alg=C x R\")\n        assert \"448.a.448.1\" in L.get_data(as_text=True)\n\n    def test_automorphism_group_search(self):\n        self.check_args('/Genus2Curve/Q/?aut_grp_label=12.4', '196.a.21952.1')\n        self.check_args('/Genus2Curve/Q/?aut_grp_id=%5B2,1%5D', '295.a.295.2')\n\n    def test_geometric_automorphism_group_search(self):\n        self.check_args('/Genus2Curve/Q/?geom_aut_grp_label=48.29', '4096.b.65536.1')\n        self.check_args('/Genus2Curve/Q/?geom_aut_grp_id=%5B2,1%5D', '363.a.43923.1')\n\n    def test_locally_solvable_serach(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?locally_solvable=False\")\n        assert \"336.a.172032.1\" in L.get_data(as_text=True)\n\n    def test_sha_search(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?analytic_sha=256\")\n        assert \"114240.d.114240.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/?analytic_sha=3\")\n        assert \"No matches\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/?has_square_sha=False\")\n        assert \"336.a.172032.1\" in L.get_data(\n            as_text=True\n        ) and \"169.a.169.1\" not in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/?locally_solvable=True&has_square_sha=False\")\n        assert \"No matches\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/?analytic_sha=2&has_square_sha=True\")\n        assert \"No matches\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/?analytic_sha=2&has_square_sha=False\")\n        assert \"336.a.172032.1\" in L.get_data(as_text=True)\n\n    def test_torsion(self):\n        L = self.tc.get(\"/Genus2Curve/Q/976/a/999424/1\")\n        assert \"\\\\Z/{29}\\\\Z\" in L.get_data(as_text=True)\n\n    def test_mwgroup(self):\n        L = self.tc.get(\"/Genus2Curve/Q/25913/a/25913/1\")\n        assert \"\\\\Z \\\\oplus \\\\Z \\\\oplus \\\\Z\" in L.get_data(as_text=True)\n        assert \"-x^3 - z^3\" in L.get_data(as_text=True)\n        assert \"0.375585\" in L.get_data(as_text=True)\n        assert \"\\\\infty\" in L.get_data(as_text=True)\n        assert \"6.2.1658432.2\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/969306/a/969306/1\")\n        assert \"\\\\Z \\\\oplus \\\\Z \\\\oplus \\\\Z \\\\oplus \\\\Z/{2}\\\\Z\" in L.get_data(as_text=True)\n        assert \"16y\" in L.get_data(as_text=True) and \"2xz^2 + 11z^3\" in L.get_data(as_text=True)\n        assert \"3.259671\" in L.get_data(as_text=True)\n        assert \"\\\\infty\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/461/a/461/2\")\n        assert \"trivial\" in L.get_data(as_text=True)\n\n    def test_bsd_invariants(self):\n        L = self.tc.get(\"/Genus2Curve/Q/70450/c/704500/1\")\n        assert \"upper bound\" in L.get_data(as_text=True)\n        assert \"0.046457\" in L.get_data(as_text=True)\n        assert \"16.52129\" in L.get_data(as_text=True)\n        assert \"0.767540\" in L.get_data(as_text=True)\n        assert \"rounded\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/1253/a/1253/1\")\n        assert \"0.207463\" in L.get_data(as_text=True)\n        assert \"0.414927\" in L.get_data(as_text=True)\n        assert \"twice a square\" in L.get_data(as_text=True)\n\n    def test_local_invariants(self):\n        L = self.tc.get(\"/Genus2Curve/Q/806069/a/806069/1\")\n        assert \"1 + 5 T + 11 T^{2}\" in L.get_data(as_text=True)\n        assert \"1 + 2 T + 127 T^{2}\" in L.get_data(as_text=True)\n        assert \"1 + 22 T + 577 T^{2}\" in L.get_data(as_text=True)\n\n    def test_mfhilbert(self):\n        L = self.tc.get(\"/Genus2Curve/Q/12500/a/12500/1\")\n        assert \"2.2.5.1-500.1-a\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/12500/a/\")\n        assert \"2.2.5.1-500.1-a\" in L.get_data(as_text=True)\n\n    def test_ratpts(self):\n        L = self.tc.get(\"/Genus2Curve/Q/792079/a/792079/1\")\n        assert \"(-15 : -6579 : 14)\" in L.get_data(as_text=True)\n        assert \"(13 : -4732 : 20)\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/126746/a/126746/1\")\n        assert \"everywhere\" in L.get_data(as_text=True)\n        assert \"This curve has no\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/3319/a/3319/1\")\n        assert \"Known points\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/14880/c/238080/2\")\n        assert \"rational points are known\" in L.get_data(as_text=True)\n        assert \"for this curve\" in L.get_data(as_text=True)\n\n    def test_endo_search(self):\n        # first result for every search\n        for endo, text in [\n            (\"Q\", \"249.a.249.1\"),\n            (\"RM\", \"529.a.529.1\"),\n            (\"CM\", \"3125.a.3125.1\"),\n            (\"QM\", \"20736.l.373248.1\"),\n            (\"Q x Q\", \"294.a.294.1\"),\n            (\"CM x Q\", \"448.a.448.2\"),\n            (\"CM x CM\", \"No matches\"),\n            (\"M_2(Q)\", \"169.a.169.1\"),\n            (\"M_2(CM)\", \"2916.b.11664.1\"),\n        ]:\n            L = self.tc.get(\"/Genus2Curve/Q/?geom_end_alg={}\".format(endo))\n            assert text in L.get_data(as_text=True)\n\n    # tests for searching by geometric invariants\n    def test_igusa_clebsch_search(self):\n        L = self.tc.get(\n            \"/Genus2Curve/Q/?geometric_invariants=[456%2C11220%2C2199936%2C202612]\"\n        )\n        assert \"1369.a.50653.1\" in L.get_data(as_text=True)\n        assert \"169.a.169.1\" not in L.get_data(as_text=True)\n        L = self.tc.get(\n            \"/Genus2Curve/Q/?geometric_invariants=[456%2C11220%2C2199936%2C202612]\"\n        )\n        assert \"1369.a.50653.1\" in L.get_data(as_text=True)\n        assert \"169.a.169.1\" not in L.get_data(as_text=True)\n\n    def test_igusa_search(self):\n        L = self.tc.get(\n            \"/Genus2Curve/Q/?geometric_invariants=[228%2C296%2C-98568%2C-5640280%2C50653]\"\n        )\n        assert \"1369.a.50653.1\" in L.get_data(as_text=True)\n        assert \"169.a.169.1\" not in L.get_data(as_text=True)\n\n    def test_G2_search(self):\n        L = self.tc.get(\n            \"/Genus2Curve/Q/?geometric_invariants=[616132666368%2F50653%2C94818816%2F1369%2C-3742848%2F37]\"\n        )\n        assert \"1369.a.50653.1\" in L.get_data(as_text=True)\n        assert \"169.a.169.1\" not in L.get_data(as_text=True)\n\n    def test_badprimes_search(self):\n        L = self.tc.get(\"/Genus2Curve/Q/?bad_quantifier=exactly&bad_primes=2%2C3\")\n        assert \"324.a.648.1\" in L.get_data(as_text=True)\n        assert \"450.a.2700.1\" not in L.get_data(as_text=True)\n        assert \"169.a.169.1\" not in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/?bad_quantifier=exclude&bad_primes=2%2C3\")\n        assert \"324.a.648.1\" not in L.get_data(as_text=True)\n        assert \"450.a.2700.1\" not in L.get_data(as_text=True)\n        assert \"169.a.169.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/?bad_quantifier=include&bad_primes=2%2C3\")\n        assert \"324.a.648.1\" in L.get_data(as_text=True)\n        assert \"450.a.2700.1\" in L.get_data(as_text=True)\n        assert \"169.a.169.1\" not in L.get_data(as_text=True)\n        L = self.tc.get(\"/Genus2Curve/Q/?bad_primes=2%2C3\")\n        assert \"324.a.648.1\" in L.get_data(as_text=True)\n        assert \"450.a.2700.1\" in L.get_data(as_text=True)\n        assert \"169.a.169.1\" not in L.get_data(as_text=True)\n\n    def test_related_objects(self):\n        for url, friends in [\n            (\n                \"/Genus2Curve/Q/20736/i/373248/1\",\n                (\n                    \"L-function\",\n                    \"Genus 2 curve 20736.i\",\n                    \"Elliptic curve 576.f3\",\n                    \"Elliptic curve 36.a4\",\n                    \"Elliptic curve 2.0.8.1-324.3-a\",\n                    \"Modular form 36.2.a.a\",\n                    \"Modular form 576.2.a.f\",\n                    \"Bianchi modular form 2.0.8.1-324.3-a\",\n                    \"Hilbert modular form 2.2.24.1-36.1-a\",\n                    \"Elliptic curve 2.2.24.1-36.1-a\",\n                    \"Twists\",\n                ),\n            ),\n            (\n                \"/Genus2Curve/Q/20736/i/\",\n                (\n                    \"L-function\",\n                    \"Elliptic curve 576.f\",\n                    \"Elliptic curve 36.a\",\n                    \"Modular form 36.2.a.a\",\n                    \"Modular form 576.2.a.f\",\n                    \"Bianchi modular form 2.0.8.1-324.3-a\",\n                    \"Elliptic curve 2.0.8.1-324.3-a\",\n                    \"Elliptic curve 2.2.24.1-36.1-a\",\n                    \"Hilbert modular form 2.2.24.1-36.1-a\",\n                ),\n            ),\n            (\n                \"/Genus2Curve/Q/576/a/\",\n                (\n                    \"L-function\",\n                    \"Elliptic curve 2.2.8.1-9.1-a\",\n                    \"Modular form 24.2.d.a\",\n                    \"Hilbert modular form 2.2.8.1-9.1-a\",\n                ),\n            ),\n        ]:\n            data = self.tc.get(url).get_data(as_text=True)\n            for friend in friends:\n                assert friend in data\n\n    def test_underlying_data(self):\n        data = self.tc.get(\"/Genus2Curve/Q/data/576.a.576.1\").get_data(as_text=True)\n        assert ('g2c_curves' in data and 'bad_lfactors' in data and\n                'g2c_endomorphisms' in data and 'factorsQQ_base' in data\n                and 'g2c_ratpts' in data and 'mw_gens_v' in data\n                and 'g2c_galrep' in data and 'modell_image' in data\n                and 'g2c_tamagawa' in data and 'tamagawa_number' in data\n                and 'g2c_plots' in data and \"data:image/png;base64\" in data)\n\n    def test_jump(self):\n        from sage.all import magma\n        try:\n            magma('1+1')\n            # Check that giving defining polynomials for f,h works\n            L = self.tc.get('/Genus2Curve/Q/?jump=x%5E5%2Bx%2B1%2Cx', follow_redirects=True)\n            assert \"y^2 + xy = x^5 + x + 1\" in L.get_data(as_text=True)\n\n            # Check that giving a Weierstrass equation works, even without explicit multiplication '*'\n            L = self.tc.get(\"/Genus2Curve/Q/?jump=b%5E2%3Da%5E5-2a%5E2%2B1\", follow_redirects=True)\n            assert \"$y^2 = x^5 - 2x^2 + 1$\" in L.get_data(as_text=True)\n\n            # Check that variables are only single characters\n            L = self.tc.get(\"/Genus2Curve/Q/?jump=(banana)%5E2%3Dx%5E5%2B1\", follow_redirects=True)\n            assert \"is not in two variables\" in L.get_data(as_text=True)\n\n            # Check that curves not of genus 2 fail\n            L = self.tc.get(\"/Genus2Curve/Q/?jump=y^2+%3D+x^10+-+1\", follow_redirects=True)\n            assert \"invalid genus 2 curve\" in L.get_data(as_text=True)\n\n            # Check that there are only two variables present\n            L = self.tc.get(\"/Genus2Curve/Q/?jump=y%5E2+%3D+x+%2B+a\", follow_redirects=True)\n            assert \"is not in two variables\" in L.get_data(as_text=True)\n        except (RuntimeError, TypeError) as the_error:\n            if str(the_error).startswith(\"unable to start magma\"):\n                pass\n            else:\n                raise\n\n    def test_galrep(self):\n        # A generic example\n        L = self.tc.get(\"/Genus2Curve/Q/976/a/999424/1\")\n        assert \"2.6.1\" in L.get_data(as_text=True)\n\n        # A nongeneric example\n        L = self.tc.get(\"/Genus2Curve/Q/961/a/961/1\")\n        assert \"3.72.2\" in L.get_data(as_text=True)\n        assert \"Galois representation data has not been computed for this curve\" in L.get_data(as_text=True)"
  },
  {
    "type": "class",
    "file": "lmfdb/modular_curves/test_modular_curves.py",
    "name": "ModCrvTest",
    "line_start": 4,
    "line_end": 514,
    "lines": 511,
    "bytes": 22113,
    "has_71": true,
    "code": "class ModCrvTest(LmfdbTest):\n    def test_home(self):\n        L = self.tc.get('/ModularCurve/Q/')\n        assert 'Modular curves' in L.get_data(as_text=True)\n        assert 'Browse' in L.get_data(as_text=True)\n        assert 'Search' in L.get_data(as_text=True)\n        assert 'Find' in L.get_data(as_text=True)\n        assert 'X_0(N)' in L.get_data(as_text=True)\n\n    def test_level_range(self):\n        L = self.tc.get(\"/ModularCurve/Q/?level=10-100\")\n        assert \"10.2.0.a.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?level_type=prime&level=10-100\")\n        assert \"11.12.1.a.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?level_type=prime_power&level=25-100\")\n        assert \"25.30.0.a.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?level_type=squarefree&level=49-150\")\n        assert \"51.6.0.a.1\" in L.get_data(as_text=True)\n\n    def test_level_search(self):\n        L = self.tc.get(\"/ModularCurve/Q/?level=13\")\n        assert \"13.14.0.a.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?level_type=prime&level=23\")\n        assert \"23.24.2.a.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?level_type=prime&level=22\")\n        assert \"No matches\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?level_type=prime_power&level=169\")\n        assert \"169.182.8.a.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?level_type=squarefree&level=74\")\n        assert \"74.2.0.a.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?start=0&level_type=divides&level=15\")\n        assert \"15.12.0.b.2\" in L.get_data(as_text=True)\n\n    def test_index_range(self):\n        L = self.tc.get(\"/ModularCurve/Q/?index=100-1000\")\n        assert \"6.144.1-6.b.1.1\" in L.get_data(as_text=True)\n\n    def test_index_search(self):\n        L = self.tc.get(\"/ModularCurve/Q/?index=42\")\n        assert \"7.42.1.a.1\" in L.get_data(as_text=True)\n\n    def test_genus_range(self):\n        L = self.tc.get(\"/ModularCurve/Q/?genus=10-1000\")\n        assert \"9.648.10-9.a.1.2\" in L.get_data(as_text=True)\n\n    def test_genus_search(self):\n        L = self.tc.get(\"/ModularCurve/Q/?genus=25\")\n        assert \"12.576.25.a.1\" in L.get_data(as_text=True)\n\n    def test_rank_range(self):\n        L = self.tc.get(\"/ModularCurve/Q/?rank=20-200\")\n        assert \"13.1092.50.d.1\" in L.get_data(as_text=True)\n\n    def test_rank_search(self):\n        L = self.tc.get(\"/ModularCurve/Q/?rank=10\")\n        assert \"16.768.41.q.1\" in L.get_data(as_text=True)\n\n    def test_genus_minus_rank_range(self):\n        L = self.tc.get(\"/ModularCurve/Q/?genus_minus_rank=2-5\")\n        assert \"7.168.3.a.1\" in L.get_data(as_text=True)\n\n    def test_genus_minus_rank_search(self):\n        L = self.tc.get(\"/ModularCurve/Q/?genus_minus_rank=30\")\n        assert \"15.720.37.h.1\" in L.get_data(as_text=True)\n\n    def test_Q_gonality_search(self):\n        L = self.tc.get(\"/ModularCurve/Q/?q_gonality=4\")\n        assert \"8.192.3-8.d.1.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?gonality_type=possibly&q_gonality=8\")\n        assert \"10.360.13.b.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?gonality_type=atleast&q_gonality=7\")\n        assert \"11.660.26.a.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?count=None&gonality_type=atmost&q_gonality=3\")\n        assert \"1.1.0.a.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?gonality_type=atmost&q_gonality=3-4\")\n        assert \"is not a valid input for\" in L.get_data(as_text=True)\n\n    def test_cusps_range(self):\n        L = self.tc.get(\"/ModularCurve/Q/?cusps=48-60\")\n        assert \"11.660.26.a.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?rational_cusps=100-1000\")\n        assert \"211.22260.1751.by.1\" in L.get_data(as_text=True)\n\n    def test_cusps_search(self):\n        L = self.tc.get(\"/ModularCurve/Q/?cusps=6\")\n        assert \"4.24.0.a.1\" in L.get_data(as_text=True)\n\n    def test_rational_CM_points_search(self):\n        L = self.tc.get(\"/ModularCurve/Q/?cm_discriminants=yes\")\n        assert \"3.3.0.a.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?cm_discriminants=no\")\n        assert \"4.24.0.b.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?cm_discriminants=-4%2C-16\")\n        assert \"2.3.0.a.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?cm_discriminants=-3\")\n        assert \"3.6.0.b.1\" in L.get_data(as_text=True)\n\n        # Fails due to slow query\n        # L = self.tc.get(\"/ModularCurve/Q/?cm_discriminants=-27\")\n        # assert \"6.8.0-3.a.1.1\" in L.get_data(as_text=True)\n\n    def test_elliptic_points_order_2_search(self):\n        L = self.tc.get(\"/ModularCurve/Q/?nu2=2\")\n        assert \"4.6.0.e.1\" in L.get_data(as_text=True)\n\n    def test_elliptic_points_order_3_search(self):\n        L = self.tc.get(\"/ModularCurve/Q/?nu3=10\")\n        assert \"25.100.4.a.1\" in L.get_data(as_text=True)\n\n    def test_SL2_level(self):\n        L = self.tc.get(\"/ModularCurve/Q/252.432.10-126.dk.1.10\",follow_redirects=True)\n        assert r\"$\\SL_2$-level\" in L.get_data(as_text=True)\n        assert \"$36$\" in L.get_data(as_text=True)\n\n    def test_PSL2_index(self):\n        L = self.tc.get(\"/ModularCurve/Q/60.1152.25-60.dh.4.24\",follow_redirects=True)\n        assert r\"$\\PSL_2$-index\" in L.get_data(as_text=True)\n        assert \"$576$\" in L.get_data(as_text=True)\n\n    def test_cusp_widths(self):\n        L = self.tc.get(\"/ModularCurve/Q/252.432.10-126.dk.1.10\",follow_redirects=True)\n        assert \"Cusp widths\" in L.get_data(as_text=True)\n        assert r\"$6^{9}\\cdot18^{9}$\" in L.get_data(as_text=True)\n\n    def test_newform_level(self):\n        L = self.tc.get(\"/ModularCurve/Q/48.9216.321-48.fnp.1.1\",follow_redirects=True)\n        assert \"Newform level\" in L.get_data(as_text=True)\n        assert \"$2304$\" in L.get_data(as_text=True)\n\n    def test_cusp_orbits(self):\n        L = self.tc.get(\"/ModularCurve/Q/60.8640.313-60.eqq.1.4\",follow_redirects=True)\n        assert \"Cusp orbits\" in L.get_data(as_text=True)\n        assert r\"$8^{6}\\cdot16^{3}$\" in L.get_data(as_text=True)\n\n    def test_modcrv_label(self):\n        L = self.tc.get(\"/ModularCurve/Q/48.576.21-48.bqz.1.2\",follow_redirects=True)\n        assert \"Cummins and Pauli (CP) label\" in L.get_data(as_text=True)\n        assert \"48P21\" in L.get_data(as_text=True)\n        assert \"Rouse, Sutherland, and Zureick-Brown (RSZB) label\" in L.get_data(as_text=True)\n        assert \"48.576.21.26699\" in L.get_data(as_text=True)\n\n    def test_GL2ZNZ_gens(self):\n        L = self.tc.get(\"/ModularCurve/Q/240.288.8-48.jt.2.31\",follow_redirects=True)\n        for matrix_gens in [\n            r\"$\\GL_2(\\Z/240\\Z)$-generators\",\n            r\"$\\begin{bmatrix}31&amp;54\\\\156&amp;217\\end{bmatrix}$\",\n            r\"$\\begin{bmatrix}110&amp;141\\\\191&amp;100\\end{bmatrix}$\",\n            r\"$\\begin{bmatrix}132&amp;227\\\\7&amp;168\\end{bmatrix}$\",\n            r\"$\\begin{bmatrix}164&amp;137\\\\171&amp;10\\end{bmatrix}$\",\n            r\"$\\begin{bmatrix}181&amp;150\\\\154&amp;113\\end{bmatrix}$\",\n            r\"$\\begin{bmatrix}191&amp;226\\\\34&amp;151\\end{bmatrix}$\"\n            ]:\n            assert matrix_gens in L.get_data(as_text=True)\n\n    def test_GL2ZNZ_subgroup(self):\n        L = self.tc.get(\"/ModularCurve/Q/40.2880.97-40.blq.2.11\",follow_redirects=True)\n        assert r\"$\\GL_2(\\Z/40\\Z)$-subgroup\" in L.get_data(as_text=True)\n        assert \"$C_2^5.D_4$\" in L.get_data(as_text=True)\n\n    def test_contains_negative_one_search(self):\n        L = self.tc.get(\"/ModularCurve/Q/?contains_negative_one=yes\")\n        assert \"4.2.0.a.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?contains_negative_one=no\")\n        assert \"3.24.0-3.a.1.1\" in L.get_data(as_text=True)\n\n    def test_cyclic_isogeny_field_degree(self):\n        L = self.tc.get(\"/ModularCurve/Q/252.432.10-126.dk.1.10\",follow_redirects=True)\n        assert \"Cyclic 252-isogeny field degree\" in L.get_data(as_text=True)\n        assert \"$48$\" in L.get_data(as_text=True)\n\n    def test_cyclic_torsion_field_degree(self):\n        L = self.tc.get(\"/ModularCurve/Q/168.144.4-168.lh.1.28\",follow_redirects=True)\n        assert \"Cyclic 168-torsion field degree\" in L.get_data(as_text=True)\n        assert \"$1536$\" in L.get_data(as_text=True)\n\n    def test_full_torsion_field_degree(self):\n        L = self.tc.get(\"/ModularCurve/Q/60.2304.81-60.hp.2.4\",follow_redirects=True)\n        assert \"Full 60-torsion field degree\" in L.get_data(as_text=True)\n        assert \"$960$\" in L.get_data(as_text=True)\n\n    def test_conductor(self):\n        L = self.tc.get(\"/ModularCurve/Q/48.4608.161-48.blz.2.8\",follow_redirects=True)\n        assert \"Conductor\" in L.get_data(as_text=True)\n        assert r\"$2^{981}\\cdot3^{256}$\" in L.get_data(as_text=True)\n\n    def test_is_simple(self):\n        L = self.tc.get(\"/ModularCurve/Q/48.3072.97-48.bmv.8.32\",follow_redirects=True)\n        assert \"Simple\" in L.get_data(as_text=True)\n\n    def test_is_squarefree(self):\n        L = self.tc.get(\"/ModularCurve/Q/120.192.1-120.sp.4.13\",follow_redirects=True)\n        assert \"Squarefree\" in L.get_data(as_text=True)\n\n    def test_isogeny_decomposition(self):\n        L = self.tc.get(\"/ModularCurve/Q/48.6144.193-48.td.4.12\",follow_redirects=True)\n        assert \"Decomposition\" in L.get_data(as_text=True)\n        assert r\"$1^{49}\\cdot2^{32}\\cdot4^{20}$\" in L.get_data(as_text=True)\n\n    def test_newforms(self):\n        L = self.tc.get(\"/ModularCurve/Q/64.3072.113-64.do.2.4\",follow_redirects=True)\n        assert \"Newforms\" in L.get_data(as_text=True)\n        assert r'href=\"/ModularForm/GL2/Q/holomorphic/16/2/e/a/\">16.2.e.a</a>$^{2}$' in L.get_data(as_text=True)\n\n    def test_modcrv_model(self):\n        L = self.tc.get(\"/ModularCurve/Q/180.216.4-18.e.2.8\",follow_redirects=True)\n        assert \"Canonical model\" in L.get_data(as_text=True)\n        assert \"$ 12 x^{2} + 3 x y + 3 y^{2} - z^{2} + z w - w^{2} $\" in L.get_data(as_text=True)\n        assert \"Singular plane model\" in L.get_data(as_text=True)\n        assert r\"$  - 2008 x^{6} + 456 x^{5} y + 192 x^{5} z + 408 x^{4} y^{2} - 564 x^{4} y z + 324 x^{4} z^{2} + \\cdots  + 9 y^{2} z^{4} $\" in L.get_data(as_text=True)\n\n    def test_rational_points(self):\n        data = self.tc.get(\"/ModularCurve/Q/48.1152.81.mov.1/\",follow_redirects=True).get_data(as_text=True)\n        assert \"Rational points\" in data\n        assert r\"This modular curve has 2 rational cusps but no known non-cuspidal rational points.\" in data\n        data = self.tc.get(\"/ModularCurve/Q/168.144.3-12.i.1.3\",follow_redirects=True).get_data(as_text=True)\n        assert \"Rational points\" in data\n        assert \"Embedded model\" in data\n        assert r\"$(1:1:0:0:0)$, $(0:0:0:-1:1)$, $(0:0:1:1:0)$, $(0:0:1/2:1:0)$\" in data\n        data = self.tc.get(\"/ModularCurve/Q/37.38.2.a.1\",follow_redirects=True).get_data(as_text=True)\n        assert \"Elliptic curve\" in data\n        assert \"CM\" in data\n        assert \"$j$-invariant\" in data\n        assert \"$j$-height\" in data\n        assert \"Plane model\" in data\n        assert \"Weierstrass model\" in data\n        assert \"Embedded model\" in data\n\n    def test_low_degree_points_search(self):\n        L = self.tc.get(\"/ModularCurve/Q/low_degree_points?cusp=no\")\n        assert \"31752.f1\" in L.get_data(as_text=True)\n\n    def test_obstructions_search(self):\n        L = self.tc.get(\"/ModularCurve/Q/?has_obstruction=yes\")\n        assert \"3.6.0.a.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?has_obstruction=not_yes\")\n        assert \"1.1.0.a.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?has_obstruction=no\")\n        assert \"2.2.0.a.1\" in L.get_data(as_text=True)\n\n    def test_j_points_range(self):\n        L = self.tc.get(\"/ModularCurve/Q/?points=10-50\")\n        assert \"4.24.0.c.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?points_type=noncm&points=20-40\")\n        assert \"8.12.0.f.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?points_type=all&points=30-60\")\n        assert \"4.24.0.c.1\" in L.get_data(as_text=True)\n        L = self.tc.get(\"/ModularCurve/Q/?points_type=all&points=30-60\")\n        assert \"4.24.0.c.1\" in L.get_data(as_text=True)\n\n    def test_fiber_product_of_search(self):\n        L = self.tc.get(\"/ModularCurve/Q/?factor=3.8.0-3.a.1.1\")\n        assert \"6.16.0-6.a.1.1\" in L.get_data(as_text=True)\n\n    def test_fiber_product_of(self):\n        L = self.tc.get(\"/ModularCurve/Q/10.15.1.a.1\",follow_redirects=True)\n        assert \"Fiber product\" in L.get_data(as_text=True)\n        assert \"$X_0(2)$\" in L.get_data(as_text=True)\n        assert \"$X_{S_4}(5)$\" in L.get_data(as_text=True)\n\n    # Fails due to slow query.\n    # def test_minimally_covers_search(self):\n    #     L = self.tc.get(\"/ModularCurve/Q/?covers=13.14.0.a.1\")\n    #     assert \"39.28.0.a.2\" in L.get_data(as_text=True)\n\n    def test_minimally_covers(self):\n        L = self.tc.get(\"/ModularCurve/Q/31.192.6-31.a.1.1\",follow_redirects=True)\n        assert \"minimally covers\" in L.get_data(as_text=True)\n        assert \"31.64.2-31.a.1.2\" in L.get_data(as_text=True)\n\n    def test_minimally_covered_by_search(self):\n        L = self.tc.get(\"/ModularCurve/Q/?covered_by=16.48.3.a.2\")\n        assert \"8.24.1.b.1\" in L.get_data(as_text=True)\n        # Fails due to slow query\n        # L = self.tc.get(\"/ModularCurve/Q/?covered_by=9A11\")\n        # assert \"not the label of a modular curve in the database\" in L.get_data(as_text=True)\n\n    def test_minimally_covered_by(self):\n        L = self.tc.get(\"/ModularCurve/Q/40.2304.65-40.mm.4.13\",follow_redirects=True)\n        covering_curve_urls_set = [\n            '/ModularCurve/Q/40.4608.129-40.cf.3.6',\n            '/ModularCurve/Q/40.4608.129-40.cl.1.7',\n            '/ModularCurve/Q/40.4608.129-40.fz.3.6',\n            '/ModularCurve/Q/40.4608.129-40.gb.1.7',\n            '/ModularCurve/Q/40.4608.129-40.kp.3.7',\n            '/ModularCurve/Q/40.4608.129-40.kr.4.4',\n            '/ModularCurve/Q/40.4608.129-40.of.3.7',\n            '/ModularCurve/Q/40.4608.129-40.ol.4.6',\n            '/ModularCurve/Q/40.11520.385-40.nw.1.13'\n        ]\n        for url in covering_curve_urls_set:\n            L1 = self.tc.get(url)\n            assert url[15:] in L.get_data(as_text=True)\n            assert url[15:] in L1.get_data(as_text=True)\n\n    def test_family_page(self):\n        for name, family in ALL_FAMILIES.items():\n            self.check_args(\n                f\"/ModularCurve/Q/family/{name}\",\n                [\n                    family.name,\n                    family.genus_formula,\n                    family.cusps,\n                    family.psl2index,\n                    family.nu2,\n                    family.nu3,\n                ],\n            )\n\n    def test_family_search(self):\n        family_set = [\n            ('X0','2.3.0.a.1'),\n            ('X1','4.12.0-4.c.1.1'),\n            ('Xpm1','5.12.0.a.1'),\n            ('X','2.6.0.a.1'),\n            ('Xarith1','4.24.0-4.b.1.3'),\n            ('Xarithpm1','6.24.0.a.1'),\n            ('Xsp','3.12.0.a.1'),\n            ('Xns','3.6.0.a.1'),\n            ('Xspplus','3.6.0.b.1'),\n            ('Xnsplus','3.3.0.a.1'),\n            ('XS4','5.5.0.a.1'),\n            ('Xarith','4.48.0-4.b.1.1'),\n            ('any','1.1.0.a.1')\n        ]\n        for family, crv in family_set:\n            url = '/ModularCurve/Q/?family=' + family\n            L = self.tc.get(url)\n            assert crv in L.get_data(as_text=True)\n\n    def test_image(self):\n        L = self.tc.get(\"/ModularCurve/Q/280.288.17.cdv.1\", follow_redirects=True)\n        assert \"image/png\" in L.get_data(as_text=True)\n        assert \"Picture description\" in L.get_data(as_text=True)\n\n    def test_interesting(self):\n        L = self.tc.get(\"/ModularCurve/interesting\")\n        assert \"Fermat quartic\" in L.get_data(as_text=True)\n\n    def test_random(self):\n        for _ in range(5):\n            L = self.tc.get(\"/ModularCurve/Q/random\", follow_redirects=True)\n            assert \"Label\" in L.get_data(as_text=True)\n\n    def test_jump(self):\n        jump_set = [\n            ('60.34560.1297-60.bwg.1.1','60.34560.1297-60.bwg.1.1'),\n            ('XSP(3)','3.12.0.a.1'),\n            ('Xsp%2B%2811%29','11.66.2.a.1'),\n            ('32.1536.41.1175','32.1536.41-32.bz.3.6'),\n            ('7B.6.2','7.24.0.b.1'),\n            ('4E0-8b','8.12.0.a.1'),\n            ('banana','Error: There is no modular curve in the database')\n        ]\n        for j,l in jump_set:\n            L = self.tc.get(\"/ModularCurve/Q/?jump=%s\" % j,follow_redirects=True)\n            assert l in L.get_data(as_text=True)\n\n    def test_related_objects(self):\n        for url, friends in [\n            (\n                \"/ModularCurve/Q/48.4608.161-48.duj.4.7\",\n                (\n                    # Currently, isogeny/gassmann class links are not available on individual curve pages.\n                    # 'Modular isogeny class 48.2304.161.duj',\n                    'L-function not available',\n                    'Modular curve 48.2304.161.duj.1',\n                    'Modular curve 48.2304.161.duj.2',\n                    'Modular curve 48.2304.161.duj.3',\n                    'Modular curve 48.2304.161.duj.4',\n                    'Modular curve 48.2304.161.duj.5',\n                    'Modular curve 48.2304.161.duj.6',\n                    'Modular curve 48.2304.161.duj.7',\n                    'Modular curve 48.2304.161.duj.8',\n                    'Modular curve 48.2304.161.dut.1',\n                    'Modular curve 48.2304.161.dut.2',\n                    'Modular curve 48.2304.161.dut.3',\n                    'Modular curve 48.2304.161.dut.4',\n                    'Modular curve 48.2304.161.dut.5',\n                    'Modular curve 48.2304.161.dut.6',\n                    'Modular curve 48.2304.161.dut.7',\n                    'Modular curve 48.2304.161.dut.8'\n                )\n            ),\n            (\n                \"/ModularCurve/Q/60.2880.97-60.bol.1.8\",\n                (\n                    # Currently, isogeny/gassmann class links are not available on individual curve pages.\n                    # 'Modular isogeny class 60.1440.97.bol',\n                    'L-function not available',\n                    'Modular curve 60.1440.97.bog.1',\n                    'Modular curve 60.1440.97.bol.1'\n                )\n            ),\n            # The next two cases come from LMFDB#5929\n            (\n                \"/ModularCurve/Q/6.6.1.a.1\",\n                (\n                    'Elliptic curve 36.a3',\n                    'Modular form 36.2.a.a'\n                )\n            ),\n            (\n                \"/ModularCurve/Q/23.24.2.a.1\",\n                (\n                    'Isogeny class 529.a',\n                    'Modular form 23.2.a.a'\n                )\n            )\n            ]:\n            data = self.tc.get(url,follow_redirects=True).get_data(as_text=True)\n            for friend in friends:\n                assert friend in data\n\n    def test_download(self):\n        self.tc.get(\"/ModularCurve/download_to_magma/60.11520.409-60.bwm.1.10\")\n        self.tc.get(\"/ModularCurve/download_to_sage/60.11520.409-60.bwm.1.10\")\n        self.tc.get(\"/ModularCurve/download_to_text/60.11520.409-60.bwm.1.10\")\n\n    def test_underlying_data(self):\n        data = self.tc.get(\"/ModularCurve/data/56.4032.139-56.fq.1.17\",follow_redirects=True).get_data(as_text=True)\n        for underlying_data in [\n            'CPlabel',\n            'Glabel',\n            'RSZBlabel',\n            'RZBlabel',\n            'SZlabel',\n            'Slabel',\n            'all_degree1_points_known',\n            'bad_primes',\n            'canonical_conjugator',\n            'canonical_generators',\n            'cm_discriminants',\n            'coarse_class',\n            'coarse_class_num',\n            'coarse_index',\n            'coarse_label',\n            'coarse_level',\n            'coarse_num',\n            'conductor',\n            'contains_negative_one',\n            'curve_label',\n            'cusp_orbits',\n            'cusp_widths',\n            'cusps',\n            'determinant_label',\n            'dims',\n            'factorization',\n            'fine_num',\n            'generators',\n            'genus',\n            'genus_minus_rank',\n            'has_obstruction',\n            'index',\n            'isogeny_orbits',\n            'kummer_orbits',\n            'label',\n            'lattice_labels',\n            'lattice_x',\n            'level',\n            'level_is_squarefree',\n            'level_radical',\n            'log_conductor',\n            'models',\n            'mults',\n            'name',\n            'newforms',\n            'nu2',\n            'nu3',\n            'num_bad_primes',\n            'num_known_degree1_noncm_points',\n            'num_known_degree1_noncusp_points',\n            'num_known_degree1_points',\n            'obstructions',\n            'orbits',\n            'parents',\n            'parents_conj',\n            'pointless',\n            'power',\n            'psl2index',\n            'psl2label',\n            '56.2016.139.b.1',\n            'psl2level',\n            'q_gonality',\n            'q_gonality_bounds',\n            'qbar_gonality',\n            'qbar_gonality_bounds',\n            'rank',\n            'rational_cusps',\n            'reductions',\n            'scalar_label',\n            'simple',\n            'sl2label',\n            'sl2level',\n            'squarefree',\n            'trace_hash',\n            'traces'\n            ]:\n            assert underlying_data in data\n\n    def test_gassmann_class(self):\n        data = self.tc.get(\"/ModularCurve/Q/40.720.49.df\", follow_redirects=True).get_data(as_text=True)\n        for gassmann_data in [\n            'Cusp orbits',\n            'Level',\n            'Elliptic points',\n            'Number of curves',\n            'Genus',\n            '20.2.a.a',\n            '40.720.49.1139'\n            ]:\n            assert gassmann_data in data"
  },
  {
    "type": "class",
    "file": "lmfdb/tests/test_utils.py",
    "name": "UtilsTest",
    "line_start": 41,
    "line_end": 403,
    "lines": 363,
    "bytes": 22232,
    "has_71": true,
    "code": "class UtilsTest(unittest.TestCase):\n    \"\"\"\n    An example of unit tests that are not based on the website itself.\n    \"\"\"\n\n    def test_an_list(self):\n        r\"\"\"\n        Checking utility: an_list\n        \"\"\"\n        # (1 - 2^{-s})^{-1} (1 - 3^{-s})^{-1}\n        def euler1(p): return [1, -1] if p <= 3 else [1,0]\n        t1 = an_list(euler1, upperbound=20)\n        expect1 = [1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0]\n        self.assertEqual(t1, expect1)\n\n        # (1 + 2^{-s})^{-1} (1 + 3^{-s})^{-1}\n        def euler2(p): return [1, 1] if p <= 3 else [1,0]\n        t2 = an_list(euler2, upperbound=20)\n        expect2 = [1, -1, -1, 1, 0, 1, 0, -1, 1, 0, 0, -1, 0, 0, 0, 1, 0, -1, 0, 0]\n        self.assertEqual(t2, expect2)\n\n    def test_coeff_to_poly(self):\n        r\"\"\"\n        Checking utility: coeff_to_poly\n        \"\"\"\n        x = var('x')\n        self.assertEqual(coeff_to_poly(\"1 - 3x + x^2\"), x**2 - 3*x + 1)\n\n    def test_display_multiset(self):\n        r\"\"\"\n        Checking utility: display_multiset\n        \"\"\"\n        self.assertEqual(display_multiset([[\"a\", 3], [12, 2]]), 'a x3, 12 x2')\n        self.assertEqual(display_multiset([[1, 4], [0, 0], [\"cat\", 2]]),\n                                          '1 x4, 0, cat x2')\n\n    def test_pair2complex(self):\n        r\"\"\"\n        Checking utility: pair2complex\n        \"\"\"\n        self.assertEqual(pair2complex(\"1 2\"), [1.0, 2.0])\n        self.assertEqual(pair2complex(\"1.5\"), [1.5, 0])\n        self.assertEqual(pair2complex(\"  -1.3    4.1   \"), [-1.3, 4.1])\n\n    def test_round_to_half_int(self):\n        r\"\"\"\n        Checking utility: round_to_half_int\n        \"\"\"\n        self.assertEqual(round_to_half_int(1.1), 1.0)\n        self.assertEqual(round_to_half_int(-0.9), -1.0)\n\n    def test_to_dict(self):\n        r\"\"\"\n        Checking utility: to_dict\n        \"\"\"\n        self.assertEqual(to_dict({\"not_list\": 1, \"is_list\":[2,3,4]}),\n                         {'is_list': 4, 'not_list': 1})\n\n    def test_splitcoeff(self):\n        r\"\"\"\n        Checking utility: splitcoeff\n        \"\"\"\n        self.assertEqual(splitcoeff(\"1 2\"), [[1.0, 2.0]])\n        self.assertEqual(splitcoeff(\"  0  -1.2  \\n  3.14  1 \"),\n                         [[0.0, -1.2], [3.14, 1.0]])\n\n    ################################################################################\n    #  display and formatting utilities\n    ################################################################################\n\n    def test_comma(self):\n        r\"\"\"\n        Checking utility: comma\n        \"\"\"\n        self.assertEqual(comma(123), \"$123$\")\n        self.assertEqual(comma(123456789), \"$123{,}456{,}789$\")\n        self.assertEqual(comma(123, mathmode=False), \"123\")\n        self.assertEqual(comma(123456789, mathmode=False), \"123,456,789\")\n\n    def test_format_percentage(self):\n        r\"\"\"\n        Checking utility: format_percentage\n        \"\"\"\n        self.assertEqual(format_percentage(12,31), '     38.71')\n        self.assertEqual(format_percentage(12,37), '     32.43')\n\n    def test_signtocolour(self):\n        r\"\"\"\n        Checking utility: signtocolour\n        \"\"\"\n        self.assertEqual(signtocolour(0), 'rgb(63,63,255)')\n        self.assertEqual(signtocolour(\"1+2*I\"), 'rgb(197,0,184)')\n\n    def test_rgbtohex(self):\n        r\"\"\"\n        Checking utility: rgbtohex\n        \"\"\"\n        self.assertEqual(rgbtohex('rgb(63,255,100)'), '#3fff64')\n        self.assertEqual(rgbtohex('rbg(63,63,255)'), '#3f3fff')\n\n    ################################################################################\n    #  latex/math rendering utilities\n    ################################################################################\n\n    def test_web_latex(self):\n        r\"\"\"\n        Checking utility: web_latex\n        \"\"\"\n        x = var('x')\n        self.assertEqual(web_latex(\"test string\"), \"test string\")\n        self.assertEqual(web_latex(x**23 + 2*x + 1),\n                         '\\\\( x^{23} + 2 \\\\, x + 1 \\\\)')\n        self.assertEqual(web_latex(x**23 + 2*x + 1, enclose=False),\n                         ' x^{23} + 2 \\\\, x + 1 ')\n\n    def test_web_latex_ideal_fact(self):\n        r\"\"\"\n        Checking utility: web_latex_ideal_fact\n        \"\"\"\n        from sage.all import NumberField\n        x = var('x')\n        K = NumberField(x**2 - 5, 'a')\n        a = K.gen()\n        I = K.ideal(2/(5+a)).factor()\n        self.assertEqual(web_latex_ideal_fact(I),\n                         '\\\\( \\\\left(-a\\\\right)^{-1} \\\\)')\n        self.assertEqual(web_latex_ideal_fact(I, enclose=False),\n                         ' \\\\left(-a\\\\right)^{-1} ')\n\n    def test_web_latex_split_on(self):\n        r\"\"\"\n        Checking utility: web_latex_split_on\n        \"\"\"\n        x = var('x')\n        self.assertEqual(web_latex_split_on(\"test string\"), \"test string\")\n        self.assertEqual(web_latex_split_on(x**2 + 1),\n                         '\\\\( x^{2} \\\\) + \\\\(  1 \\\\)')\n\n    def test_web_latex_split_on_pm(self):\n        r\"\"\"\n        Checking utility: web_latex_split_on_pm\n        \"\"\"\n        x = var('x')\n        f = x**2 + 1\n        expected = '\\\\(x^{2} \\\\) \\\\(\\\\mathstrut +\\\\mathstrut  1 \\\\)'\n        self.assertEqual(web_latex_split_on_pm(f), expected)\n\n    def test_web_latex_split_on_re(self):\n        r\"\"\"\n        Checking utility: web_latex_split_on_re\n        \"\"\"\n        x = var('x')\n        f = x**2 + 1\n        expected = '\\\\(x^{2} \\\\) \\\\(\\\\mathstrut+  1 \\\\)'\n        self.assertEqual(web_latex_split_on_re(f), expected)\n\n    def test_list_to_latex_matrix(self):\n        r\"\"\"\n        Checking utility: list_to_latex_matrix\n        \"\"\"\n        identity_list = [[1,0], [0,1]]\n        identity_rep = '\\\\left(\\\\begin{array}{rr}1 & 0\\\\\\\\0 & 1\\\\end{array}\\\\right)'\n        self.assertEqual(list_to_latex_matrix(identity_list), identity_rep)\n\n        # malformed matrices should work\n        malformed = [[1,0], [0]]\n        malform_rep = '\\\\left(\\\\begin{array}{rr}1 & 0\\\\\\\\0\\\\end{array}\\\\right)'\n        self.assertEqual(list_to_latex_matrix(malformed), malform_rep)\n\n    def test_integer_set(self):\n        A = IntegerSet([2, 4])\n        B = IntegerSet([6, 9])\n        C = IntegerSet([-11, 5])\n        self.assertEqual(str(A + A), \"[4, 8]\")\n        self.assertEqual(str(A - A), \"[-2, 2]\")\n        self.assertEqual(str(A * A), \"[4, 16]\")\n        self.assertEqual(str(A / A), \"[1, 2]\")\n        self.assertEqual(str(-A), \"[-4, -2]\")\n        self.assertEqual(str(~A), \"[1/4, 1/2]\")\n        self.assertEqual(str(A + B), \"[8, 13]\")\n        self.assertEqual(str(A - B), \"[-7, -2]\")\n        self.assertEqual(str(A * B), \"[12, 36]\")\n        self.assertEqual(str(A / B), \"{}\")\n        self.assertEqual(str(A + C), \"[-9, 9]\")\n        self.assertEqual(str(A - C), \"[-3, 15]\")\n        self.assertEqual(str(A * C), \"[-44, 20]\")\n        self.assertEqual(str(A / C), \"[-4, -1] \u222a [1, 4]\")\n        self.assertEqual(str(B + A), \"[8, 13]\")\n        self.assertEqual(str(B - A), \"[2, 7]\")\n        self.assertEqual(str(B * A), \"[12, 36]\")\n        self.assertEqual(str(B / A), \"[2, 4]\")\n        self.assertEqual(str(B + B), \"[12, 18]\")\n        self.assertEqual(str(B - B), \"[-3, 3]\")\n        self.assertEqual(str(B * B), \"[36, 81]\")\n        self.assertEqual(str(B / B), \"{1}\")\n        self.assertEqual(str(-B), \"[-9, -6]\")\n        self.assertEqual(str(~B), \"[1/9, 1/6]\")\n        self.assertEqual(str(B + C), \"[-5, 14]\")\n        self.assertEqual(str(B - C), \"[1, 20]\")\n        self.assertEqual(str(B * C), \"[-99, 45]\")\n        self.assertEqual(str(B / C), \"[-9, -1] \u222a [2, 9]\")\n        self.assertEqual(str(C + A), \"[-9, 9]\")\n        self.assertEqual(str(C - A), \"[-15, 3]\")\n        self.assertEqual(str(C * A), \"[-44, 20]\")\n        self.assertEqual(str(C / A), \"[-5, 2]\")\n        self.assertEqual(str(C + B), \"[-5, 14]\")\n        self.assertEqual(str(C - B), \"[-20, -1]\")\n        self.assertEqual(str(C * B), \"[-99, 45]\")\n        self.assertEqual(str(C / B), \"[-1, 0]\")\n        self.assertEqual(str(C + C), \"[-22, 10]\")\n        self.assertEqual(str(C - C), \"[-16, 16]\")\n        self.assertEqual(str(C * C), \"[-55, 121]\")\n        self.assertEqual(str(C / C), \"[-11, 11]\")\n        self.assertEqual(str(-C), \"[-5, 11]\")\n        self.assertEqual(str(~C), \"(-oo, -1/11] \u222a [1/5, +oo)\")\n        self.assertEqual(str(abs(C)), \"[0, 11]\")\n\n        self.assertEqual(str(B.pow_cap(A, 1.5)), \"[6, 8]\")\n        self.assertEqual(str(A.union(B, C)), \"[-11, 9]\")\n        self.assertEqual(str(C.intersection(A * A)), \"[4, 5]\")\n        self.assertEqual(str(C.difference(-A,A)), \"[-11, -5] \u222a [-1, 1] \u222a {5}\")\n        self.assertEqual(A.is_subset(C), True)\n        self.assertEqual(B.is_subset(A + A), False)\n        self.assertEqual(A <= B, True)\n        self.assertEqual(A <= A + A, True)\n        self.assertEqual(C <= A + A, False)\n        self.assertEqual(A < B, True)\n        self.assertEqual(A < A + A, False)\n        self.assertEqual(A.bounded(5), True)\n        self.assertEqual(A.bounded(4), True)\n        self.assertEqual(A.bounded(3), False)\n        self.assertEqual(A.bounded(2,4), True)\n        self.assertEqual(A.restricted(), True)\n        self.assertEqual(IntegerSet(None).restricted(), False)\n        self.assertEqual(A.min(), 2)\n        self.assertEqual(A.max(), 4)\n        self.assertEqual(top(4).min(), -infinity)\n        self.assertEqual(top(4).max(), 4)\n\n        self.assertEqual(list(IntegerSet([5, 40]).stickelberger(2, [0])), [(5,), (2,), (2, 3), (13,), (17,), (3, 7), (2, 3), (2, 7), (29,), (3, 11), (37,), (2, 5)])\n        self.assertEqual(list(IntegerSet([3, 40]).stickelberger(2, [1])), [(3,), (2,), (7,), (2,), (11,), (3, 5), (19,), (2, 5), (23,), (2, 3), (31,), (5, 7), (3, 13), (2, 5)])\n        self.assertEqual(list(IntegerSet([200, 220]).stickelberger(3, [0])), [(2, 5), (3, 67), (2, 3, 17), (5, 41), (2, 13), (11, 19), (2, 53), (3, 71), (2, 3), (7, 31), (2, 5, 11)])\n\n        self.assertEqual(A.is_finite(), True)\n        self.assertEqual(IntegerSet(None).is_finite(), False)\n        self.assertEqual(top(4).is_finite(), False)\n        self.assertEqual(bottom(4).is_finite(), False)\n\n        X = [\n            (3, 150000), # 3\n            (4, 100000), # 4\n            ([5,14], 50000), # 7,8,11\n            (15, 1000), # 15\n            ([16,19], 15000), # 19\n            (20, 1000), # 20\n            ([21,23], 3000), # 23\n            (24, 1000), # 24\n            ([25,34], 5000), # 31\n            ([35,40], 1000), # 35,39,40\n            ([41,46], 15000), # 43\n            ([47, 59], 1000), # 47,51,52,55,56,59\n            ([60, 67], 10000), # 67\n            ([68, 120], 1000),\n            ([121, 159], 100),\n            ([160, 163], 5000), # 163\n            ([164, 702], 100), # 703 is the first missing\n        ]\n        self.assertEqual(A.bound_under(X), None)\n        self.assertEqual((A + A).bound_under(X), 50000)\n        self.assertEqual((A * B).bound_under(X), 1000)\n\n    def test_complete(self):\n        from lmfdb import db\n        for tup in [\n                (\"lfunc_search\", {\"rational\": True, \"degree\": 1, \"conductor\": {\"$lte\": 100}}, 'L-functions with degree 1 and conductor at most 2800'),\n                (\"maass_rigor\", {\"level\": 3, \"spectral_parameter\": {\"$lte\": 21}}, 'Maass forms with level 3 and spectral parameter at most 24.9526'),\n                (\"mf_newforms\", {'level': {'$gte': 4, '$lte': 12}, 'weight': {'$gte': 3, '$lte': 6}}, \"newforms with $Nk^2$ at most 4000\"),\n                (\"mf_newforms\", {'level': {'$gte': 24, '$lte': 100}, 'weight': {'$gte': 10, '$lte': 16}, 'char_orbit_index': 1}, \"newforms with trivial character and $Nk^2$ at most 40000\"),\n                (\"mf_newforms\", {'level': {'$gte': 12, '$lte': 20}, 'weight': {'$gte': 20, '$lte': 40}}, \"newforms with level $N$ at most 24 and $Nk^2$ at most 40000\"),\n                (\"mf_newforms\", {'level': {'$gte': 4, '$lte': 8}, 'weight': {'$gte': 60, '$lte': 100}}, \"newforms with level $N$ at most 10 and $Nk^2$ at most 100000\"),\n                (\"mf_newforms\", {'level': {'$gte': 96, '$lte': 100}, 'weight': {'$gte': 8, '$lte': 12}}, \"newforms with level at most 100 and weight at most 12\"),\n                (\"mf_newforms\", {'level': {'$gte': 37000, '$lte': 49000}, 'weight': 2, 'prim_orbit_index': 1}, \"newforms with trivial character, weight 2, and level at most 50000\"),\n                (\"mf_newforms\", {'level': 900001, 'weight': 2, 'char_order': 1}, \"newforms with trivial character, weight 2 and prime level at most a million\"),\n                (\"hmf_forms\", {'deg': 4, 'disc': {'$gte': 1, '$lte': 1200}, 'level_norm': {'$gte': 1, '$lte': 40}}, \"Hilbert modular forms over 4.4.725.1, 4.4.1125.1 of level norm at most 991\"),\n                (\"hmf_forms\", {'field_label': '3.3.1929.1', 'level_norm': {'$gte': 1, '$lte': 50}}, \"Hilbert modular forms over 3.3.1929.1 of level norm at most 53\"),\n                (\"bmf_forms\", {'field_disc': {'$gte': -12, '$lte': -3}, 'level_norm': {'$gte': 1, '$lte': 40000}}, \"Bianchi modular forms with level norm at most 50000 over imaginary quadratic fields with absolute discriminant in [3, 12]\"),\n                (\"ec_nfcurves\", {'field_label': '3.3.1929.1', 'conductor_norm': {'$gte': 1, '$lte': 50}}, \"elliptic curves with conductor norm at most 2059 over totally real cubic fields with discriminant 1957\"),\n                (\"nf_fields\", {'disc_abs': {'$gte': 1, '$lte': 10000}}, \"number fields with absolute discriminant at most 1656109\"),\n                (\"nf_fields\", {'degree': 3, 'r2': 0, 'disc_abs': {'$gte': 1, '$lte': 2000000}}, \"number fields with degree 3, signature [3,0], absolute discriminant at most 3375000\"),\n                (\"nf_fields\", {'degree': 1}, \"number fields with degree 1\"),\n                (\"nf_fields\", {'degree': 14, 'r2': 1, 'disc_sign': 1}, \"number fields with incompatible conditions: signature and discriminant\"),\n                (\"nf_fields\", {'degree': 2, 'r2': 1, 'class_number': 17}, \"number fields with signature [0,1], class number at most 100 (except 98)\"),\n                (\"nf_fields\", {'degree': 2, 'r2': 1, 'class_group': [2, 2, 2, 2, 2, 2, 2]}, \"number fields with signature [0,1], class group of exponent 2\", \"depends on GRH\"),\n                (\"nf_fields\", {'degree': 5, 'rd': {'$gte': 40, '$lte': 60}, 'grd': {'$gte': 20, '$lte': 30}}, \"number fields with incompatible conditions: root discriminant and Galois root discriminant\"),\n                (\"nf_fields\", {'degree': 2, 'rd': {'$gte': 30, '$lte': 40}, 'disc_abs': {'$gte': 10000, '$lte': 20000}}, \"number fields with absolute discriminant at most 1656109\"),\n                (\"nf_fields\", {'degree': 6, 'r2': 0, 'galois_label': '6T11', 'disc_abs': {'$gte': 1200000000, '$lte': 1800000000}}, \"number fields with degree 6, signature [6,0], Galois group 6T11, absolute discriminant at most 1838265625\"),\n                (\"nf_fields\", {'degree': 9, 'r2': 0, 'gal_is_abelian': True, 'disc_abs': {'$gte': 1, '$lte': 1900000000000000}}, \"number fields with degree 9, signature [9,0], Galois group 9T(1,2,6,7,17), absolute discriminant at most 1953125000000000\"),\n                (\"nf_fields\", {'degree': 6, 'disc_abs': 489631389843456}, \"number fields with degree 6, unramified outside {2,3,7}\"),\n                (\"nf_fields\", {'degree': 5, 'disc_abs': 4130513738895632747}, \"number fields with degree 5, unramified outside {107,131}\"),\n                (\"nf_fields\", {'degree': 5, 'disc_abs': 38602932139211521}, \"number fields with degree 5, unramified outside {107,131}\"),\n                (\"nf_fields\", {'degree': 7, 'galois_label': '7T1', 'disc_abs': 446132784330195495457232}, \"number fields with degree 7, Galois group 7T1, unramified outside {2,7,11,17,37,41}\"),\n                (\"nf_fields\", {'degree': 5, 'galois_label': '5T4', 'disc_abs': 920627786839041}, \"number fields with degree 5, Galois group 5T(1,2,4), unramified outside {3,1201}\"),\n                (\"nf_fields\", {'degree': 5, 'galois_label': '5T4', 'gal_is_abelian': True, 'disc_abs': 920627786839041}, \"number fields with incompatible conditions: Galois group\"),\n                (\"nf_fields\", {'degree': 5, 'galois_label': '5T4', 'disc_rad': 1254}, \"number fields with degree 5, Galois group 5T(1,2,4), unramified outside {2,3,11,19}\"),\n                (\"nf_fields\", {'degree': 8, 'galois_label': '8T25', 'rd': {'$gte': 1, '$lte': 100}}, \"number fields with degree 8, Galois group 8T(25,36), Galois root discriminant at most 200\"),\n                (\"artin_reps\", {'GaloisLabel': '6T6', 'Conductor': {'$gte': 1, '$lte': 20000}}, \"Artin representations with group 6T6, and conductor at most 22497\"),\n                (\"gps_groups\", {'order': {'$gte': 300, '$lte': 500}}, \"groups of order at most 2000 except orders larger than 500 that are multiples of 128\"),\n                (\"gps_groups\", {'perfect': True, 'order': {'$gte': 20000, '$lte': 40000}}, \"perfect groups of order at most 50000\"),\n                (\"gps_groups\", {'simple': True, 'abelian': False, 'order': {'$gte': 1, '$lte': 10000000}}, \"nonabelian simple groups of order less than 10162031880\"),\n                (\"gps_groups\", {'transitive_degree': {'$gte': 16, '$lte': 24}}, \"groups with minimal transitive degree at most 47 (except 32)\"),\n                (\"gps_groups\", {'transitive_degree': 32, 'order': {'$gte': 40000000000, '$lte': 100000000000}}, \"groups with minimal transitive degree 32 and order at least 40 billion\"),\n                (\"gps_groups\", {'permutation_degree': {'$gte': 10, '$lte': 14}}, \"groups with minimal permutation degree at most 15\"),\n                (\"gps_groups\", {'linQ_dim': 5}, r\"groups with linear $\\Q$-degree at most 6\"),\n                (\"ec_curvedata\", {'conductor': {'$gte': 300, '$lte': 3000}}, \"elliptic curves with conductor at most 500000\"),\n                (\"ec_curvedata\", {'conductor': 1000003}, \"elliptic curves with prime conductor at most 300 million\"),\n                (\"ec_curvedata\", {'conductor': 76204800}, \"elliptic curves with 7-smooth conductor\"),\n                (\"ec_curvedata\", {'absD': {'$gte': 50000, '$lte': 100000}}, \"elliptic curves with minimal discriminant at most 500000\"),\n                (\"hgcwa_passports\", {'genus': 3}, \"groups acting as automorphisms of curves of genus 2, 3 or 4\"),\n                (\"hgcwa_passports\", {'genus': 11, 'g0': 0}, \"groups G acting as automorphisms of curves X with the genus of X at most 15 and the genus of X/G equal to 0\"),\n                (\"av_fq_isog\", {'g': 1, 'q': 729}, \"isogeny classes of elliptic curves over fields of cardinality less than 500 or 512, 625, 729, 1024\"),\n                (\"av_fq_isog\", {'g': {'$gte': 2, '$lte': 4}, 'q': {'$gte': 2, '$lte': 4}}, \"isogeny classes of abelian varieties of dimension at most 4 over fields of cardinality at most 5\"),\n                (\"av_fq_isog\", {'q': 3, 'p_rank': 2, 'p_rank_deficit': 2}, \"isogeny classes of abelian varieties of dimension at most 4 over fields of cardinality at most 5\"),\n                (\"belyi_galmaps\", {'deg': {'$gte': 2, '$lte': 4}}, \"Belyi maps of degree at most 6\"),\n                (\"lf_fields\", {'p': 2, 'n': 16}, \"p-adic fields of degree at most 23 and residue characteristic at most 199\"),\n                (\"lf_fields\", {'p': 3, 'e': 9, 'f': 2}, \"p-adic fields of degree at most 23 and residue characteristic at most 199\"),\n                (\"lf_families\", {'p': 2, 'e': 4, 'f0': {'$gte': 1, '$lte': 2}, 'e0': 2, 'f': 2}, \"families of p-adic extensions with absolute degree at most 47, base degree at most 15 and residue characteristic at most 199\"),\n                (\"char_dirichlet\", {'modulus': {'$gte': 40, '$lte': 100}}, \"Dirichlet characters with modulus at most a million\"),\n                (\"hgm_families\", {'degree': {'$gte': 4, '$lte': 6}}, \"hypergeometric families with degree at most 7\"),\n                (\"gps_transitive\", {'n': 18, 'solv': 1}, \"transitive groups of degree at most 47 (except 32)\"),\n                (\"gps_transitive\", {'n': 32, 'order': 384}, \"transitive groups of degree 32 and order at most 511\"),\n                (\"gps_transitive\", {'n': 32, 'order': {'$gte': 40000000000, '$lte': 100000000000}}, \"transitive groups of degree at most 47 and order at least 40 billion\"),\n                (\"gps_st\", {'rational': True, 'weight': 1, 'degree': {'$gte': 3, '$lte': 5}}, \"rational Sato-Tate groups of weight at most 1 and degree at most 6\"),\n                (\"gps_st\", {'rational': True, 'weight': 0, 'degree': 1}, \"rational Sato-Tate groups of weight 0 and degree 1\"),\n                (\"gps_st\", {'weight': 0, 'degree': 1, 'components': {'$gte': 40, '$lte': 50}}, \"Sato-Tate groups of weight 0, degree 1 and at most 10000 components\"),\n        ]:\n            if len(tup) == 3:\n                tbl, query, reason = tup\n                caveat = None\n            else:\n                tbl, query, reason, caveat = tup\n            self.assertEqual(results_complete(tbl, query, db), (True, reason, caveat))\n\n        for tbl, query in [\n                (\"maass_rigor\", {\"level\": {\"$gte\":2, \"$lte\": 5}, \"spectral_parameter\": {\"$lte\": 21}}),\n                (\"mf_newforms\", {'level': {'$gte': 100, '$lte': 200}, 'weight': {'$gte': 20, '$lte': 30}}),\n                (\"hmf_forms\", {'deg': 7, 'disc': {'$gte': 1, '$lte': 1200}, 'level_norm': {'$gte': 1, '$lte': 40}}),\n                (\"bmf_forms\", {'field_disc': {'$gte': -120, '$lte': -3}, 'level_norm': {'$gte': 1, '$lte': 4000}}),\n                (\"ec_nfcurves\", {'field_label': '7.7.20134393.1', 'conductor_norm': {'$gte': 1, '$lte': 50}}),\n                (\"nf_fields\", {'degree': 6, 'disc_abs': {'$gte': 1, '$lte': 20000000}}),\n                (\"artin_reps\", {'GaloisLabel': '8T34', 'Conductor': {'$gte': 1, '$lte': 200}}),\n                (\"gps_groups\", {'order': {'$gte': 300, '$lte': 600}}),\n                (\"ec_curvedata\", {'rank': 6}),\n                (\"hgcwa_passports\", {'genus': 6}),\n                (\"av_fq_isog\", {'g': 6, 'q': 3}),\n                (\"belyi_galmaps\", {'deg': 8}),\n                (\"lf_fields\", {'p': 2, 'n': 24}),\n                (\"lf_families\", {'p': 2, 'e': 4, 'f0': {'$gte': 1, '$lte': 4}, 'e0': 2, 'f': 2}),\n                (\"char_dirichlet\", {'modulus': {'$gte': 400000, '$lte': 3000000}}),\n                (\"hgm_families\", {'degree': 8}),\n                (\"gps_transitive\", {'n': 32, 'solv': 1}),\n                (\"gps_st\", {'rational': True, 'weight': 1, 'degree': 8}),\n        ]:\n            self.assertEqual(results_complete(tbl, query, db)[0], False)"
  },
  {
    "type": "class",
    "file": "lmfdb/classical_modular_forms/test_cmf2.py",
    "name": "CmfTest",
    "line_start": 8,
    "line_end": 394,
    "lines": 387,
    "bytes": 23612,
    "has_71": true,
    "code": "class CmfTest(LmfdbTest):\n    def runTest(self):\n        pass\n\n    def test_download_qexp(self):\n        for label, exp in [\n                ['11.7.b.a', '[0, 10, 64]'],\n                ['11.2.a.a', '[-2, -1, 2]'],\n                ['21.2.g.a', '[0, -a - 1, 2*a - 2]'],\n                ['59.2.a.a', '[-a^4 + 7*a^2 + 3*a - 5, a^4 - a^3 - 6*a^2 + 2*a + 3, a^3 - a^2 - 4*a + 3]'],\n                ['13.2.e.a', '[-a - 1, 2*a - 2, a]'],\n                ['340.1.ba.b', '[z, 0, z^2]'],\n                ['24.3.h.a', '[-2, 3, 4]'],\n                ['24.3.h.c', '[a, -1/4*a^3 - a^2 - 1/2*a - 3, a^2]'],\n                ]:\n            sage_code = self.tc.get('/ModularForm/GL2/Q/holomorphic/download_qexp/%s' % label, follow_redirects=True).get_data(as_text=True)\n            assert \"make_data\" in sage_code\n            assert \"aps_data\" in sage_code\n            sage_code += \"\\n\\nout = str(make_data().list()[2:5])\\n\"\n            out = self.check_sage_compiles_and_extract_var(sage_code, 'out')\n            assert str(out) == exp\n        for label in ['212.2.k.a', '887.2.a.b']:\n            page = self.tc.get('/ModularForm/GL2/Q/holomorphic/download_qexp/{}'.format(label), follow_redirects=True)\n            assert 'q-expansion not available for newform {}'.format(label) in page.get_data(as_text=True)\n\n        # Test invalid labels return 404 with proper error message\n        for label in ['safeboating', 'invalid.label', '11.2.a', '11.2.a.a.extra']:\n            page = self.tc.get('/ModularForm/GL2/Q/holomorphic/download_qexp/{}'.format(label), follow_redirects=True)\n            assert 'Invalid label: {}'.format(label) in page.get_data(as_text=True)\n\n    def test_download(self):\n        r\"\"\"\n        Test download function\n        \"\"\"\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/download_traces/23.10', follow_redirects=True)\n        assert '[0, 187, -11, -11, -11, -11, -11, -11, -11, -11, -11, -11, -11, -11, -11, 969023, -478731' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/download_traces/1161.1.i', follow_redirects=True)\n        assert '[0, 14, 0, 0, -2, 0, 0, 0, 0, 0, -2, 0, 0, 1, 0, 0, -10, 0, 0, 1, 0, 0' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/download_traces/1161.1.i.maria.josefina', follow_redirects=True)\n        assert 'Invalid label' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/download_traces/4021.2.mz', follow_redirects=True)\n        assert 'Label not found:' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/download_traces/4021.2.c', follow_redirects=True)\n        assert 'We have not computed traces for' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/download_traces/27.2.e.a', follow_redirects=True)\n        assert '[0, 12, -6, -6, -6, -3, 0, -6, 6, 0, -3, 3, 12, -6, 15, 9, 0, 9, 9, -3, -3, -12, 3, -12, -18, 3, -30' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/download_newform/27.2.e.a', follow_redirects=True)\n        assert '\"analytic_rank_proved\": true' in page.get_data(as_text=True)\n        assert '[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]' in page.get_data(as_text=True) # a1 (make sure qexp is there)\n        assert '[1, 1, 27, 5, 1, 9, 0]' in page.get_data(as_text=True) # non-trivial inner twist\n        assert '[0, 12, -6, -6, -6, -3, 0, -6, 6, 0, -3, 3, 12, -6, 15, 9, 0, 9, 9, -3, -3, -12, 3, -12, -18, 3, -30' in page.get_data(as_text=True)\n        assert '1.2.3.c9' in page.get_data(as_text=True) # Sato-Tate group\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/download_full_space/20.5', follow_redirects=True)\n        assert r\"\"\"[\"20.5.b.a\", \"20.5.d.a\", \"20.5.d.b\", \"20.5.d.c\", \"20.5.f.a\"]\"\"\" in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/download_newspace/244.4.w')\n        assert \"[1456, -16, 0, -14, -28, 64, 0, -16, -3156, 168, 0, 36, -108\" in page.get_data(as_text=True)\n        assert \"244.4.w\" in page.get_data(as_text=True)\n\n    def test_download_magma(self):\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/download_newform_to_magma/23.1.b.a.z')\n        assert 'Label not found' in page.get_data(as_text=True)\n\n        # test MakeNewformModFrm\n        for label, expected in [\n                ['11.2.a.a',\n                    'q - 2*q^2 - q^3 + 2*q^4 + q^5 + 2*q^6 - 2*q^7 - 2*q^9 - 2*q^10 + q^11 + O(q^12)'],\n                ['21.2.g.a',\n                    'q + (-nu - 1)*q^3 + (2*nu - 2)*q^4 + (-3*nu + 2)*q^7 + 3*nu*q^9 + O(q^12)'],\n                ['59.2.a.a',\n                    'q + (-nu^4 + 7*nu^2 + 3*nu - 5)*q^2 + (nu^4 - nu^3 - 6*nu^2 + 2*nu + 3)*q^3 + (nu^3 - nu^2 - 4*nu + 3)*q^4 + (nu^4 - 6*nu^2 - 4*nu + 3)*q^5 + (-3*nu^4 + 2*nu^3 + 17*nu^2 - 3*nu - 7)*q^6 + (-nu^2 + 3)*q^7 + (3*nu^4 - 2*nu^3 - 17*nu^2 + 3*nu + 5)*q^8 + (2*nu^4 - 13*nu^2 - 4*nu + 8)*q^9 + (3*nu^4 - 2*nu^3 - 17*nu^2 + nu + 5)*q^10 + (-4*nu^4 + 2*nu^3 + 24*nu^2 + 2*nu - 12)*q^11 + O(q^12)'],\n                ['13.2.e.a',\n                    'q + (-nu - 1)*q^2 + (2*nu - 2)*q^3 + nu*q^4 + (-2*nu + 1)*q^5 + (-2*nu + 4)*q^6 + (2*nu - 1)*q^8 - nu*q^9 + (3*nu - 3)*q^10 + O(q^12)'],\n                ['340.1.ba.b',\n                    'q + zeta_8*q^2 + zeta_8^2*q^4 - zeta_8^3*q^5 + zeta_8^3*q^8 - zeta_8*q^9 + q^10 + O(q^12)'],\n                ['24.3.h.a',\n                    'q - 2*q^2 + 3*q^3 + 4*q^4 + 2*q^5 - 6*q^6 - 10*q^7 - 8*q^8 + 9*q^9 - 4*q^10 - 10*q^11 + O(q^12)'],\n                ['24.3.h.c',\n                    'q + nu*q^2 + 1/4*(-nu^3 - 4*nu^2 - 2*nu - 12)*q^3 + nu^2*q^4 + (nu^3 + 2*nu)*q^5 + (-nu^3 + nu^2 - 3*nu + 4)*q^6 + 4*q^7 + nu^3*q^8 + 1/2*(-nu^3 - 10*nu - 10)*q^9 + (-4*nu^2 - 16)*q^10 + 1/2*(-3*nu^3 - 6*nu)*q^11 + O(q^12)'],\n                ['87.2.a.a',\n                    'q + nu*q^2 + q^3 + (nu - 1)*q^4 + (-2*nu + 2)*q^5 + nu*q^6 + (-2*nu - 1)*q^7 + (-2*nu + 1)*q^8 + q^9 - 2*q^10 + (2*nu + 1)*q^11 + O(q^12)'],\n                ]:\n            page = self.tc.get('/ModularForm/GL2/Q/holomorphic/download_newform_to_magma/%s' % label)\n            makenewform = 'MakeNewformModFrm_%s_%s_%s_%s' % tuple(label.split('.'))\n            assert makenewform in page.get_data(as_text=True)\n            magma_code = page.get_data(as_text=True) + '\\n' + '%s();\\n' % makenewform\n            self.assert_if_magma(expected, magma_code, mode='equal')\n\n        for label, expected in [['24.3.h.a',\n                    'Modular symbols space of level 24, weight 3, character Kronecker character -24, and dimension 1 over Rational Field'],\n                ['24.3.h.c',\n                    'Modular symbols space of level 24, weight 3, character Kronecker character -24, and dimension 4 over Rational Field'],\n                ['54.2.e.a',\n                    'Modular symbols space of level 54, weight 2, character $.1^16, and dimension 1 over Cyclotomic Field of order 9 and degree 6'],\n                ['54.2.e.b',\n                    'Modular symbols space of level 54, weight 2, character $.1^16, and dimension 2 over Cyclotomic Field of order 9 and degree 6'\n                    ],\n                ['87.2.a.a',\n                    'Modular symbols space for Gamma_0(87) of weight 2 and dimension 2 over Rational Field'\n                    ],\n                ['212.2.k.a',\n                    'Modular symbols space of level 212, weight 2, character $.1*$.2^17, and dimension 1 over Cyclotomic Field of order 52 and degree 24'\n                    ],\n                ]:\n            page = self.tc.get('/ModularForm/GL2/Q/holomorphic/download_newform_to_magma/%s' % label)\n            makenewform = 'MakeNewformModSym_%s_%s_%s_%s' % tuple(label.split('.'))\n            assert makenewform in page.get_data(as_text=True)\n            magma_code = page.get_data(as_text=True) + '\\n' + '%s();\\n' % makenewform\n            self.assert_if_magma(expected, magma_code, mode='equal')\n\n    def test_expression_level(self):\n        # checks we can search on 2*7^2\n        self.check_args('/ModularForm/GL2/Q/holomorphic/?level=2*7%5E2', '98.2.a.a')\n\n    def test_download_search(self):\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?Submit=sage&download=1&query=%7B%27level_radical%27%3A+5%2C+%27dim%27%3A+%7B%27%24lte%27%3A+10%2C+%27%24gte%27%3A+1%7D%2C+%27weight%27%3A+10%7D&search_type=Traces', follow_redirects=True)\n        assert '5.10.a.a' in page.get_data(as_text=True)\n        assert '1, -8, -114, -448, -625, 912, 4242, 7680, -6687, 5000, -46208, 51072, -115934, -33936' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?Submit=sage&download=1&query=%7B%27level_radical%27%3A+5%2C+%27dim%27%3A+%7B%27%24lte%27%3A+10%2C+%27%24gte%27%3A+1%7D%2C+%27weight%27%3A+10%7D', follow_redirects=True)\n        txt = page.get_data(as_text=True)\n        assert '5.10.a.a' in txt\n        assert r'[\"5.10.a.a\", 1, 2.5751791808193656, \"1.1.1.1\", [], [-8, -114, -625, 4242], 1, \"q-8q^{2}-114q^{3}-448q^{4}-5^{4}q^{5}+\\\\cdots\"]' in txt or '[\"5.10.a.a\", 1, 2.57517918082, \"1.1.1.1\", [], [-8, -114, -625, 4242], 1, \"q-8q^{2}-114q^{3}-448q^{4}-5^{4}q^{5}+\\\\cdots\"]' in txt\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?Submit=gp&download=1&query=%7B%27num_forms%27%3A+%7B%27%24gte%27%3A+1%7D%2C+%27weight%27%3A+5%2C+%27level%27%3A+20%7D&search_type=Spaces')\n        for elt in [\"20.5.b\", \"20.5.d\", \"20.5.f\"]:\n            assert elt in page.get_data(as_text=True)\n\n    def test_random(self):\n        r\"\"\"\n        Test that we don't hit any error on a random newform\n        \"\"\"\n        def check(page):\n            assert 'Newspace' in page.get_data(as_text=True), page.url\n            assert 'parameters' in page.get_data(as_text=True), page.url\n            assert 'Properties' in page.get_data(as_text=True), page.url\n            assert 'Newform' in page.get_data(as_text=True), page.url\n            assert 'expansion' in page.get_data(as_text=True), page.url\n        for i in range(100):\n            page = self.tc.get('/ModularForm/GL2/Q/holomorphic/random', follow_redirects=True)\n            check(page)\n\n        for w in ('1', '2', '3', '4', '5', '6-10', '11-20', '21-40', '41-'):\n            page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?weight=%s&search_type=Random' % w, follow_redirects=True)\n            check(page)\n            page = self.tc.get('/ModularForm/GL2/Q/holomorphic/random?weight=%s' % w, follow_redirects=True)\n            check(page)\n\n        for l in ('1', '2-100', '101-500', '501-1000', '1001-2000', '2001-'):\n            page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=%s&search_type=Random' % l, follow_redirects=True)\n            check(page)\n            page = self.tc.get('/ModularForm/GL2/Q/holomorphic/random?level=%s' % l, follow_redirects=True)\n            check(page)\n\n    def test_dimension(self):\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=10&weight=1-14&dim=1', follow_redirects=True)\n        assert \"14 matches\" in page.get_data(as_text=True)\n        assert 'A-L signs' in page.get_data(as_text=True)\n\n    def test_traces(self):\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=244&weight=4&count=50&search_type=Traces', follow_redirects=True)\n        assert \"Results (18 matches)\" in page.get_data(as_text=True)\n        for elt in map(str,[-98,-347,739,0,147,-414,324,306,-144,0,24,-204,153,414,-344,-756,-24,164]):\n            assert elt in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=244&weight=4&search_type=Traces&n=1-40&n_primality=prime_powers&an_constraints=a3%3D0%2Ca37%3D0', follow_redirects=True)\n        assert \"Results (3 matches)\" in page.get_data(as_text=True)\n        for elt in map(str,[-6,-68, 3224, 206, 4240, -408, -598, 1058]):\n            assert elt in page.get_data(as_text=True)\n\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?weight_parity=odd&level=7&weight=7&search_type=Traces&n=1-10&n_primality=all\")\n        assert \"Results (4 matches)\" in page.get_data(as_text=True)\n        for elt in map(str,[17,0,-80,60,3780,-1200]):\n            assert elt in page.get_data(as_text=True)\n\n    def test_trivial_searches(self):\n        from sage.all import Subsets\n        for begin in [\n                ('level=10&weight=1-20&dim=1',\n                    ['Results (21 matches)', '171901114', 'No', '10.723', 'A-L signs']\n                    ),\n                ('level=10%2C13%2C17&weight=1-8&dim=1',\n                    ['Results (12 matches)', '1373', 'No', '0.136']\n                    )]:\n            for s in Subsets(['has_self_twist=no', 'is_self_dual=yes', 'nf_label=1.1.1.1','char_order=1','inner_twist_count=1']):\n                s = '&'.join(['/ModularForm/GL2/Q/holomorphic/?search_type=List', begin[0]] + list(s))\n                page = self.tc.get(s, follow_redirects=True)\n                for elt in begin[1]:\n                    assert elt in page.get_data(as_text=True), s\n\n        for begin in [\n                ('level=1-330&weight=1&projective_image=D2',\n                    ['Results (49 matches)',\n                        '328.1.c.a', r\"\\sqrt{-82}\", r\"\\sqrt{-323}\", r\"\\sqrt{109}\"]\n                    ),\n                ('level=900-1000&weight=1-&projective_image=D2',\n                    ['Results (26 matches)', r\"\\sqrt{-1}\", r\"\\sqrt{-995}\", r\"\\sqrt{137}\"]\n                    )]:\n            for s in Subsets(['has_self_twist=yes', 'has_self_twist=cm', 'has_self_twist=rm', 'projective_image=Dn','dim=1-4']):\n                s = '&'.join(['/ModularForm/GL2/Q/holomorphic/?search_type=List', begin[0]] + list(s))\n                page = self.tc.get(s, follow_redirects=True)\n                for elt in begin[1]:\n                    assert elt in page.get_data(as_text=True), s\n\n    def test_parity(self):\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?weight_parity=even&char_parity=even')\n        assert '11.2.a.a' in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?weight_parity=odd&char_parity=odd')\n        assert '23.1.b.a' in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?weight_parity=even&char_parity=even&weight=3')\n        assert \"No matches\" in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?weight_parity=even&char_parity=odd')\n\n    def test_coefficient_fields(self):\n        r\"\"\"\n        Test the display of coefficient fields.\n        \"\"\"\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/9/8/a/')\n        assert r'\\Q(\\sqrt{10})' in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/11/6/a/')\n        assert '3.3.54492.1' in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/27/2/e/a/')\n        assert '12.0.1952986685049.1' in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=1-500&weight=2&nf_label=16.0.1048576000000000000.1&prime_quantifier=subsets')\n        assert r'\\zeta_{40}' in page.get_data(as_text=True)\n        assert \"Results (6 matches)\" in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=1-4000&weight=1&nf_label=9.9.16983563041.1&prime_quantifier=subsets&projective_image=D19')\n        assert r\"Q(\\zeta_{38})^+\" in page.get_data(as_text=True)\n        assert \"Results (32 matches)\" in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=1-100&weight=2&dim=4&nf_label=4.0.576.2&prime_quantifier=subsets')\n        assert 'Results (7 matches)' in page.get_data(as_text=True)\n        assert r'\\Q(\\sqrt{2}, \\sqrt{-3})' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?dim=8&char_order=20&cm=no&rm=no')\n        assert \"Results (17 matches)\" in page.get_data(as_text=True)\n        assert r\"Q(\\zeta_{20})\" in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=1-4000&weight=1&dim=116')\n        assert \"Results (displaying both matches)\" in page.get_data(as_text=True)\n        assert r\"Q(\\zeta_{177})\" in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=1-100&weight=2&dim=4&nf_label=4.0.576.2&prime_quantifier=subsets')\n        assert 'Results (7 matches)' in page.get_data(as_text=True)\n        assert r'\\Q(\\sqrt{2}, \\sqrt{-3})' in page.get_data(as_text=True)\n\n    def test_inner_twist(self):\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/3992/1/ba/a/')\n        assert \"499.g\" in page.get_data(as_text=True)\n        assert \"3992.ba\" in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/190/2/i/a/')\n        for elt in ['5.b', '19.c', '95.i']:\n            assert elt in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/1816/1/l/a/')\n        for elt in ['227.c','1816.l']:\n            assert elt in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/2955/1/c/e/')\n        for elt in ['3.b','5.b','197.b','2955.c']:\n            assert elt in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/52/18/a/a/')\n        assert \"This newform does not admit any (\" in page.get_data(as_text=True)\n        assert \"nontrivial\" in page.get_data(as_text=True)\n        assert \"inner twist\" in page.get_data(as_text=True)\n\n    def test_self_twist(self):\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/2955/1/c/e/')\n        for elt in [r'\\Q(\\sqrt{-591})', r'\\Q(\\sqrt{-15})', r'\\Q(\\sqrt{985})']:\n            assert elt in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/1124/1/d/a/')\n        for elt in [r'\\Q(\\sqrt{-281})', r'\\Q(\\sqrt{-1})', r'\\Q(\\sqrt{281})']:\n            assert elt in page.get_data(as_text=True)\n\n    def test_selft_twist_disc(self):\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=1-40&weight=1-6&self_twist_discs=-3')\n        for elt in [r'\\Q(\\sqrt{-39})', r'\\Q(\\sqrt{-3})']:\n            assert elt in page.get_data(as_text=True)\n        assert 'Results (22 matches)' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=1-100&self_twist_discs=5')\n        for elt in [-55,-11,5,-5,-1,-95,-19]:\n            assert (r'\\Q(\\sqrt{%d})' % elt) in page.get_data(as_text=True)\n        assert 'Results (3 matches)' in page.get_data(as_text=True)\n        for d in [3,-5]:\n            page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=1-100&self_twist_discs=%d' % d)\n            assert 'is not a valid input for' in page.get_data(as_text=True)\n\n    def test_projective(self):\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/2955/1/c/e/')\n        assert 'D_{2}' in page.get_data(as_text=True)\n        assert r'\\Q(\\sqrt{-15}, \\sqrt{-591})' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/1124/1/d/a/')\n        assert 'D_{2}' in page.get_data(as_text=True)\n        assert r'\\Q(i, \\sqrt{281})' in page.get_data(as_text=True)\n\n    def test_artin(self):\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/2955/1/c/e/')\n        assert 'Artin representation 2.3_5_197.8t11.1' in page.get_data(as_text=True)\n        assert 'D_4:C_2' in page.get_data(as_text=True)\n        assert '8.0.1964705625.1' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/1124/1/d/a/')\n        assert 'Artin representation 2.2e2_281.4t3.2' in page.get_data(as_text=True)\n        assert '4.0.4496.1' in page.get_data(as_text=True)\n        assert 'D_4' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/124/1/i/a/67/1/')\n        assert 'Artin representation 2.2e2_31.16t60.1c3' in page.get_data(as_text=True)\n        assert 'SL(2,3):C_2' in page.get_data(as_text=True)\n        assert '4.0.15376.1' in page.get_data(as_text=True)\n\n    def test_AL_search(self):\n        r\"\"\"\n        Test that we display AL eigenvals/signs\n        \"\"\"\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=15&char_order=1', follow_redirects=True)\n        assert 'A-L signs' in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=15&search_type=Spaces', follow_redirects=True)\n        assert 'AL-decomposition.' in page.get_data(as_text=True)\n        assert r'$0$+$1$+$0$+$0$' in page.get_data(as_text=True)\n\n    def test_Fricke_signs_search(self):\n        r\"\"\"\n        Test that we display Fricke signs\n        \"\"\"\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=15%2C20&weight=2&dim=1', follow_redirects=True)\n        assert 'Fricke sign' in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?char_order=1', follow_redirects=True)\n        assert 'Fricke sign' in page.get_data(as_text=True)\n\n    def displaying_weight1_search(self):\n        for typ in ['List', 'Traces', 'Dimensions']:\n            for search in ['weight=1', 'rm_discs=5','has_self_twist=rm','cm_discs=-3%2C+-39']:\n                page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?%s&search_type=%s' % (search, typ), follow_redirects=True)\n                assert 'Only for weight 1:' in page.get_data(as_text=True)\n\n    def test_is_self_dual(self):\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?is_self_dual=yes', follow_redirects=True)\n        for elt in ['23.1.b.a', '31.1.b.a', '111.1.d.a']:\n            assert elt in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?is_self_dual=no', follow_redirects=True)\n        for elt in ['52.1.j.a', '57.1.h.a', '111.1.h.a']:\n            assert elt in page.get_data(as_text=True)\n\n    def test_hecke_charpolys(self):\n        \"\"\"Test that the Hecke charpolys are correct.\n\n        Some expected Hecke charpolys are stored in the dict test_data,\n        which are then checked to be in the relevant page. These examples\n        have been chosen to be readily verifiable from the displayed\n        Fourier coefficients of each respective homepage.\"\"\"\n\n        test_data = {# Dimension 1\n                    '11/2/a/a': {2: r'\\( T + 2 \\)',\n                                 17: r'\\( T + 2 \\)',\n                                 29: r'\\( T \\)'},\n\n                    # Dimension 2\n                    '10/3/c/a': {5: r'\\( T^{2} + 25 \\)',\n                                 11: r'\\( (T + 8)^{2} \\)',\n                                 97: r'\\( T^{2} + 126T + 7938 \\)'},\n\n                    # Dimension 5\n                    '294/5/b/f': {2: r'\\( (T^{2} + 8)^{5} \\)',\n                                    # The following test checks that monomials do not have superfluous parentheses\n                                    7: r'\\( T^{10} \\)'},\n                    }\n\n        for label, some_expected_charpolys in test_data.items():\n            page_as_text = self.tc.get('/ModularForm/GL2/Q/holomorphic/{}/'.format(label), follow_redirects=True).get_data(as_text=True)\n            for _, expected_pth_charpoly in some_expected_charpolys.items():\n                assert expected_pth_charpoly in page_as_text\n\n        # Check large dimensions behave as we expect. The following is a form of dimension 108\n\n        large_dimension_page_as_text = self.tc.get('/ModularForm/GL2/Q/holomorphic/671/2/i/a/', follow_redirects=True).get_data(as_text=True)\n        assert \"Hecke characteristic polynomials\" not in large_dimension_page_as_text"
  },
  {
    "type": "function",
    "file": "lmfdb/ecnf/WebEllipticCurve.py",
    "name": "make_E",
    "line_start": 339,
    "line_end": 877,
    "lines": 539,
    "bytes": 25002,
    "has_71": true,
    "code": "    def make_E(self):\n        #print(\"Creating ECNF object for {}\".format(self.label))\n        #sys.stdout.flush()\n        K = self.field.K()\n        Kgen = str(K.gen())\n\n        # a-invariants\n        # NB Here we construct the ai as elements of K, which are used as follows:\n        # (1) to compute the model discriminant (if not stored)\n        # (2) to compute the latex equation (if not stored)\n        # (3) to compute the plots under real embeddings of K\n        # Of these, (2) is not needed and (1) will soon be obsolete;\n        #  for (3) it would be possible to rewrite the function EC_nf_plot() not to need this.\n        # Then we might also be able to avoid constructing the field K also.\n\n        self.ainvs = parse_ainvs(K,self.ainvs)\n        self.numb = str(self.number)\n\n        # Conductor, discriminant, j-invariant\n\n        self.cond_norm = web_latex(self.conductor_norm)\n\n        Dnorm = self.normdisc\n        self.model_disc = self.disc.replace('w', Kgen).replace(\"*\",\"\").replace(\"(\",\"\").replace(\")\",\"\")\n        if Kgen == 'phi':\n            self.model_disc = self.model_disc.replace(Kgen, r\"\\phi\")\n        self.disc = pretty_ideal(Kgen, self.disc)\n\n        local_data = self.local_data\n        local_data.sort(key=lambda ld: ld['normp'])\n\n        badprimes = [pretty_ideal(Kgen, ld['p'], enclose=False) for ld in local_data]\n        badnorms = [ld['normp'] for ld in local_data]\n        disc_ords = [ld['ord_disc'] for ld in local_data]\n        mindisc_ords = [ld['ord_disc'] for ld in local_data]\n        cond_ords = [ld['ord_cond'] for ld in local_data]\n\n        if self.conductor_norm == 1:\n            self.cond = r\"\\((1)\\)\"\n            self.fact_cond = self.cond\n            self.fact_cond_norm = '1'\n        else:\n            self.cond = pretty_ideal(Kgen, self.conductor_ideal)\n            self.fact_cond = latex_factorization(badprimes, cond_ords)\n            self.fact_cond_norm = latex_factorization(badnorms, cond_ords)\n\n        # Assumption: the curve models stored in the database are\n        # either global minimal models or minimal at all but one\n        # prime, so the list here has length 0 or 1:\n\n        self.is_minimal = (len(self.non_min_p) == 0)\n        self.has_minimal_model = self.is_minimal\n\n        if not self.is_minimal:\n            non_min_p = self.non_min_p[0]\n            self.non_min_prime = pretty_ideal(Kgen, non_min_p)\n            ip = [ld['p'] for ld in local_data].index(non_min_p)\n            disc_ords[ip] += 12\n            Dnorm_factor = local_data[ip]['normp']**12\n\n        self.disc_norm = web_latex(Dnorm)\n        signDnorm = 1 if Dnorm > 0 else -1\n        if Dnorm in [1, -1]:  # since the factorization of (1) displays as \"1\"\n            self.fact_disc = self.disc\n            self.fact_disc_norm = str(Dnorm)\n        else:\n            self.fact_disc = latex_factorization(badprimes, disc_ords)\n            self.fact_disc_norm = latex_factorization(badnorms, disc_ords, sign=signDnorm)\n\n        if self.is_minimal:\n            Dmin_norm = Dnorm\n            self.mindisc = self.disc\n        else:\n            Dmin_norm = Dnorm // Dnorm_factor\n            self.mindisc = pretty_ideal(Kgen, self.minD)\n\n        self.mindisc_norm = web_latex(Dmin_norm)\n        if Dmin_norm in [1,-1]:  # since the factorization of (1) displays as \"1\"\n            self.fact_mindisc = self.mindisc\n            self.fact_mindisc_norm = self.mindisc_norm\n        else:\n            self.fact_mindisc = latex_factorization(badprimes, mindisc_ords)\n            self.fact_mindisc_norm = latex_factorization(badnorms, mindisc_ords, sign=signDnorm)\n\n        j = self.field.parse_NFelt(self.jinv)\n        self.j = web_latex(j)\n        self.fact_j = None\n        # See issue 1258: some j factorizations work but take too long\n        # (e.g. EllipticCurve/6.6.371293.1/1.1/a/1).  Note that we do\n        # store the factorization of the denominator of j and display\n        # that, which is the most interesting part.\n\n        # When the equation is stored in the database as a latex string,\n        # it may have extraneous double quotes at beginning and\n        # end, which we fix here.  We also strip out initial \\( and \\)\n        # (if present) which are added in the template.\n        try:\n            self.equation = self.equation.replace('\"','').replace(r'\\\\(','').replace(r'\\\\)','')\n        except AttributeError:\n            self.equation = latex_equation(self.ainvs)\n\n        # Images of Galois representations\n\n        if not hasattr(self,'galois_images'):\n            #print \"No Galois image data\"\n            self.galois_images = \"?\"\n            self.nonmax_primes = \"?\"\n            self.galois_data = []\n        else:\n            self.galois_data = [{'p': p,'image': im }\n                                for p,im in zip(self.nonmax_primes,\n                                                self.galois_images)]\n\n        # CM and End(E)\n        self.cm_bool = \"no\"\n        self.End = r\"\\(\\Z\\)\"\n        self.rational_cm = self.cm_type > 0\n        if self.cm:\n            self.cm_sqf = integer_squarefree_part(ZZ(self.cm))\n            self.cm_bool = r\"yes (\\(%s\\))\" % self.cm\n            if self.cm % 4 == 0:\n                d4 = ZZ(self.cm) // 4\n                self.End = r\"\\(\\Z[\\sqrt{%s}]\\)\" % (d4)\n            else:\n                self.End = r\"\\(\\Z[(1+\\sqrt{%s})/2]\\)\" % self.cm\n\n        # Galois images in CM case:\n        if self.cm and self.galois_images != '?':\n            self.cm_ramp = [p for p in ZZ(self.cm).support() if p not in self.nonmax_primes]\n            self.cm_nramp = len(self.cm_ramp)\n            if self.cm_nramp == 1:\n                self.cm_ramp = self.cm_ramp[0]\n            else:\n                self.cm_ramp = \", \".join(str(p) for p in self.cm_ramp)\n\n        # Sato-Tate:\n        self.ST = st_display_knowl('1.2.A.1.1a' if not self.cm_type else ('1.2.B.2.1a' if self.cm_type < 0 else '1.2.B.1.1a'))\n\n        # Q-curve / Base change\n        try:\n            qc = self.q_curve\n            if qc is True:\n                self.qc = \"yes\"\n            elif qc is False:\n                self.qc = \"no\"\n            else: # just in case\n                self.qc = \"not determined\"\n        except AttributeError:\n            self.qc = \"not determined\"\n\n        # Mordell-Weil group\n        try:\n            invs = [0 for a in range(self.rank)] + list(self.torsion_structure)\n            self.mw_struct = \"trivial\" if len(invs) == 0 else r'\\(' + r' \\oplus '.join((r'\\Z' if n == 0 else r'\\Z/{%s}\\Z' % n) for n in invs) + r'\\)'\n        except AttributeError: # if self.rank not set\n            self.mw_struct = \"unknown\"\n\n        # Torsion\n        BSDntors = self.torsion_order\n        self.ntors = web_latex(BSDntors)\n        self.tr = len(self.torsion_structure)\n        if self.tr == 0:\n            self.tor_struct_pretty = \"$0$\"\n        if self.tr == 1:\n            self.tor_struct_pretty = r\"\\(\\Z/%s\\Z\\)\" % self.torsion_structure[0]\n        if self.tr == 2:\n            self.tor_struct_pretty = r\"\\(\\Z/%s\\Z\\oplus\\Z/%s\\Z\\)\" % tuple(self.torsion_structure)\n\n        self.torsion_gens = [web_point(parse_point(K,P)) for P in self.torsion_gens]\n        self.tor_gens_and_orders = list(zip(self.torsion_gens, self.torsion_structure))\n\n        # BSD data\n        #\n        # We divide into 3 cases, based on rank_bounds [lb,ub],\n        # analytic_rank ar, (lb=ngens always).  The flag\n        # self.bsd_status is set to one of the following:\n        #\n        # \"unconditional\"\n        #     lb=ar=ub: we always have reg but in some cases over sextic fields we do not have omega, Lvalue, sha.\n        #     i.e. [lb,ar,ub] = [r,r,r]\n        #\n        # \"conditional\"\n        #     lb=ar<ub: we always have reg but in some cases over sextic fields we do not have omega, Lvalue, sha.\n        #     e.g. [lb,ar,ub] = [0,0,2], [1,1,3]\n        #\n        # \"missing_gens\"\n        #     lb<ar<=ub\n        #     e.g. [lb,ar,ub] = [0,1,1], [0,2,2], [1,2,2], [0,1,3]\n        #\n        # \"incomplete\"\n        #     ar not computed.  (We can always set lb=0, ub=Infinity.)\n\n        # Rank and bounds\n        try:\n            self.rk = web_latex(self.rank)\n        except AttributeError:\n            self.rank = None\n            self.rk = \"not available\"\n\n        try:\n            self.rk_lb, self.rk_ub = self.rank_bounds\n        except AttributeError:\n            self.rk_lb = 0\n            self.rk_ub = Infinity\n            self.rank_bounds = \"not available\"\n\n        # Analytic rank\n        try:\n            self.ar = web_latex(self.analytic_rank)\n        except AttributeError:\n            self.analytic_rank = None\n            self.ar = \"not available\"\n\n        # for debugging:\n        assert self.rk == \"not available\" or (self.rk_lb == self.rank\n                                              and self.rank == self.rk_ub)\n        assert self.ar == \"not available\" or (self.rk_lb <= self.analytic_rank and self.analytic_rank <= self.rk_ub)\n\n        self.bsd_status = \"incomplete\"\n        if self.analytic_rank is not None:\n            if self.rk_lb == self.rk_ub:\n                self.bsd_status = \"unconditional\"\n            elif self.rk_lb == self.analytic_rank:\n                self.bsd_status = \"conditional\"\n            else:\n                self.bsd_status = \"missing_gens\"\n\n        # Regulator only in conditional/unconditional cases, or when we know the rank:\n        BSDReg = None\n        if self.bsd_status in [\"conditional\", \"unconditional\"]:\n            if self.analytic_rank == 0:\n                BSDReg = 1\n                self.reg = self.NTreg = web_latex(BSDReg)  # otherwise we only get 1.00000...\n            else:\n                try:\n                    R = self.reg\n                    BSDReg = R * K.degree()**self.rank\n                    self.reg = web_latex(R)\n                    self.NTreg = web_latex(BSDReg)\n                except Exception:\n                    self.reg = \"not available\"\n                    self.NTreg = \"not available\"\n        elif self.rk != \"not available\":\n            R = self.reg\n            BSDReg = R * K.degree()**self.rank\n            self.reg = web_latex(R) if self.rank else web_latex(1)\n            self.NTreg = web_latex(BSDReg) if self.rank else web_latex(1)\n        else:\n            self.reg = \"not available\"\n            self.NTreg = \"not available\"\n\n        # Generators\n        try:\n            self.gens = [web_point(parse_point(K, P)) for P in self.gens]\n            self.gens_and_heights = list(zip(self.gens,self.heights))\n            self.gens_and_heights.sort(key=lambda Ph: Ph[1])\n        except AttributeError:\n            self.gens = []\n            self.gens_and_heights = []\n\n        # Global period -- see issue #5409 for why we multiply by\n        # 2**nc in most cases.  However, data computed after\n        # 2024-07-09 (including all data for imaginary quadratic\n        # fields of absolute discriminant > 600 as well as some larger\n        # conductors for other IQFs) already has the extra factor of\n        # 2.  As a fail-safe until we fix the data in all cases, we\n        # will test (using the BSD formula) whether to remove the\n        # factor of 2 added here.\n        BSDomega = None\n        try:\n            BSDomega = self.omega\n            nc = self.signature[1] # number of complex places\n            if nc:\n                BSDomega *= 2**nc\n            self.omega = web_latex(BSDomega)\n        except AttributeError:\n            self.omega = \"not available\"\n\n        # L-value\n        BSDLvalue = None\n        try:\n            r = int(self.analytic_rank)\n            # lhs = \"L(E,1) = \" if r==0 else \"L'(E,1) = \" if r==1 else \"L^{{({})}}(E,1)/{}! = \".format(r,r)\n            BSDLvalue = self.Lvalue\n            self.Lvalue = web_latex(BSDLvalue)\n        except (TypeError, AttributeError):\n            self.Lvalue = \"not available\"\n\n        # Tamagawa product\n        tamagawa_numbers = [ZZ(_ld['cp']) for _ld in self.local_data]\n        cp_fac = [cp.factor() for cp in tamagawa_numbers]\n        cp_fac = [latex(cp) if len(cp) < 2 else '('+latex(cp)+')' for cp in cp_fac]\n        if len(cp_fac) > 1:\n            self.tamagawa_factors = r'\\cdot'.join(cp_fac)\n        else:\n            self.tamagawa_factors = None\n        BSDprodcp = prod(tamagawa_numbers,1)\n        self.tamagawa_product = web_latex(BSDprodcp)\n\n        # Analytic Sha\n        BSDsha = None\n        try:\n            BSDsha = self.sha\n            self.sha = web_latex(BSDsha) + \" (rounded)\"\n        except AttributeError:\n            self.sha = \"not available\"\n\n        # Check analytic Sha value compatible with formula in the knowl (see issue #5409)\n\n        BSDrootdisc = RR(K.discriminant().abs()).sqrt()\n        BSDok = True\n        if BSDLvalue and BSDsha and BSDReg and (self.rank is not None):\n            BSDsha_numerator = BSDrootdisc * BSDntors**2\n            BSDsha_denominator = BSDReg * BSDomega * BSDprodcp\n            BSDsha_from_formula = BSDLvalue * BSDsha_numerator / BSDsha_denominator\n            BSDsha_from_formula_rounded = BSDsha_from_formula.round()\n            BSDok = (BSDsha_from_formula_rounded == BSDsha) and ((BSDsha_from_formula_rounded - BSDsha_from_formula).abs() < 0.001)\n            #print(f\"{BSDsha_from_formula=}\")\n            #print(f\"{BSDsha_from_formula_rounded=}\")\n            #print(f\"{BSDsha=}\")\n            #print(f\"{BSDok=}\")\n            if not BSDok:\n                # this means that we doubled BSDomega when we should\n                # not have, so BSDsha_denominator is doubled and\n                # BSDsha_from formula is halved\n                print(f\"BSD normalization: adjusting Omega for {self.label}: stored Sha = {BSDsha} but formula gives {BSDsha_from_formula}\")\n                BSDok = ((BSDsha/BSDsha_from_formula)-2).abs() < 0.01\n                if not BSDok:\n                    print(f\"BSD normalization issue with {self.label}: stored Sha = {BSDsha} but formula gives {BSDsha_from_formula}\")\n                BSDomega /= 2\n                BSDsha_denominator /= 2\n                BSDsha_from_formula *= 2\n                BSDsha_from_formula_rounded = BSDsha_from_formula.round()\n            BSDLvalue_from_formula = BSDsha * BSDsha_denominator / BSDsha_numerator\n            self.BSDsha = web_latex(BSDsha_from_formula)\n            self.BSDLvalue = web_latex(BSDLvalue_from_formula)\n\n            # The BSD formula for display\n\n            dot = '\\\\cdot'\n            approx = '\\\\approx'\n            eq_query = '\\\\overset{?}{=}'\n            frac = '\\\\frac'\n            Sha = '\\\\# &#1064;(E/K)'\n            Sha = '\\\\# \u0428(E/K)'\n            Om = '\\\\Omega(E/K)'\n            Reg = '\\\\mathrm{Reg}_{\\\\mathrm{NT}}(E/K)'\n            prodcp = '\\\\prod_{\\\\mathfrak{p}} c_{\\\\mathfrak{p}}'\n            tors2 = '\\\\#E(K)_{\\\\mathrm{tor}}^2'\n            rootD = '\\\\left|d_K\\\\right|^{1/2}'\n\n            lder_name  = rf\"L^{{({r})}}(E/K,1)/{r}!\" if r >= 2 else \"L'(E/K,1)\" if r else \"L(E/K,1)\"\n            lhs_num    = rf'{Sha} {dot} {Om} {dot} {Reg} {dot} {prodcp}'\n            lhs_den    = rf'{tors2} {dot} {rootD}'\n            lhs        = rf'{frac}{{ {lhs_num} }} {{ {lhs_den} }}'\n            rhs_num    = rf'{BSDsha} {dot} {BSDomega:0.6f} {dot} {BSDReg} {dot} {BSDprodcp}'\n            if r:\n                rhs_num    = rf'{BSDsha} {dot} {BSDomega:0.6f} {dot} {BSDReg:0.6f} {dot} {BSDprodcp}'\n            rhs_den    = rf'{{{BSDntors}^2 {dot} {BSDrootdisc:0.6f}}}'\n            rhs        = rf'{frac}{{ {rhs_num} }} {{ {rhs_den} }}'\n            self.bsd_formula = rf'\\begin{{aligned}}{BSDLvalue:0.9f} {approx} {lder_name} & {eq_query} {lhs} \\\\ & {approx} {rhs} \\\\ & {approx} {BSDLvalue_from_formula:0.9f} \\end{{aligned}}'\n\n        else:\n            self.BSDsha = \"not available\"\n            self.BSDLvalue = \"not available\"\n            self.bsd_formula = None\n\n        if not BSDok: # don't display the formula if it is not correct\n            self.bsd_formula = None\n\n        # Local data\n\n        # The Kodaira symbol is stored as an int in pari encoding. The\n        # conversion to latex must take into account the bug (in Sage\n        # 9.2) for I_m^* when m has more than one digit.\n\n        def latex_kod(kod):\n            return latex(KodairaSymbol(kod)) if kod > -14 else 'I_{%s}^{*}' % (-kod - 4)\n\n        for P,NP,ld in zip(badprimes, badnorms, local_data):\n            ld['p'] = P\n            ld['norm'] = NP\n            ld['kod'] = latex_kod(ld['kod'])\n\n        # URLs of self and related objects:\n        self.urls = {}\n        # It's useful to be able to use this class out of context, when calling url_for will fail:\n        try:\n            self.urls['curve'] = url_for(\".show_ecnf\", nf=self.field_label, conductor_label=quote(self.conductor_label), class_label=self.iso_label, number=self.number)\n        except RuntimeError:\n            return\n        self.urls['class'] = url_for(\".show_ecnf_isoclass\", nf=self.field_label, conductor_label=quote(self.conductor_label), class_label=self.iso_label)\n        self.urls['conductor'] = url_for(\".show_ecnf_conductor\", nf=self.field_label, conductor_label=quote(self.conductor_label))\n        self.urls['field'] = url_for(\".show_ecnf1\", nf=self.field_label)\n\n        # Isogeny information\n\n        self.one_deg = ZZ(self.class_deg).is_prime()\n        isodegs = [str(d) for d in self.isodeg if d > 1]\n        if len(isodegs) < 3:\n            self.isodeg = \" and \".join(isodegs)\n        else:\n            self.isodeg = \" and \".join([\", \".join(isodegs[:-1]), isodegs[-1]])\n\n        sig = self.signature\n        totally_real = sig[1] == 0\n        imag_quadratic = sig == [0,1]\n\n        if totally_real:\n            self.hmf_label = \"-\".join([self.field.label, self.conductor_label, self.iso_label])\n            self.urls['hmf'] = url_for('hmf.render_hmf_webpage', field_label=self.field.label, label=self.hmf_label)\n            lfun_url = url_for(\"l_functions.l_function_ecnf_page\", field_label=self.field_label, conductor_label=self.conductor_label, isogeny_class_label=self.iso_label)\n            origin_url = lfun_url.lstrip('/L/').rstrip('/')\n            if sig[0] <= 2 and db.lfunc_instances.exists({'url':origin_url}):\n                self.urls['Lfunction'] = lfun_url\n            elif self.abs_disc ** 2 * self.conductor_norm < 70000:\n                # we shouldn't trust the Lfun computed on the fly for large conductor\n                self.urls['Lfunction'] = url_for(\"l_functions.l_function_hmf_page\", field=self.field_label, label=self.hmf_label, character='0', number='0')\n\n        if imag_quadratic:\n            self.bmf_label = \"-\".join([self.field.label, self.conductor_label, self.iso_label])\n            self.bmf_url = url_for('bmf.render_bmf_webpage', field_label=self.field_label, level_label=self.conductor_label, label_suffix=self.iso_label)\n            lfun_url = url_for(\"l_functions.l_function_ecnf_page\", field_label=self.field_label, conductor_label=self.conductor_label, isogeny_class_label=self.iso_label)\n            origin_url = lfun_url.lstrip('/L/').rstrip('/')\n            if db.lfunc_instances.exists({'url':origin_url}):\n                self.urls['Lfunction'] = lfun_url\n\n        # most of this code is repeated in isog_class.py\n        # and should be refactored\n        self.friends = []\n        self.friends += [('Isogeny class ' + self.short_class_label, self.urls['class'])]\n        self.friends += [('Twists', url_for('ecnf.index', field=self.field_label, jinv=rename_j(j)))]\n        if totally_real and 'Lfunction' not in self.urls:\n            self.friends += [('Hilbert modular form ' + self.hmf_label, self.urls['hmf'])]\n\n        if imag_quadratic:\n            if \"CM\" in self.label:\n                self.friends += [('Bianchi modular form is not cuspidal', '')]\n            elif 'Lfunction' not in self.urls:\n                if db.bmf_forms.label_exists(self.bmf_label):\n                    self.friends += [('Bianchi modular form %s' % self.bmf_label, self.bmf_url)]\n                else:\n                    self.friends += [('(Bianchi modular form %s)' % self.bmf_label, '')]\n\n        self.properties = [('Label', self.label)]\n\n        # Plot\n        if K.signature()[0]:\n            self.plot = None\n            if self.degree > 2:\n                self.plot = db.ec_nfportraits.lookup(self.label, \"portrait\")\n            if self.plot is None:\n                self.plot = encode_plot(EC_nf_plot(K,self.ainvs, self.field.generator_name()), transparent=True)\n            self.plot_link = '<a href=\"{0}\"><img src=\"{0}\" width=\"200\" height=\"150\"/></a>'.format(self.plot)\n            self.properties += [(None, self.plot_link)]\n        self.properties += [('Base field', self.field.field_pretty())]\n\n        self.properties += [\n            # hide conductor in Properties box (can be very large)\n            # ('Conductor', self.cond),\n            ('Conductor norm', self.cond_norm),\n            # See issue #796 for why this is hidden (can be very large)\n            # ('j-invariant', self.j),\n            ('CM', self.cm_bool)]\n\n        if not self.base_change:\n            self.base_change = []  # in case it was False or None instead of []\n        self.nbc = len(self.base_change)\n\n        # add base_change yes/no to Properties box\n        if self.base_change:\n            self.properties += [('Base change', 'yes')]\n        else:\n            self.properties += [('Base change', 'no')]\n        self.properties += [('Q-curve', self.qc)]\n\n        r = self.rk\n        if r == \"?\":\n            r = self.rk_bnds\n        self.properties += [\n            ('Torsion order', self.ntors),\n            ('Rank', r),\n        ]\n\n        # add links to base curves if base-change - first separate\n        # labels over Q from others, and convert any Cremona labels to\n        # LMFDB labels:\n        self.base_change_Q = [cremona_label_to_lmfdb_label(lab) for lab in self.base_change if '-' not in lab]\n\n        # sort by conductor (so also unknown curves come last)\n        self.base_change_Q.sort(key=lambda lab:ZZ(conductor_from_label(lab)))\n        self.bcQtext = [] # for the Base change section of the home page\n        for lab in self.base_change_Q:\n            if '?' in lab:\n                cond = conductor_from_label(lab)\n                self.bcQtext.append('a curve of conductor {} (not in the database)'.format(cond))\n                # but omit from friends\n            else:\n                url = url_for(\"ec.by_ec_label\", label=lab)\n                self.bcQtext.append('<a href=\"{}\">{}</a>'.format(url,lab))\n                self.friends += [(r'Base change of {} /\\(\\Q\\)'.format(lab), url)]\n\n        self.base_change_NF = [lab for lab in self.base_change if '-' in lab]\n        # we want to use split_full_label but that will fail if the class code + number are '?'\n        self.base_change_NFsplit = [(lab,)+split_full_label(lab.replace('?','a1')) for lab in self.base_change_NF]\n        self.bcNFtext = [] # for the Base change section of the home page\n        for lab, nf, cond, cl, num in self.base_change_NFsplit:\n            field_knowl = FIELD(nf).knowl()\n            if '?' in lab:\n                cond_norm = cond.split(\".\")[0]\n                self.bcNFtext.append([\"{}\".format(field_knowl), \"a curve with conductor norm {} (not in the database)\".format(cond_norm)])\n            else:\n                url = url_for(\".show_ecnf\", nf=nf, conductor_label=cond, class_label=cl, number=num)\n                self.bcNFtext.append([\"{}\".format(field_knowl), '<a href=\"{}\">{}</a>'.format(url,lab)])\n                self.friends += [(r'Base change of %s' % lab, url)]\n        self._code = None # will be set if needed by get_code()\n\n        self.downloads = [('All stored data to text', url_for(\".download_ECNF_all\", nf=self.field_label, conductor_label=quote(self.conductor_label), class_label=self.iso_label, number=self.number))]\n        for lang in [[\"Magma\",\"magma\"], [\"PariGP\", \"gp\"], [\"SageMath\",\"sage\"]]:\n            self.downloads.append(('{} commands'.format(lang[0]),\n                                   url_for(\".ecnf_code_download\", nf=self.field_label, conductor_label=quote(self.conductor_label),\n                                           class_label=self.iso_label, number=self.number, download_type=lang[1])))\n        self.downloads.append(('Underlying data', url_for(\".ecnf_data\", label=self.label)))\n\n        if 'Lfunction' in self.urls:\n            Lfun = get_lfunction_by_url(self.urls['Lfunction'].lstrip('/L').rstrip('/'), projection=['degree', 'trace_hash', 'Lhash'])\n            if Lfun is None:\n                self.friends += [('L-function not available', \"\")]\n            else:\n                instances = get_instances_by_Lhash_and_trace_hash(\n                    Lfun['Lhash'],\n                    Lfun['degree'],\n                    Lfun.get('trace_hash'))\n                exclude = {elt[1].rstrip('/').lstrip('/') for elt in self.friends\n                         if elt[1]}\n                self.friends += names_and_urls(instances, exclude=exclude)\n                self.friends += [('L-function', self.urls['Lfunction'])]\n        else:\n            self.friends += [('L-function not available', \"\")]"
  },
  {
    "type": "class",
    "file": "lmfdb/ecnf/WebEllipticCurve.py",
    "name": "ECNF",
    "line_start": 311,
    "line_end": 885,
    "lines": 575,
    "bytes": 25951,
    "has_71": true,
    "code": "class ECNF():\n\n    \"\"\"\n    ECNF Wrapper\n    \"\"\"\n\n    def __init__(self, dbdata):\n        \"\"\"\n        Arguments:\n\n            - dbdata: the data from the database\n        \"\"\"\n        # del dbdata[\"_id\"]\n        self.__dict__.update(dbdata)\n        self.field = FIELD(self.field_label)\n        self.nonmax_primes = dbdata.get('nonmax_primes',None)\n        self.make_E()\n\n    @staticmethod\n    def by_label(label):\n        \"\"\"\n        searches for a specific elliptic curve in the ecnf collection by its label\n        \"\"\"\n        data = db.ec_nfcurves.lookup(label)\n        if data:\n            return ECNF(data)\n        return \"Elliptic curve not found: %s\" % label # caller must check for this\n\n    def make_E(self):\n        #print(\"Creating ECNF object for {}\".format(self.label))\n        #sys.stdout.flush()\n        K = self.field.K()\n        Kgen = str(K.gen())\n\n        # a-invariants\n        # NB Here we construct the ai as elements of K, which are used as follows:\n        # (1) to compute the model discriminant (if not stored)\n        # (2) to compute the latex equation (if not stored)\n        # (3) to compute the plots under real embeddings of K\n        # Of these, (2) is not needed and (1) will soon be obsolete;\n        #  for (3) it would be possible to rewrite the function EC_nf_plot() not to need this.\n        # Then we might also be able to avoid constructing the field K also.\n\n        self.ainvs = parse_ainvs(K,self.ainvs)\n        self.numb = str(self.number)\n\n        # Conductor, discriminant, j-invariant\n\n        self.cond_norm = web_latex(self.conductor_norm)\n\n        Dnorm = self.normdisc\n        self.model_disc = self.disc.replace('w', Kgen).replace(\"*\",\"\").replace(\"(\",\"\").replace(\")\",\"\")\n        if Kgen == 'phi':\n            self.model_disc = self.model_disc.replace(Kgen, r\"\\phi\")\n        self.disc = pretty_ideal(Kgen, self.disc)\n\n        local_data = self.local_data\n        local_data.sort(key=lambda ld: ld['normp'])\n\n        badprimes = [pretty_ideal(Kgen, ld['p'], enclose=False) for ld in local_data]\n        badnorms = [ld['normp'] for ld in local_data]\n        disc_ords = [ld['ord_disc'] for ld in local_data]\n        mindisc_ords = [ld['ord_disc'] for ld in local_data]\n        cond_ords = [ld['ord_cond'] for ld in local_data]\n\n        if self.conductor_norm == 1:\n            self.cond = r\"\\((1)\\)\"\n            self.fact_cond = self.cond\n            self.fact_cond_norm = '1'\n        else:\n            self.cond = pretty_ideal(Kgen, self.conductor_ideal)\n            self.fact_cond = latex_factorization(badprimes, cond_ords)\n            self.fact_cond_norm = latex_factorization(badnorms, cond_ords)\n\n        # Assumption: the curve models stored in the database are\n        # either global minimal models or minimal at all but one\n        # prime, so the list here has length 0 or 1:\n\n        self.is_minimal = (len(self.non_min_p) == 0)\n        self.has_minimal_model = self.is_minimal\n\n        if not self.is_minimal:\n            non_min_p = self.non_min_p[0]\n            self.non_min_prime = pretty_ideal(Kgen, non_min_p)\n            ip = [ld['p'] for ld in local_data].index(non_min_p)\n            disc_ords[ip] += 12\n            Dnorm_factor = local_data[ip]['normp']**12\n\n        self.disc_norm = web_latex(Dnorm)\n        signDnorm = 1 if Dnorm > 0 else -1\n        if Dnorm in [1, -1]:  # since the factorization of (1) displays as \"1\"\n            self.fact_disc = self.disc\n            self.fact_disc_norm = str(Dnorm)\n        else:\n            self.fact_disc = latex_factorization(badprimes, disc_ords)\n            self.fact_disc_norm = latex_factorization(badnorms, disc_ords, sign=signDnorm)\n\n        if self.is_minimal:\n            Dmin_norm = Dnorm\n            self.mindisc = self.disc\n        else:\n            Dmin_norm = Dnorm // Dnorm_factor\n            self.mindisc = pretty_ideal(Kgen, self.minD)\n\n        self.mindisc_norm = web_latex(Dmin_norm)\n        if Dmin_norm in [1,-1]:  # since the factorization of (1) displays as \"1\"\n            self.fact_mindisc = self.mindisc\n            self.fact_mindisc_norm = self.mindisc_norm\n        else:\n            self.fact_mindisc = latex_factorization(badprimes, mindisc_ords)\n            self.fact_mindisc_norm = latex_factorization(badnorms, mindisc_ords, sign=signDnorm)\n\n        j = self.field.parse_NFelt(self.jinv)\n        self.j = web_latex(j)\n        self.fact_j = None\n        # See issue 1258: some j factorizations work but take too long\n        # (e.g. EllipticCurve/6.6.371293.1/1.1/a/1).  Note that we do\n        # store the factorization of the denominator of j and display\n        # that, which is the most interesting part.\n\n        # When the equation is stored in the database as a latex string,\n        # it may have extraneous double quotes at beginning and\n        # end, which we fix here.  We also strip out initial \\( and \\)\n        # (if present) which are added in the template.\n        try:\n            self.equation = self.equation.replace('\"','').replace(r'\\\\(','').replace(r'\\\\)','')\n        except AttributeError:\n            self.equation = latex_equation(self.ainvs)\n\n        # Images of Galois representations\n\n        if not hasattr(self,'galois_images'):\n            #print \"No Galois image data\"\n            self.galois_images = \"?\"\n            self.nonmax_primes = \"?\"\n            self.galois_data = []\n        else:\n            self.galois_data = [{'p': p,'image': im }\n                                for p,im in zip(self.nonmax_primes,\n                                                self.galois_images)]\n\n        # CM and End(E)\n        self.cm_bool = \"no\"\n        self.End = r\"\\(\\Z\\)\"\n        self.rational_cm = self.cm_type > 0\n        if self.cm:\n            self.cm_sqf = integer_squarefree_part(ZZ(self.cm))\n            self.cm_bool = r\"yes (\\(%s\\))\" % self.cm\n            if self.cm % 4 == 0:\n                d4 = ZZ(self.cm) // 4\n                self.End = r\"\\(\\Z[\\sqrt{%s}]\\)\" % (d4)\n            else:\n                self.End = r\"\\(\\Z[(1+\\sqrt{%s})/2]\\)\" % self.cm\n\n        # Galois images in CM case:\n        if self.cm and self.galois_images != '?':\n            self.cm_ramp = [p for p in ZZ(self.cm).support() if p not in self.nonmax_primes]\n            self.cm_nramp = len(self.cm_ramp)\n            if self.cm_nramp == 1:\n                self.cm_ramp = self.cm_ramp[0]\n            else:\n                self.cm_ramp = \", \".join(str(p) for p in self.cm_ramp)\n\n        # Sato-Tate:\n        self.ST = st_display_knowl('1.2.A.1.1a' if not self.cm_type else ('1.2.B.2.1a' if self.cm_type < 0 else '1.2.B.1.1a'))\n\n        # Q-curve / Base change\n        try:\n            qc = self.q_curve\n            if qc is True:\n                self.qc = \"yes\"\n            elif qc is False:\n                self.qc = \"no\"\n            else: # just in case\n                self.qc = \"not determined\"\n        except AttributeError:\n            self.qc = \"not determined\"\n\n        # Mordell-Weil group\n        try:\n            invs = [0 for a in range(self.rank)] + list(self.torsion_structure)\n            self.mw_struct = \"trivial\" if len(invs) == 0 else r'\\(' + r' \\oplus '.join((r'\\Z' if n == 0 else r'\\Z/{%s}\\Z' % n) for n in invs) + r'\\)'\n        except AttributeError: # if self.rank not set\n            self.mw_struct = \"unknown\"\n\n        # Torsion\n        BSDntors = self.torsion_order\n        self.ntors = web_latex(BSDntors)\n        self.tr = len(self.torsion_structure)\n        if self.tr == 0:\n            self.tor_struct_pretty = \"$0$\"\n        if self.tr == 1:\n            self.tor_struct_pretty = r\"\\(\\Z/%s\\Z\\)\" % self.torsion_structure[0]\n        if self.tr == 2:\n            self.tor_struct_pretty = r\"\\(\\Z/%s\\Z\\oplus\\Z/%s\\Z\\)\" % tuple(self.torsion_structure)\n\n        self.torsion_gens = [web_point(parse_point(K,P)) for P in self.torsion_gens]\n        self.tor_gens_and_orders = list(zip(self.torsion_gens, self.torsion_structure))\n\n        # BSD data\n        #\n        # We divide into 3 cases, based on rank_bounds [lb,ub],\n        # analytic_rank ar, (lb=ngens always).  The flag\n        # self.bsd_status is set to one of the following:\n        #\n        # \"unconditional\"\n        #     lb=ar=ub: we always have reg but in some cases over sextic fields we do not have omega, Lvalue, sha.\n        #     i.e. [lb,ar,ub] = [r,r,r]\n        #\n        # \"conditional\"\n        #     lb=ar<ub: we always have reg but in some cases over sextic fields we do not have omega, Lvalue, sha.\n        #     e.g. [lb,ar,ub] = [0,0,2], [1,1,3]\n        #\n        # \"missing_gens\"\n        #     lb<ar<=ub\n        #     e.g. [lb,ar,ub] = [0,1,1], [0,2,2], [1,2,2], [0,1,3]\n        #\n        # \"incomplete\"\n        #     ar not computed.  (We can always set lb=0, ub=Infinity.)\n\n        # Rank and bounds\n        try:\n            self.rk = web_latex(self.rank)\n        except AttributeError:\n            self.rank = None\n            self.rk = \"not available\"\n\n        try:\n            self.rk_lb, self.rk_ub = self.rank_bounds\n        except AttributeError:\n            self.rk_lb = 0\n            self.rk_ub = Infinity\n            self.rank_bounds = \"not available\"\n\n        # Analytic rank\n        try:\n            self.ar = web_latex(self.analytic_rank)\n        except AttributeError:\n            self.analytic_rank = None\n            self.ar = \"not available\"\n\n        # for debugging:\n        assert self.rk == \"not available\" or (self.rk_lb == self.rank\n                                              and self.rank == self.rk_ub)\n        assert self.ar == \"not available\" or (self.rk_lb <= self.analytic_rank and self.analytic_rank <= self.rk_ub)\n\n        self.bsd_status = \"incomplete\"\n        if self.analytic_rank is not None:\n            if self.rk_lb == self.rk_ub:\n                self.bsd_status = \"unconditional\"\n            elif self.rk_lb == self.analytic_rank:\n                self.bsd_status = \"conditional\"\n            else:\n                self.bsd_status = \"missing_gens\"\n\n        # Regulator only in conditional/unconditional cases, or when we know the rank:\n        BSDReg = None\n        if self.bsd_status in [\"conditional\", \"unconditional\"]:\n            if self.analytic_rank == 0:\n                BSDReg = 1\n                self.reg = self.NTreg = web_latex(BSDReg)  # otherwise we only get 1.00000...\n            else:\n                try:\n                    R = self.reg\n                    BSDReg = R * K.degree()**self.rank\n                    self.reg = web_latex(R)\n                    self.NTreg = web_latex(BSDReg)\n                except Exception:\n                    self.reg = \"not available\"\n                    self.NTreg = \"not available\"\n        elif self.rk != \"not available\":\n            R = self.reg\n            BSDReg = R * K.degree()**self.rank\n            self.reg = web_latex(R) if self.rank else web_latex(1)\n            self.NTreg = web_latex(BSDReg) if self.rank else web_latex(1)\n        else:\n            self.reg = \"not available\"\n            self.NTreg = \"not available\"\n\n        # Generators\n        try:\n            self.gens = [web_point(parse_point(K, P)) for P in self.gens]\n            self.gens_and_heights = list(zip(self.gens,self.heights))\n            self.gens_and_heights.sort(key=lambda Ph: Ph[1])\n        except AttributeError:\n            self.gens = []\n            self.gens_and_heights = []\n\n        # Global period -- see issue #5409 for why we multiply by\n        # 2**nc in most cases.  However, data computed after\n        # 2024-07-09 (including all data for imaginary quadratic\n        # fields of absolute discriminant > 600 as well as some larger\n        # conductors for other IQFs) already has the extra factor of\n        # 2.  As a fail-safe until we fix the data in all cases, we\n        # will test (using the BSD formula) whether to remove the\n        # factor of 2 added here.\n        BSDomega = None\n        try:\n            BSDomega = self.omega\n            nc = self.signature[1] # number of complex places\n            if nc:\n                BSDomega *= 2**nc\n            self.omega = web_latex(BSDomega)\n        except AttributeError:\n            self.omega = \"not available\"\n\n        # L-value\n        BSDLvalue = None\n        try:\n            r = int(self.analytic_rank)\n            # lhs = \"L(E,1) = \" if r==0 else \"L'(E,1) = \" if r==1 else \"L^{{({})}}(E,1)/{}! = \".format(r,r)\n            BSDLvalue = self.Lvalue\n            self.Lvalue = web_latex(BSDLvalue)\n        except (TypeError, AttributeError):\n            self.Lvalue = \"not available\"\n\n        # Tamagawa product\n        tamagawa_numbers = [ZZ(_ld['cp']) for _ld in self.local_data]\n        cp_fac = [cp.factor() for cp in tamagawa_numbers]\n        cp_fac = [latex(cp) if len(cp) < 2 else '('+latex(cp)+')' for cp in cp_fac]\n        if len(cp_fac) > 1:\n            self.tamagawa_factors = r'\\cdot'.join(cp_fac)\n        else:\n            self.tamagawa_factors = None\n        BSDprodcp = prod(tamagawa_numbers,1)\n        self.tamagawa_product = web_latex(BSDprodcp)\n\n        # Analytic Sha\n        BSDsha = None\n        try:\n            BSDsha = self.sha\n            self.sha = web_latex(BSDsha) + \" (rounded)\"\n        except AttributeError:\n            self.sha = \"not available\"\n\n        # Check analytic Sha value compatible with formula in the knowl (see issue #5409)\n\n        BSDrootdisc = RR(K.discriminant().abs()).sqrt()\n        BSDok = True\n        if BSDLvalue and BSDsha and BSDReg and (self.rank is not None):\n            BSDsha_numerator = BSDrootdisc * BSDntors**2\n            BSDsha_denominator = BSDReg * BSDomega * BSDprodcp\n            BSDsha_from_formula = BSDLvalue * BSDsha_numerator / BSDsha_denominator\n            BSDsha_from_formula_rounded = BSDsha_from_formula.round()\n            BSDok = (BSDsha_from_formula_rounded == BSDsha) and ((BSDsha_from_formula_rounded - BSDsha_from_formula).abs() < 0.001)\n            #print(f\"{BSDsha_from_formula=}\")\n            #print(f\"{BSDsha_from_formula_rounded=}\")\n            #print(f\"{BSDsha=}\")\n            #print(f\"{BSDok=}\")\n            if not BSDok:\n                # this means that we doubled BSDomega when we should\n                # not have, so BSDsha_denominator is doubled and\n                # BSDsha_from formula is halved\n                print(f\"BSD normalization: adjusting Omega for {self.label}: stored Sha = {BSDsha} but formula gives {BSDsha_from_formula}\")\n                BSDok = ((BSDsha/BSDsha_from_formula)-2).abs() < 0.01\n                if not BSDok:\n                    print(f\"BSD normalization issue with {self.label}: stored Sha = {BSDsha} but formula gives {BSDsha_from_formula}\")\n                BSDomega /= 2\n                BSDsha_denominator /= 2\n                BSDsha_from_formula *= 2\n                BSDsha_from_formula_rounded = BSDsha_from_formula.round()\n            BSDLvalue_from_formula = BSDsha * BSDsha_denominator / BSDsha_numerator\n            self.BSDsha = web_latex(BSDsha_from_formula)\n            self.BSDLvalue = web_latex(BSDLvalue_from_formula)\n\n            # The BSD formula for display\n\n            dot = '\\\\cdot'\n            approx = '\\\\approx'\n            eq_query = '\\\\overset{?}{=}'\n            frac = '\\\\frac'\n            Sha = '\\\\# &#1064;(E/K)'\n            Sha = '\\\\# \u0428(E/K)'\n            Om = '\\\\Omega(E/K)'\n            Reg = '\\\\mathrm{Reg}_{\\\\mathrm{NT}}(E/K)'\n            prodcp = '\\\\prod_{\\\\mathfrak{p}} c_{\\\\mathfrak{p}}'\n            tors2 = '\\\\#E(K)_{\\\\mathrm{tor}}^2'\n            rootD = '\\\\left|d_K\\\\right|^{1/2}'\n\n            lder_name  = rf\"L^{{({r})}}(E/K,1)/{r}!\" if r >= 2 else \"L'(E/K,1)\" if r else \"L(E/K,1)\"\n            lhs_num    = rf'{Sha} {dot} {Om} {dot} {Reg} {dot} {prodcp}'\n            lhs_den    = rf'{tors2} {dot} {rootD}'\n            lhs        = rf'{frac}{{ {lhs_num} }} {{ {lhs_den} }}'\n            rhs_num    = rf'{BSDsha} {dot} {BSDomega:0.6f} {dot} {BSDReg} {dot} {BSDprodcp}'\n            if r:\n                rhs_num    = rf'{BSDsha} {dot} {BSDomega:0.6f} {dot} {BSDReg:0.6f} {dot} {BSDprodcp}'\n            rhs_den    = rf'{{{BSDntors}^2 {dot} {BSDrootdisc:0.6f}}}'\n            rhs        = rf'{frac}{{ {rhs_num} }} {{ {rhs_den} }}'\n            self.bsd_formula = rf'\\begin{{aligned}}{BSDLvalue:0.9f} {approx} {lder_name} & {eq_query} {lhs} \\\\ & {approx} {rhs} \\\\ & {approx} {BSDLvalue_from_formula:0.9f} \\end{{aligned}}'\n\n        else:\n            self.BSDsha = \"not available\"\n            self.BSDLvalue = \"not available\"\n            self.bsd_formula = None\n\n        if not BSDok: # don't display the formula if it is not correct\n            self.bsd_formula = None\n\n        # Local data\n\n        # The Kodaira symbol is stored as an int in pari encoding. The\n        # conversion to latex must take into account the bug (in Sage\n        # 9.2) for I_m^* when m has more than one digit.\n\n        def latex_kod(kod):\n            return latex(KodairaSymbol(kod)) if kod > -14 else 'I_{%s}^{*}' % (-kod - 4)\n\n        for P,NP,ld in zip(badprimes, badnorms, local_data):\n            ld['p'] = P\n            ld['norm'] = NP\n            ld['kod'] = latex_kod(ld['kod'])\n\n        # URLs of self and related objects:\n        self.urls = {}\n        # It's useful to be able to use this class out of context, when calling url_for will fail:\n        try:\n            self.urls['curve'] = url_for(\".show_ecnf\", nf=self.field_label, conductor_label=quote(self.conductor_label), class_label=self.iso_label, number=self.number)\n        except RuntimeError:\n            return\n        self.urls['class'] = url_for(\".show_ecnf_isoclass\", nf=self.field_label, conductor_label=quote(self.conductor_label), class_label=self.iso_label)\n        self.urls['conductor'] = url_for(\".show_ecnf_conductor\", nf=self.field_label, conductor_label=quote(self.conductor_label))\n        self.urls['field'] = url_for(\".show_ecnf1\", nf=self.field_label)\n\n        # Isogeny information\n\n        self.one_deg = ZZ(self.class_deg).is_prime()\n        isodegs = [str(d) for d in self.isodeg if d > 1]\n        if len(isodegs) < 3:\n            self.isodeg = \" and \".join(isodegs)\n        else:\n            self.isodeg = \" and \".join([\", \".join(isodegs[:-1]), isodegs[-1]])\n\n        sig = self.signature\n        totally_real = sig[1] == 0\n        imag_quadratic = sig == [0,1]\n\n        if totally_real:\n            self.hmf_label = \"-\".join([self.field.label, self.conductor_label, self.iso_label])\n            self.urls['hmf'] = url_for('hmf.render_hmf_webpage', field_label=self.field.label, label=self.hmf_label)\n            lfun_url = url_for(\"l_functions.l_function_ecnf_page\", field_label=self.field_label, conductor_label=self.conductor_label, isogeny_class_label=self.iso_label)\n            origin_url = lfun_url.lstrip('/L/').rstrip('/')\n            if sig[0] <= 2 and db.lfunc_instances.exists({'url':origin_url}):\n                self.urls['Lfunction'] = lfun_url\n            elif self.abs_disc ** 2 * self.conductor_norm < 70000:\n                # we shouldn't trust the Lfun computed on the fly for large conductor\n                self.urls['Lfunction'] = url_for(\"l_functions.l_function_hmf_page\", field=self.field_label, label=self.hmf_label, character='0', number='0')\n\n        if imag_quadratic:\n            self.bmf_label = \"-\".join([self.field.label, self.conductor_label, self.iso_label])\n            self.bmf_url = url_for('bmf.render_bmf_webpage', field_label=self.field_label, level_label=self.conductor_label, label_suffix=self.iso_label)\n            lfun_url = url_for(\"l_functions.l_function_ecnf_page\", field_label=self.field_label, conductor_label=self.conductor_label, isogeny_class_label=self.iso_label)\n            origin_url = lfun_url.lstrip('/L/').rstrip('/')\n            if db.lfunc_instances.exists({'url':origin_url}):\n                self.urls['Lfunction'] = lfun_url\n\n        # most of this code is repeated in isog_class.py\n        # and should be refactored\n        self.friends = []\n        self.friends += [('Isogeny class ' + self.short_class_label, self.urls['class'])]\n        self.friends += [('Twists', url_for('ecnf.index', field=self.field_label, jinv=rename_j(j)))]\n        if totally_real and 'Lfunction' not in self.urls:\n            self.friends += [('Hilbert modular form ' + self.hmf_label, self.urls['hmf'])]\n\n        if imag_quadratic:\n            if \"CM\" in self.label:\n                self.friends += [('Bianchi modular form is not cuspidal', '')]\n            elif 'Lfunction' not in self.urls:\n                if db.bmf_forms.label_exists(self.bmf_label):\n                    self.friends += [('Bianchi modular form %s' % self.bmf_label, self.bmf_url)]\n                else:\n                    self.friends += [('(Bianchi modular form %s)' % self.bmf_label, '')]\n\n        self.properties = [('Label', self.label)]\n\n        # Plot\n        if K.signature()[0]:\n            self.plot = None\n            if self.degree > 2:\n                self.plot = db.ec_nfportraits.lookup(self.label, \"portrait\")\n            if self.plot is None:\n                self.plot = encode_plot(EC_nf_plot(K,self.ainvs, self.field.generator_name()), transparent=True)\n            self.plot_link = '<a href=\"{0}\"><img src=\"{0}\" width=\"200\" height=\"150\"/></a>'.format(self.plot)\n            self.properties += [(None, self.plot_link)]\n        self.properties += [('Base field', self.field.field_pretty())]\n\n        self.properties += [\n            # hide conductor in Properties box (can be very large)\n            # ('Conductor', self.cond),\n            ('Conductor norm', self.cond_norm),\n            # See issue #796 for why this is hidden (can be very large)\n            # ('j-invariant', self.j),\n            ('CM', self.cm_bool)]\n\n        if not self.base_change:\n            self.base_change = []  # in case it was False or None instead of []\n        self.nbc = len(self.base_change)\n\n        # add base_change yes/no to Properties box\n        if self.base_change:\n            self.properties += [('Base change', 'yes')]\n        else:\n            self.properties += [('Base change', 'no')]\n        self.properties += [('Q-curve', self.qc)]\n\n        r = self.rk\n        if r == \"?\":\n            r = self.rk_bnds\n        self.properties += [\n            ('Torsion order', self.ntors),\n            ('Rank', r),\n        ]\n\n        # add links to base curves if base-change - first separate\n        # labels over Q from others, and convert any Cremona labels to\n        # LMFDB labels:\n        self.base_change_Q = [cremona_label_to_lmfdb_label(lab) for lab in self.base_change if '-' not in lab]\n\n        # sort by conductor (so also unknown curves come last)\n        self.base_change_Q.sort(key=lambda lab:ZZ(conductor_from_label(lab)))\n        self.bcQtext = [] # for the Base change section of the home page\n        for lab in self.base_change_Q:\n            if '?' in lab:\n                cond = conductor_from_label(lab)\n                self.bcQtext.append('a curve of conductor {} (not in the database)'.format(cond))\n                # but omit from friends\n            else:\n                url = url_for(\"ec.by_ec_label\", label=lab)\n                self.bcQtext.append('<a href=\"{}\">{}</a>'.format(url,lab))\n                self.friends += [(r'Base change of {} /\\(\\Q\\)'.format(lab), url)]\n\n        self.base_change_NF = [lab for lab in self.base_change if '-' in lab]\n        # we want to use split_full_label but that will fail if the class code + number are '?'\n        self.base_change_NFsplit = [(lab,)+split_full_label(lab.replace('?','a1')) for lab in self.base_change_NF]\n        self.bcNFtext = [] # for the Base change section of the home page\n        for lab, nf, cond, cl, num in self.base_change_NFsplit:\n            field_knowl = FIELD(nf).knowl()\n            if '?' in lab:\n                cond_norm = cond.split(\".\")[0]\n                self.bcNFtext.append([\"{}\".format(field_knowl), \"a curve with conductor norm {} (not in the database)\".format(cond_norm)])\n            else:\n                url = url_for(\".show_ecnf\", nf=nf, conductor_label=cond, class_label=cl, number=num)\n                self.bcNFtext.append([\"{}\".format(field_knowl), '<a href=\"{}\">{}</a>'.format(url,lab)])\n                self.friends += [(r'Base change of %s' % lab, url)]\n        self._code = None # will be set if needed by get_code()\n\n        self.downloads = [('All stored data to text', url_for(\".download_ECNF_all\", nf=self.field_label, conductor_label=quote(self.conductor_label), class_label=self.iso_label, number=self.number))]\n        for lang in [[\"Magma\",\"magma\"], [\"PariGP\", \"gp\"], [\"SageMath\",\"sage\"]]:\n            self.downloads.append(('{} commands'.format(lang[0]),\n                                   url_for(\".ecnf_code_download\", nf=self.field_label, conductor_label=quote(self.conductor_label),\n                                           class_label=self.iso_label, number=self.number, download_type=lang[1])))\n        self.downloads.append(('Underlying data', url_for(\".ecnf_data\", label=self.label)))\n\n        if 'Lfunction' in self.urls:\n            Lfun = get_lfunction_by_url(self.urls['Lfunction'].lstrip('/L').rstrip('/'), projection=['degree', 'trace_hash', 'Lhash'])\n            if Lfun is None:\n                self.friends += [('L-function not available', \"\")]\n            else:\n                instances = get_instances_by_Lhash_and_trace_hash(\n                    Lfun['Lhash'],\n                    Lfun['degree'],\n                    Lfun.get('trace_hash'))\n                exclude = {elt[1].rstrip('/').lstrip('/') for elt in self.friends\n                         if elt[1]}\n                self.friends += names_and_urls(instances, exclude=exclude)\n                self.friends += [('L-function', self.urls['Lfunction'])]\n        else:\n            self.friends += [('L-function not available', \"\")]\n\n    def display_modell_image(self,label):\n        return display_knowl('gl2.subgroup_data', title=label, kwargs={'label':label})\n\n    def code(self):\n        if self._code is None:\n            self._code = make_code(self.label)\n        return self._code"
  },
  {
    "type": "class",
    "file": "lmfdb/groups/abstract/test_browse_page.py",
    "name": "AbGpsHomeTest",
    "line_start": 6,
    "line_end": 612,
    "lines": 607,
    "bytes": 29271,
    "has_71": true,
    "code": "class AbGpsHomeTest(LmfdbTest):\n    # All tests should pass\n\n    # The pages themselves\n    def test_index_page(self):\n        r\"\"\"\n        Check that the Groups/Abstract index page works\n        \"\"\"\n        homepage = self.tc.get(\"/Groups/Abstract/\").get_data(as_text=True)\n        assert \"database currently contains\" in homepage\n\n    # TODO test stats once we have them\n    #  def test_stats_page(self):\n    #  self.check_args(\"/Groups/Abstract/stats\",\"Abstract groups: Statistics\")\n\n    def test_completeness_page(self):\n        r\"\"\"\n        Check that Groups/Abstract/Completeness works\n        \"\"\"\n        page = self.tc.get(\"/Groups/Abstract/Completeness\").get_data(as_text=True)\n        assert \"All groups of order up to\" in page\n\n    def test_further_completeness_page(self):\n        r\"\"\"\n        Check that Groups/Abstract/Source works\n        \"\"\"\n        page = self.tc.get(\"/Groups/Abstract/Source\").get_data(as_text=True)\n        assert \"as well as their attributes, subgroups, character tables\" in page\n\n    def test_labels_page(self):\n        r\"\"\"\n        Check that Groups/Abstract/Labels works\n        \"\"\"\n        page = self.tc.get(\"/Groups/Abstract/Labels\").get_data(as_text=True)\n        assert \"has the form\" in page\n\n    def test_lookup(self):\n        r\"\"\"\n        Check that Groups/Abstract/?jump works\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?jump=10.1\", \"10.1\") # by label\n        self.check_args(\"/Groups/Abstract/?jump=SL(2,7)\", \"336.114\") # by family name\n        self.check_args(\"/Groups/Abstract/?jump=F5\", \"20.3\") # by name\n\n    # test that abelian group redirect works\n    def test_abelian_lookup(self):\n        r\"\"\"\n        Check that Groups/Abstract/ab/ works\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/ab/2.2.2.6\", \"48.52\")\n\n    def test_random(self):\n        r\"\"\"\n        Check that the random link works\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/random\", \"Group information\")\n        self.check_args(\"/Groups/Abstract/random\", \"Order:\")\n\n    # Various searches\n\n    def test_bad_label(self):\n        r\"\"\"\n        Check the error message for a bad label url\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/7.2\", \"No group with label\")\n\n    def test_search_order(self):\n        r\"\"\"\n        Check that we can search by order\n        \"\"\"\n        # check that 8.1 and  8.3 show up\n        self.check_args(\"/Groups/Abstract/?order=8\", \"8.1\")\n        self.check_args(\"/Groups/Abstract/?order=8\", \"8.3\")\n\n    def test_search_exponent(self):\n        r\"\"\"\n        Check that we can search by exponent\n        \"\"\"\n        # check that C2^4 and C2^6 show up for exponent 2\n        self.check_args(\"/Groups/Abstract/?exponent=2\", \"16.14\")\n        self.check_args(\"/Groups/Abstract/?exponent=2\", \"64.267\")\n\n    def test_search_nilpotent(self):\n        r\"\"\"\n        Check that we can search by exponent\n        \"\"\"\n        # check that 64.30 and 64.94 show up in first 50 results\n        self.check_args(\"/Groups/Abstract/?nilpotency_class=3\", \"64.30\")\n        self.check_args(\"/Groups/Abstract/?nilpotency_class=3\", \"64.94\")\n\n    def test_search_autgroup(self):\n        r\"\"\"\n        Check that we can search by automorphism group\n        \"\"\"\n        # check that 7.1  and 18.2 show up as having 6.2 as aut. group\n        self.check_args(\"/Groups/Abstract/?aut_group=6.2\", \"7.1\")\n        self.check_args(\"/Groups/Abstract/?aut_group=6.2\", \"18.2\")\n\n    def test_search_autgroup_order(self):\n        r\"\"\"\n        Check that we can search by automorphism group order\n        \"\"\"\n        # check that 36.12 and 72.2 show up as having aut. group of order 24\n        self.check_args(\"/Groups/Abstract/?aut_order=24\", \"36.12\")\n        self.check_args(\"/Groups/Abstract/?aut_order=24\", \"72.2\")\n\n    def test_search_center(self):\n        r\"\"\"\n        Check that we can search by center\n        \"\"\"\n        # check that 64.212 and 80.43 show up on first page with center 8.5\n        self.check_args(\"/Groups/Abstract/?center_label=8.5\", \"64.212\")\n        self.check_args(\"/Groups/Abstract/?center_label=8.5\", \"80.43\")\n\n    def test_search_commutator(self):\n        r\"\"\"\n        Check that we can search by commutators\n        \"\"\"\n        # check that 32.20 and 64.190 show up on first page with center 8.1\n        self.check_args(\"/Groups/Abstract/?commutator_label=8.1\", \"32.20\")\n        self.check_args(\"/Groups/Abstract/?commutator_label=8.1\", \"64.190\")\n\n    def test_search_centralquot(self):\n        r\"\"\"\n        Check that we can search by central quotients\n        \"\"\"\n        # check that 40.10 and 64.87 show up on first page\n        # with central quotient 4.2\n        self.check_args(\"/Groups/Abstract/?central_quotient=4.2\", \"40.10\")\n        self.check_args(\"/Groups/Abstract/?central_quotient=4.2\", \"64.87\")\n\n    def test_search_abelianization(self):\n        r\"\"\"\n        Check that we can search by abelianization\n        \"\"\"\n        # check that 72.19 and 96.65 show up with abelianization 8.1\n        self.check_args(\"/Groups/Abstract/?abelian_quotient=8.1\", \"72.19\")\n        self.check_args(\"/Groups/Abstract/?abelian_quotient=8.1\", \"96.65\")\n\n    def test_abelian_search(self):\n        r\"\"\"\n        Check that we can restrict to abelian or non-abelian groups only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?order=12&abelian=yes\", \"12.2\")\n        self.check_args(\"/Groups/Abstract/?order=12&abelian=no\", \"12.3\")\n        self.not_check_args(\"/Groups/Abstract/?order=12&abelian=no\", \"12.5\")\n        self.not_check_args(\"/Groups/Abstract/?order=12&abelian=yes\", \"12.4\")\n\n    def test_cyclic_search(self):\n        r\"\"\"\n        Check that we can restrict to cyclic or non-cyclic groups only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?order=24&cyclic=yes\", \"24.2\")\n        self.check_args(\"/Groups/Abstract/?order=24&cyclic=no\", \"24.3\")\n        self.not_check_args(\"/Groups/Abstract/?order=24&cyclic=yes\", \"24.4\")\n        self.not_check_args(\"/Groups/Abstract/?order=24&cyclic=no\", \"24.2\")\n\n    def test_simple_search(self):\n        r\"\"\"\n        Check that we can restrict to simple or non-simple groups only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?simple=yes\", \"60.5\")\n        self.check_args(\"/Groups/Abstract/?simple=no\", \"16.8\")\n        self.not_check_args(\"/Groups/Abstract/?simple=no\", \"29.1\")\n        self.not_check_args(\"/Groups/Abstract/?simple=yes\", \"18.4\")\n\n    # when the test was first written 60.5 was only perfect and\n    # only non-solvable group in db so next two are quite restrictive\n\n    def test_perfect_search(self):\n        r\"\"\"\n        Check that we can restrict to perfect or non-perfect groups only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?order=60&perfect=yes\", \"60.5\")\n        self.check_args(\"/Groups/Abstract/?order=60&perfect=no\", \"60.3\")\n        self.not_check_args(\"/Groups/Abstract/?order=60&perfect=no\", \"60.5\")\n        self.not_check_args(\"/Groups/Abstract/?order=60&perfect=yes\", \"60.12\")\n\n    def test_solvable_search(self):\n        r\"\"\"\n        Check that we can restrict to solvable or non-solvbable groups only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?order=60&solvable=no\", \"60.5\")\n        self.check_args(\"/Groups/Abstract/?order=60&solvable=yes\", \"60.3\")\n        self.not_check_args(\"/Groups/Abstract/?order=60&solvable=yes\", \"60.5\")\n        self.not_check_args(\"/Groups/Abstract/?order=60&solvable=no\", \"60.12\")\n\n    def test_nilpotent_search(self):\n        r\"\"\"\n        Check that we can restrict to nilpotent or non-nilpotent groups only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?order=18&nilpotent=no\", \"18.1\")\n        self.check_args(\"/Groups/Abstract/?order=18&nilpotent=yes\", \"18.5\")\n        self.not_check_args(\"/Groups/Abstract/?order=18&nilpotent=yes\", \"18.3\")\n        self.not_check_args(\"/Groups/Abstract/?order=18&nilpotent=no\", \"18.2\")\n\n    def test_direct_product_search(self):\n        r\"\"\"\n        Check that we can restrict to direct product or not only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?direct_product=no\", \"30.3\")\n        self.check_args(\"/Groups/Abstract/?direct_product=yes\", \"32.22\")\n        self.not_check_args(\"/Groups/Abstract/?direct_product=yes\", \"8.1\")\n        self.not_check_args(\"/Groups/Abstract/?direct_product=no\", \"16.11\")\n\n    def test_semidirect_product_search(self):\n        r\"\"\"\n        Check that we can restrict to semidirect product or not only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?semidirect_product=no\", \"31.1\")\n        self.check_args(\"/Groups/Abstract/?direct_product=no&semidirect_product=yes\", \"16.7\")\n        self.not_check_args(\"/Groups/Abstract/?semidirect_product=no\", \"10.1\")\n        self.not_check_args(\"/Groups/Abstract/?direct_product=no&semidirect_product=yes\", \"16.9\")\n\n    def test_famly_search(self):\n        r\"\"\"\n        Check that we can search by family\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?family=A\", [\"12.3\",\"60.5\"])\n        self.check_args(\"/Groups/Abstract/?family=C\", [\"6.2\",\"27.1\"])\n        self.check_args(\"/Groups/Abstract/?family=D\", [\"30.3\",\"48.7\"])\n        self.check_args(\"/Groups/Abstract/?family=GL\", [\"168.42\",\"480.218\"])\n        self.check_args(\"/Groups/Abstract/?family=PSL\", [\"60.5\",\"660.13\"])\n        self.check_args(\"/Groups/Abstract/?family=Q\", [\"4.1\",\"64.54\"])\n        self.check_args(\"/Groups/Abstract/?family=S\", [\"1.1\",\"120.34\"])\n        self.check_args(\"/Groups/Abstract/?family=SL\", [\"6.1\",\"720.409\"])\n        self.check_args(\"/Groups/Abstract/?family=any\", [\"6.1\", \"18.1\", \"18.2\", \"24.3\"])\n        # not checks\n        self.not_check_args(\"/Groups/Abstract/?family=A\", \"6.1\")\n        self.not_check_args(\"/Groups/Abstract/?family=C\", \"8.3\")\n        self.not_check_args(\"/Groups/Abstract/?family=D\", \"16.11\")\n        self.not_check_args(\"/Groups/Abstract/?family=GL\", \"16.11\")\n        self.not_check_args(\"/Groups/Abstract/?family=PSL\", \"16.11\")\n        self.not_check_args(\"/Groups/Abstract/?family=Q\", \"16.11\")\n        self.not_check_args(\"/Groups/Abstract/?family=S\", \"16.11\")\n        self.not_check_args(\"/Groups/Abstract/?family=SL\", \"16.11\")\n        self.not_check_args(\"/Groups/Abstract/?family=any\", \"D_4:C_2\")\n\n    def test_order_stats_search(self):\n        r\"\"\"\n        Check that we can search by order statistics\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?order_stats=1^1%2C2^3%2C3^2\", \"6.1\")\n        self.not_check_args(\"/Groups/Abstract/?order_stats=1^1%2C2^3%2C3^2\", \"10.1\")\n\n    #################################################################\n    ##################### advanced searches #########################\n    #################################################################\n\n    def test_outer_group_search(self):\n        r\"\"\"\n        Check that we can search by outer automorphism group\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?outer_group=4.2\", \"8.1\")\n        self.not_check_args(\"/Groups/Abstract/?outer_group=4.2\", \"16.8\")\n\n    def test_outer_order_search(self):\n        r\"\"\"\n        Check that we can search by order of outer automorphism group\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?outer_order=3\", \"14.1\")\n        self.not_check_args(\"/Groups/Abstract/?outer_order=3\", \"18.3\")\n\n    def test_metabelian_search(self):\n        r\"\"\"\n        Check that we can restrict to metabelian groups or not only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?metabelian=yes\", \"1.1\")\n        self.not_check_args(\"/Groups/Abstract/?metabelian=yes\", \"24.3\")\n        self.check_args(\"/Groups/Abstract/?metabelian=no\", \"24.3\")\n        self.not_check_args(\"/Groups/Abstract/?metabelian=no\", \"13.1\")\n\n    def test_metacyclic_search(self):\n        r\"\"\"\n        Check that we can restrict to metacyclic groups or not only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?metacyclic=yes\", \"1.1\")\n        self.not_check_args(\"/Groups/Abstract/?metacyclic=yes\", \"12.3\")\n        self.check_args(\"/Groups/Abstract/?metacyclic=no\", \"12.3\")\n        self.not_check_args(\"/Groups/Abstract/?metacyclic=no\", \"12.2\")\n\n    def test_almost_simple_search(self):\n        r\"\"\"\n        Check that we can restrict to almost simple groups or not only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?almost_simple=yes\", \"60.5\")\n        self.not_check_args(\"/Groups/Abstract/?almost_simple=yes\", \"8.3\")\n        self.check_args(\"/Groups/Abstract/?almost_simple=no\", \"1.1\")\n        self.not_check_args(\"/Groups/Abstract/?almost_simple=no\", \"60.5\")\n\n    def test_quasisimple_search(self):\n        r\"\"\"\n        Check that we can restrict to quasisimple groups or not only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?quasisimple=yes\", \"60.5\")\n        self.not_check_args(\"/Groups/Abstract/?quasisimple=yes\", \"7.1\")\n        self.check_args(\"/Groups/Abstract/?quasisimple=no\", \"1.1\")\n        self.not_check_args(\"/Groups/Abstract/?quasisimple=no\", \"60.5\")\n\n    def test_Agroup_search(self):\n        r\"\"\"\n        Check that we can restrict to A-group groups or not only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?Agroup=yes\", \"1.1\")\n        self.not_check_args(\"/Groups/Abstract/?Agroup=yes\", \"16.3\")\n        self.check_args(\"/Groups/Abstract/?Agroup=no\", \"8.3\")\n        self.not_check_args(\"/Groups/Abstract/?Agroup=no\", \"16.14\")\n\n    def test_Zgroup_search(self):\n        r\"\"\"\n        Check that we can restrict to Z-group groups or not only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?Zgroup=yes\", \"1.1\")\n        self.not_check_args(\"/Groups/Abstract/?Zgroup=yes\", \"12.3\")\n        self.check_args(\"/Groups/Abstract/?Zgroup=no\", \"4.2\")\n        self.not_check_args(\"/Groups/Abstract/?Zgroup=no\", \"12.2\")\n\n    def test_derived_length_search(self):\n        r\"\"\"\n        Check that we can search by derived length\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?derived_length=3\", \"24.3\")\n        self.not_check_args(\"/Groups/Abstract/?derived_length=3\", \"16.13\")\n\n    def test_frattini_label_search(self):\n        r\"\"\"\n        Check that we can search by Frattini subgroup\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?frattini_label=4.2\", \"16.2\")\n        self.not_check_args(\"/Groups/Abstract/?frattini_label=4.2\", \"5.1\")\n\n    def test_supersolvable_search(self):\n        r\"\"\"\n        Check that we can restrict to supersolvable groups or not only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?supersolvable=yes\", \"1.1\")\n        self.not_check_args(\"/Groups/Abstract/?supersolvable=yes\", \"12.3\")\n        self.check_args(\"/Groups/Abstract/?supersolvable=no\", \"12.3\")\n        self.not_check_args(\"/Groups/Abstract/?supersolvable=no\", \"12.4\")\n\n    def test_monomial_search(self):\n        r\"\"\"\n        Check that we can restrict to monomial groups or not only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?monomial=yes\", \"2.1\")\n        self.not_check_args(\"/Groups/Abstract/?monomial=yes\", \"24.3\")\n        self.check_args(\"/Groups/Abstract/?monomial=no\", \"24.3\")\n        self.not_check_args(\"/Groups/Abstract/?monomial=no\", \"16.10\")\n\n    def test_rational_search(self):\n        r\"\"\"\n        Check that we can restrict to rational groups or not only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?rational=yes\", \"2.1\")\n        self.not_check_args(\"/Groups/Abstract/?rational=yes\", \"7.1\")\n        self.check_args(\"/Groups/Abstract/?rational=no\", \"3.1\")\n        self.not_check_args(\"/Groups/Abstract/?rational=no\", \"12.4\")\n\n    def test_rank_search(self):\n        r\"\"\"\n        Check that we can search by rank\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?rank=3\", \"8.5\")\n        self.not_check_args(\"/Groups/Abstract/?rank=3\", \"18.5\")\n\n    #################################################################\n    ##################### subgroup searches #########################\n    #################################################################\n\n    def test_subgroups_search(self):\n        r\"\"\"\n        Check that subgroup search page is working\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?search_type=Subgroups\", \"1.1.1.a1.a1\")\n        self.check_args(\"/Groups/Abstract/sub/7.1.1.a1.a1\",\"Ambient group ($G$) information\")\n\n    def test_subgroup_label_search(self):\n        r\"\"\"\n        Check that subgroup search by label is working\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?search_type=Subgroups&subgroup=168.42\", \"504.157.3.a1.a1\")\n\n    def test_subgroup_order_search(self):\n        r\"\"\"\n        Check that subgroup search by label is working\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?search_type=Subgroups&subgroup_order=15\", \"45.2.3.a1.b1\")\n\n    def test_subgroup_cyclic_search(self):\n        r\"\"\"\n        Check that we can restrict to cyclic or non-cyclic subgroups only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?cyclic=yes&search_type=Subgroups\", \"2.1.1.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?cyclic=yes&search_type=Subgroups\", \"4.2.1.a1.a1\")\n        self.check_args(\"/Groups/Abstract/?cyclic=no&search_type=Subgroups\", \"4.2.1.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?cyclic=no&search_type=Subgroups\", \"8.5.4.a1.b1\")\n\n    def test_subgroup_abelian_search(self):\n        r\"\"\"\n        Check that we can restrict to abelian or non-abelian subgroups only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?abelian=yes&search_type=Subgroups\", \"6.1.2.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?abelian=yes&search_type=Subgroups\", \"6.1.1.a1.a1\")\n        self.check_args(\"/Groups/Abstract/?abelian=no&search_type=Subgroups\", \"6.1.1.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?abelian=no&search_type=Subgroups\", \"6.1.2.a1.a1\")\n\n    def test_subgroup_solvable_search(self):\n        r\"\"\"\n        Check that we can restrict to solvable or non-solvable subgroups only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?solvable=yes&search_type=Subgroups\", \"3.1.3.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?solvable=yes&search_type=Subgroups\", \"60.5.1.a1.a1\")\n        # Solvable = False requires a 30GB index to support, so we disable them for now\n        #self.check_args(\"/Groups/Abstract/?solvable=no&search_type=Subgroups\", \"60.5.1.a1.a1\")\n        #self.not_check_args(\"/Groups/Abstract/?solvable=no&search_type=Subgroups\", \"3.1.3.a1.a1\")\n\n    def test_subgroup_normal_search(self):\n        r\"\"\"\n        Check that we can restrict to normal or non-normal subgroups only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?normal=yes&search_type=Subgroups\", \"4.1.2.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?normal=yes&search_type=Subgroups\", \"6.1.3.a1.a1\")\n        self.check_args(\"/Groups/Abstract/?normal=no&search_type=Subgroups\", \"6.1.3.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?normal=no&search_type=Subgroups\", \"4.1.2.a1.a1\")\n\n    def test_subgroup_characteristic_search(self):\n        r\"\"\"\n        Check that we can restrict to characteristic or non-characteristic subgroups only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?characteristic=yes&search_type=Subgroups\", \"3.1.1.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?characteristic=yes&search_type=Subgroups\", \"4.2.2.a1.b1\")\n        self.check_args(\"/Groups/Abstract/?characteristic=no&search_type=Subgroups\", \"4.2.2.a1.b1\")\n        self.not_check_args(\"/Groups/Abstract/?characteristic=no&search_type=Subgroups\", \"3.1.1.a1.a1\")\n\n    def test_subgroup_perfect_search(self):\n        r\"\"\"\n        Check that we can restrict to perfect or non-perfect subgroups only\n        \"\"\"\n        return\n        page = self.tc.get(\"/Groups/Abstract/?perfect=yes&nontrivproper=yes&search_type=Subgroups\", follow_redirects=True).get_data(as_text=True)\n        assert \"180.19.3.a1.a1\" in page, \"Missing perfect group\"\n        assert \"4.2.2.a1.a1\" not in page, \"Incorrect perfect group\"\n        page = self.tc.get(\"/Groups/Abstract/?perfect=no&nontrivproper=yes&search_type=Subgroups\", follow_redirects=True).get_data(as_text=True)\n        assert \"4.2.2.a1.a1\" in page, \"Missing imperfect group\"\n        assert \"180.19.3.a1.a1\" not in page, \"Incorrect imperfect group\"\n\n    def test_subgroup_maximal_search(self):\n        r\"\"\"\n        Check that we can restrict to maximal or non-maximal subgroups only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?maximal=yes&search_type=Subgroups\", \"2.1.2.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?maximal=yes&search_type=Subgroups\", \"8.2.4.b1.a1\")\n        self.check_args(\"/Groups/Abstract/?maximal=no&search_type=Subgroups\", \"8.2.4.b1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?maximal=no&search_type=Subgroups\", \"2.1.2.a1.a1\")\n\n    def test_subgroup_central_search(self):\n        r\"\"\"\n        Check that we can restrict to central or non-central subgroups only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?central=yes&search_type=Subgroups\", \"3.1.1.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?central=yes&search_type=Subgroups\", \"6.1.2.a1.a1\")\n        self.check_args(\"/Groups/Abstract/?central=no&search_type=Subgroups\", \"6.1.2.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?central=no&search_type=Subgroups\", \"3.1.1.a1.a1\")\n\n    def test_subgroup_proper_search(self):\n        r\"\"\"\n        Check that we can restrict to proper or non-proper subgroups only\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?nontrivproper=yes&search_type=Subgroups\", \"4.1.2.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?nontrivproper=yes&search_type=Subgroups\", \"2.1.1.a1.a1\")\n        self.check_args(\"/Groups/Abstract/?nontrivproper=no&search_type=Subgroups\", \"2.1.1.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?nontrivproper=no&search_type=Subgroups\", \"4.1.2.a1.a1\")\n\n    def test_subgroup_ambient_label_search(self):\n        r\"\"\"\n        Check that we can search by ambient label\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?ambient=128.207&search_type=Subgroups\", \"128.207.1.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?ambient=128.207&search_type=Subgroups\", \"1.1.1.a1.a1\")\n\n    def test_subgroup_ambient_order_search(self):\n        r\"\"\"\n        Check that we can search by ambient order\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?ambient_order=128&search_type=Subgroups\", \"128.1.1.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?ambient_order=128&search_type=Subgroups\", \"1.1.1.a1.a1\")\n\n    def test_subgroup_direct_search(self):\n        r\"\"\"\n        Check that we can restrict to subgroups that are direct products\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?direct=yes&search_type=Subgroups\", \"4.2.2.a1.c1\")\n        self.not_check_args(\"/Groups/Abstract/?direct=yes&search_type=Subgroups\", \"4.1.2.a1.a1\")\n        self.check_args(\"/Groups/Abstract/?direct=no&search_type=Subgroups\", \"4.1.2.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?direct=no&search_type=Subgroups\", \"4.2.2.a1.c1\")\n\n    def test_subgroup_semidirect_search(self):\n        r\"\"\"\n        Check that we can restrict to subgroups that are semidirect products\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?split=yes&search_type=Subgroups\", \"4.2.2.a1.c1\")\n        self.not_check_args(\"/Groups/Abstract/?split=yes&search_type=Subgroups\", \"4.1.2.a1.a1\")\n        self.check_args(\"/Groups/Abstract/?split=no&search_type=Subgroups\", \"4.1.2.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?split=no&search_type=Subgroups\", \"4.2.2.a1.c1\")\n\n    def test_subgroup_hall_search(self):\n        r\"\"\"\n        Check that we can restrict to subgroups that are Hall subgroups\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?hall=yes&search_type=Subgroups\", \"2.1.1.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?hall=yes&search_type=Subgroups\", \"8.5.2.a1.b1\")\n        self.check_args(\"/Groups/Abstract/?hall=no&search_type=Subgroups\", \"4.1.2.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?hall=no&search_type=Subgroups\", \"2.1.1.a1.a1\")\n\n    def test_subgroup_sylow_search(self):\n        r\"\"\"\n        Check that we can restrict to subgroups that are Sylow subgroups\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?sylow=yes&search_type=Subgroups\", \"2.1.1.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?sylow=yes&search_type=Subgroups\", \"8.5.2.a1.f1\")\n        self.check_args(\"/Groups/Abstract/?sylow=no&search_type=Subgroups\", \"4.1.2.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?sylow=no&search_type=Subgroups\", \"8.5.1.a1.a1\")\n\n    def test_subgroup_quotient_label_search(self):\n        r\"\"\"\n        Check that we can search by quotient label\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?quotient=16.5&search_type=Subgroups\", \"32.12.16.b1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?quotient=16.5&search_type=Subgroups\", \"1.1.1.a1.a1\")\n\n    def test_subgroup_index_search(self):\n        r\"\"\"\n        Check that we can search by subgroup index\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?quotient_order=17&search_type=Subgroups\", \"34.1.17.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?quotient_order=17&search_type=Subgroups\", \"1.1.1.a1.a1\")\n\n    def test_subgroup_cyclic_quotient_search(self):\n        r\"\"\"\n        Check that we can restrict to subgroups with cyclic quotients\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?quotient_cyclic=yes&search_type=Subgroups\", \"6.1.2.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?quotient_cyclic=yes&search_type=Subgroups\", \"4.2.4.a1.a1\")\n        self.check_args(\"/Groups/Abstract/?quotient_cyclic=no&search_type=Subgroups\", \"4.2.4.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?quotient_cyclic=no&search_type=Subgroups\", \"6.1.2.a1.a1\")\n\n    def test_subgroup_abelian_quotient_search(self):\n        r\"\"\"\n        Check that we can restrict to subgroups with abelian quotients\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?quotient_abelian=yes&search_type=Subgroups\", \"1.1.1.a1.a1\")\n        self.check_args(\"/Groups/Abstract/?quotient_abelian=no&search_type=Subgroups\", \"10.1.10.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?quotient_abelian=yes&search_type=Subgroups\", \"10.1.10.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?quotient_abelian=no&search_type=Subgroups\", \"1.1.1.a1.a1\")\n\n    def test_subgroup_solvable_quotient_search(self):\n        r\"\"\"\n        Check that we can restrict to subgroups with solvable quotients\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?quotient_solvable=yes&search_type=Subgroups\", \"1.1.1.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?quotient_solvable=yes&search_type=Subgroups\", \"60.5.60.a1.a1\")\n        # The following searches require a 30GB index to support, so we disable them for now\n        #self.check_args(\"/Groups/Abstract/?quotient_solvable=no&search_type=Subgroups\", \"60.5.60.a1.a1\")\n        #self.not_check_args(\"/Groups/Abstract/?quotient_solvable=no&search_type=Subgroups\", \"1.1.1.a1.a1\")\n\n    def test_subgroup_maximal_quotient_search(self):\n        r\"\"\"\n        Check that we can restrict to subgroups with maximal quotients\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?minimal_normal=yes&search_type=Subgroups\", \"2.1.1.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?minimal_normal=yes&search_type=Subgroups\", \"4.2.4.a1.a1\")\n        self.check_args(\"/Groups/Abstract/?minimal_normal=no&search_type=Subgroups\", \"4.2.4.a1.a1\")\n        self.not_check_args(\"/Groups/Abstract/?minimal_normal=no&search_type=Subgroups\", \"2.1.1.a1.a1\")\n\n    def test_character_search(self):\n        r\"\"\"\n        Check that complex character search works\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?dim=3&search_type=ComplexCharacters\", [\n            \"21.1.3a2\", # character of C7:C3\n            \"4.0.2197.1\", # character values for several characters of 39.1\n        ])\n        self.check_args(\"/Groups/Abstract/?dim=12&faithful=yes&search_type=ComplexCharacters\", \"384.592.12a1\")\n        self.check_args(\"/Groups/Abstract/?dim=13&cyclotomic_n=39&search_type=ComplexCharacters\", [\"4563.a.13b18\", \"351.a1.a1\"]) # character label, center\n        self.check_args(\"/Groups/Abstract/?image_isoclass=12.4&kernel_order=6&search_type=ComplexCharacters\", \"72.21.2d\")\n        self.check_args(\"/Groups/Abstract/?faithful=yes&center_order=144&search_type=ComplexCharacters\", \"576.176.2c1\")\n\n    def test_highlighted_character(self):\n        r\"\"\"\n        Check that character links work\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/char_table/72.43?char_highlight=72.43.6a\", \"The row representing the character 72.43.6a is highlighted below.\")\n        self.check_args(\"/Groups/Abstract/Qchar_table/96.71?char_highlight=96.71.6a\", \"The row representing the character 96.71.6a is highlighted below.\")\n\n    def test_conj_class_search(self):\n        r\"\"\"\n        Check that conjugacy class search works\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/?group=12.4&search_type=ConjugacyClasses\", [\"3.a1.a1\", \"6A\"])\n        self.check_args(\"/Groups/Abstract/?group=128.15&search_type=ConjugacyClasses\", r\"\\OD_{16}:C_8\" #group name\n        )\n\n    def test_highlighted_conj_class(self):\n        r\"\"\"\n        Check that conjugacy class links work\n        \"\"\"\n        self.check_args(\"/Groups/Abstract/char_table/24.7?cc_highlight=4B-1&cc_highlight_i=9\", r\"The column representing the conjugacy class 4B-1 is highlighted below.\")"
  },
  {
    "type": "function",
    "file": "lmfdb/utils/completeness.py",
    "name": "__init__",
    "line_start": 1076,
    "line_end": 1720,
    "lines": 645,
    "bytes": 32288,
    "has_71": true,
    "code": "    def __init__(self):\n        # maxD[n][r2] is an integer M so that we have completeness in signature [n-2*r2, r2] as long as the absolute discriminant is at most M.\n        self._maxD = [\n            None, # n=0\n            None, # n=1\n            [2*10**6, 2*10**6], # n=2\n            [150**3, 150**3], # n=3\n            [10**7, 4*10**6, 4*10**6], # n=4\n            [10**8, 12*10**6, 12*10**6], # n=5\n            [28**6, 10**7, 10**7, 10**7], # n=6\n            [214942297, 2*10**8, 2*10**8, 2*10**8], # n=7\n            [17**8, 79259702, 20829049, 5726300, 1656109], # n=8\n            [15**9, 27316369, 27316369, 146723910, 39657561], # n=9\n            [190612177]*6, # n=10\n            [5154074557]*6, # n=11\n            [37250695278]*7, # n=12\n        ]\n\n        # num_trans[n] is the number of transitive permutation groups in degree n\n        self._num_trans = [0, 1, 1, 2, 5, 5, 16, 7, 50, 34, 45, 8, 301, 9, 63, 104, 1954, 10, 983, 8, 1117, 164, 59, 7]\n\n        # ab.get(n, {1}) gives the values of t so that nTt is abelian (for n<48)\n        self._ab = {\n            4: {1,2},\n            8: {1,2,3},\n            9: {1,2},\n            12: {1,2},\n            16: {1,2,3,4,5},\n            18: {1,2},\n            20: {1,3},\n            24: {1,2,3},\n            25: {1,2},\n            27: {1,2,4},\n            28: {1,2},\n            32: {32,33,34,36,37,39,43},\n            36: {1,2,3,4},\n            40: {1,2,7},\n            44: {1,2},\n            45: {1,2}}\n\n        # nab_gal[n] gives the values of t so that nTt is nonabelian of order n (for n<24)\n        self._nab_gal = {\n            6: {2},\n            8: {4,5},\n            10: {2},\n            12: {3,4,5},\n            14: {2},\n            16: {6,7,8,9,10,11,12,13,14},\n            18: {3,4,5},\n            20: {2,4,5},\n            21: {2},\n            22: {2}}\n\n        # nsolv.get(n, set()) gives the values of t so that nTt is nonsolvable (for n<24)\n        self._nsolv = {\n            5: {4,5},\n            6: {12,14,15,16},\n            7: {5,6,7},\n            8: {37,43,48,49,50},\n            9: {27,32,33,34},\n            10: {7,11,12,13,22,26,30,31,32,34,35,36,37,38,39,40,41,42,43,44,45},\n            11: {5,6,7,8},\n            12: {33,74,75,76,123,124,179,180,181,182,183,218,219,220,230,255,256,257,269,270,272,277,278,279,285,286,287,288,293,295,296,297,298,299,300,301},\n            13: {7,8,9},\n            14: {10,16,17,19,30,33,34,39,42,43,46,47,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63},\n            15: {5,10,15,16,20,21,22,23,24,28,29,47,53,61,62,63,69,70,72,76,77,78,83,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104},\n            16: {713,714,715,1035,1036,1080,1081,1328,1329,1504,1505,1506,1507,1508,1653,1654,1753,1801,1802,1803,1804,1805,1838,1839,1840,1842,1843,1844,1861,1873,1878,1882,1883,1902,1903,1906,1916,1938,1940,1944,1945,1946,1948,1949,1950,1951,1952,1953,1954},\n            17: {6,7,8,9,10},\n            18: {90,144,145,146,227,260,261,262,362,363,364,365,377,427,452,468,596,664,665,666,722,723,736,787,788,789,790,791,802,845,846,847,848,849,855,856,886,887,888,890,897,898,899,900,911,913,914,925,933,934,935,936,937,938,946,947,948,949,950,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983},\n            19: {7,8},\n            20: {15,30,31,32,35,36,62,63,64,65,66,70,89,116,117,118,119,120,123,145,146,147,148,149,150,151,152,172,174,175,176,177,197,198,199,200,201,202,203,204,205,206,207,208,217,218,219,220,221,222,223,224,225,226,227,228,229,230,264,265,266,267,272,273,274,275,276,277,278,279,280,281,283,284,285,287,288,289,290,291,358,362,363,365,366,367,368,369,370,373,375,376,452,453,456,457,458,459,460,461,466,467,468,531,532,539,540,541,542,543,544,545,546,547,548,555,556,558,560,561,562,564,565,566,567,568,569,570,571,573,635,654,655,656,657,658,659,663,664,665,666,667,668,669,671,672,673,674,675,676,677,679,680,681,682,684,685,686,687,688,689,690,691,692,693,694,695,752,753,754,781,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,812,855,856,857,858,885,886,887,888,912,913,914,915,916,917,918,919,920,921,922,933,934,935,936,937,938,939,947,948,949,950,951,952,953,954,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,981,985,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1006,1007,1008,1009,1010,1011,1012,1013,1015,1016,1019,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1044,1045,1046,1047,1048,1052,1053,1054,1058,1059,1060,1061,1062,1063,1064,1065,1066,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117},\n            21: {14,20,22,27,33,38,44,56,57,58,67,74,85,91,103,104,111,113,115,118,119,121,125,126,128,129,130,132,135,136,138,139,140,141,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164},\n            22: {13,14,22,26,27,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59},\n            23: {5,6,7}\n        }\n\n        # rdgrd[n][t] gives a ratio r so that grd <= rd^(1/r) for fields with Galois group nTt\n        # See https://arxiv.org/abs/1208.5806\n        self._rdgrd = [\n            [],\n            [1], # 1\n            [1], # 2\n            [1, 2/3], # 3\n            [1, 1, 1/2, 3/4, 1/2], # 4\n            [1, 4/5, 4/5, 3/5, 2/5], # 5\n            [1, 1, 2/3, 2/3, 1/2, 1/3, 2/3, 2/3, 1/2, 1/2, 1/3, 2/3, 1/3, 2/3, 1/2, 1/3],  #6\n            [1, 6/7, 6/7, 6/7, 4/7, 3/7, 2/7],  # 7\n            [1, 1, 1, 1, 1, 3/4, 1/2, 3/4, 1/2, 1/2, 1/2, 3/4, 3/4, 3/4, 1/2, 1/2,\n             1/2, 1/2, 1/2, 1/2, 1/2, 1/2, 3/4, 1/2, 7/8, 1/2, 1/4, 1/2, 1/2, 1/2,\n             1/4, 1/2, 1/2, 1/2, 1/4, 3/4, 3/4, 1/4, 1/2, 1/2, 1/2, 3/8, 3/4, 1/4,\n             3/8, 3/8, 1/4, 1/2, 3/8, 1/4],  #8\n            [1, 1, 8/9, 2/3, 8/9, 2/3, 2/3, 2/3, 8/9, 2/3, 2/3, 2/3, 2/3, 8/9, 8/9,\n             2/3, 1/3, 2/3, 2/3, 1/3, 1/3, 1/3, 2/3, 1/3, 1/3, 2/3, 7/9, 2/9, 1/3,\n             1/3, 2/9, 2/3, 1/3, 2/9],  #9\n            [1, 1, 4/5, 4/5, 4/5, 1/2, 4/5, 2/5, 1/2, 1/2, 3/5, 3/5, 3/5, 1/5, 2/5,\n             2/5, 1/2, 1/2, 1/2, 1/2, 2/5, 2/5, 1/5, 2/5, 2/5, 4/5, 2/5, 2/5, 1/5,\n             4/5, 4/5, 3/5, 2/5, 2/5, 3/5, 1/5, 2/5, 2/5, 1/5, 3/10, 3/10, 3/10,\n             1/5, 3/10, 1/5], # 10\n            [1, 10/11, 10/11, 10/11, 8/11, 8/11, 3/11, 2/11],  # 11\n            [1, 1, 1, 1, 1, 2/3, 2/3, 5/6, 2/3, 2/3, 2/3, 5/6, 5/6, 1/2, 1/2, 1/2,\n             1/2, 1/2, 1/2, 3/4, 1/3, 2/3, 2/3, 2/3, 1/3, 2/3, 2/3, 1/2, 1/3, 1/3,\n             2/3, 2/3, 5/6, 1/2, 1/2, 1/2, 1/2, 1/2, 1/2, 1/2, 1/2, 1/2, 2/3, 3/4,\n             1/2, 2/3, 2/3, 1/3, 2/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3,\n             1/2, 2/3, 1/2, 2/3, 2/3, 2/3, 2/3, 2/3, 2/3, 2/3, 1/3, 1/2, 1/2, 1/2,\n             1/2, 2/3, 2/3, 2/3, 1/3, 1/2, 1/3, 1/2, 1/2, 1/2, 1/2, 2/3, 2/3, 1/3,\n             1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3,\n             1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/2, 1/2, 2/3, 2/3, 1/2,\n             1/2, 1/2, 1/2, 1/2, 1/2, 1/2, 1/2, 2/3, 2/3, 2/3, 1/3, 1/3, 2/3, 2/3,\n             1/2, 1/4, 1/4, 1/2, 1/2, 1/6, 1/6, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3,\n             1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/2,\n             2/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/2, 1/3, 1/4, 1/4, 1/4, 1/4,\n             1/4, 1/4, 1/4, 1/4, 1/2, 1/2, 1/2, 1/2, 5/6, 1/2, 2/3, 2/3, 1/2, 1/3,\n             1/3, 1/3, 1/3, 1/6, 1/3, 1/3, 1/3, 1/3, 1/6, 1/4, 1/3, 1/3, 1/3, 1/3,\n             1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/6, 1/4, 1/4, 1/4, 1/4,\n             1/2, 1/4, 1/4, 1/4, 1/4, 5/6, 1/3, 2/3, 1/3, 1/6, 1/3, 1/6, 1/3, 1/3,\n             1/6, 1/3, 1/3, 1/3, 1/4, 1/4, 1/4, 1/4, 1/3, 1/3, 1/3, 1/3, 1/3, 1/6,\n             1/6, 1/4, 1/4, 1/4, 1/4, 1/4, 1/4, 1/4, 1/4, 1/6, 1/3, 1/3, 1/3, 1/3,\n             1/6, 1/3, 1/3, 1/4, 1/4, 1/6, 1/6, 1/4, 1/4, 1/6, 1/4, 1/4, 1/4, 1/3,\n             1/3, 1/6, 1/4, 2/3, 1/4, 1/6, 1/4, 1/4, 1/3, 1/3, 1/3, 1/6, 1/4, 1/4,\n             1/4, 1/4, 1/3, 1/6, 1/3, 1/3, 1/6, 1/4, 1/4, 1/6, 1/6, 1/6, 2/3, 1/4,\n             1/4, 1/4, 1/6, 1/4, 1/6],  # 12\n            [1, 12/13, 12/13, 12/13, 12/13, 12/13, 8/13, 3/13, 2/13], # 13\n            [1, 1, 6/7, 6/7, 6/7, 4/7, 6/7, 1/2, 3/7, 6/7, 4/7, 1/2, 1/2, 1/2, 1/2,\n             4/7, 5/7, 3/7, 4/7, 3/7, 2/7, 1/2, 1/2, 1/2, 1/2, 3/7, 2/7, 2/7, 1/7,\n             6/7, 3/7, 3/7, 4/7, 4/7, 2/7, 3/7, 3/7, 1/7, 6/7, 2/7, 2/7, 3/7, 3/7,\n             1/7, 3/7, 3/7, 3/7, 1/7, 2/7, 2/7, 1/7, 2/7, 2/7, 2/7, 2/7, 1/7, 1/7,\n             3/14, 3/14, 3/14, 1/7, 3/14, 1/7],  # 14\n            [1, 14/15, 4/5, 2/3, 4/5, 4/5, 2/3, 4/5, 2/3, 4/5, 2/3, 2/3, 2/3, 2/3,\n             4/5, 3/5, 2/3, 2/3, 2/3, 4/5, 4/5, 3/5, 3/5, 2/5, 1/3, 2/5, 2/3, 8/15,\n             2/5, 1/3, 1/3, 1/3, 2/5, 2/5, 2/5, 1/5, 1/3, 1/3, 1/3, 1/3, 2/5, 2/5,\n             2/5, 1/5, 1/5, 1/5, 4/5, 1/3, 1/3, 4/15, 1/3, 2/5, 2/5, 1/5, 1/5, 1/5,\n             1/3, 4/15, 4/15, 4/15, 2/5, 2/5, 2/5, 1/5, 1/3, 1/3, 4/15, 4/15, 1/5,\n             2/5, 1/5, 8/15, 4/15, 4/15, 4/15, 1/5, 1/5, 1/5, 1/5, 1/5, 2/15, 4/15,\n             1/5, 1/5, 1/5, 2/15, 2/15, 1/5, 1/5, 2/15, 1/5, 1/5, 2/15, 1/5, 1/5,\n             1/5, 1/5, 1/5, 1/5, 1/5, 2/15, 2/15, 1/5, 2/15], # 15\n            [1,1,1,1,1,1,1,1,1,1,1,1,1,1], #16\n            [1], #17\n            [1,1,1,1,1], #18\n            [1], #19\n            [1,1,1,1,1], #20\n            [1,1], #21\n            [1,1], #22\n            [1], #23\n        ]\n\n        od = 44.76323219095532388621866759\n        # grd[n] is a list of pairs(ts, M) so that we have completeness for fields with Galois group nTt (t in ts) as long as grd <= M\n        self._grd = {\n            2: [((1,), 1500)],\n            3: [((1,), 500),\n                ((2,), 250)],\n            4: [((1,2,3), 200), # quad over quad\n                ((4,5), 150)],\n            5: [((1,2), 200),\n                ((3,), 200),\n                ((4,5), 85)],\n            6: [((12,14), 85), # pumped up\n                ((15,16), 60),\n                ((1,2,3,5,9), 200), # just did 6t3 as composita\n                ((10,), 150),\n                ((4,5,6,7,8,11,13), 150)],\n            7: [((4,), 75),\n                ((1,3), 200),\n                ((2,), 200),\n                ((5,6), 45),\n                ((7,), 35)],\n            8: [((3,5,23,24,39,40,41,44,45,46), 100),\n                ((4,6,8,9,10,15,17,18,19,26,28,29,30,35), 125), # over 4T3\n                ((1,2,7,16,20,27), 125), # over 4T1\n                ((12,13,32,38), 250), # over 4T4\n                ((11,21,22,31), 100), # over 4T2\n                ((14,33), 150),\n                ((25,36), 200), #prim\n                ((34,), 110),\n                ((37,), 45),\n                ((42,), 135),\n                ((47,), 150),\n                ((48,), 45)],\n            9: [((16,), od),\n                ((26,), 75),\n                ((9,13,14,15,19,22,23,24,25,29), 100),\n                ((31,), 100),\n                ((18,), 150), # using 6T9\n                ((30,), 115),\n                ((1,2,4,6,7,17), 500), #C3 over C3\n                ((1,2,3,4,5,6,7,8,10,11,12,20,21,24,29,30,31), 200),\n                ((20,28), 150)],\n            10: [(tup(1,28)+(29,32,34,36,37,38,39), od),\n                 ((4,), 100), # F_5\n                 ((20,), 50),\n                 ((1,2,6), 200)], # C_5 over C_2\n            11: [((1,), 200),\n                 ((2,3), od),\n                 ((4,), 22.5)],\n            12: [((1,2,5), od),\n                 (tup(1,20)+tup(21,43)+tup(48,70)+tup(74,83), od/2),\n                 ((1,5), 150)],\n            13: [((1,), 200),\n                 ((2,), od),\n                 ((3,4,5,6), od/2)],\n            14: [((1,), od),\n                 ((2,), 50),\n                 ((3,4,5,6,7,8,9,10,11,17,18,19,21,27,28,29,33,34,35,38,40,41,42,43,44,47,48,50,51,53,56), 23)],\n            15: [((1,2), od)],\n            16: [((1,2,3,4,5), od),\n                 (tup(6,57)+tup(67,178)+tup(197,414), od/2)],\n            17: [((1,), 200),\n                 ((2,), od)],\n            18: [((1,2,3,4,5), 100)],\n            19: [((1,), 200),\n                 ((2,), od)],\n            20: [((1,2,3,4,5), 100)],\n            21: [((1,2), 100)],\n            22: [((1,), 100)],\n            23: [((1,2), od)],\n        }\n\n        quartic_2_group = (1,2,3)\n        octic_2_group = (1,2,3,4,5,6,7,8,9,10,11,15,16,17,18,19,20,21,22,26,27,28,29,30,31,35)\n        octwith4 = (1,2,4,6,7,8,10,12,13,14,16,17,19,20,21,23,27,28,30,38,40)\n        octic_with_quartic = tup(1,25)+tup(26,33)+(35,38,39,40,44)\n        octic_type_2 = (33,34,41,42,45,46,47)\n        decic_with_quint = (1,2,3,4,5,8,11,12,14,15,16,22,23,24,25,29,34,36,37,38,39)\n        decic_with_quad = (1,2,3,4,5,6,9,10,11,12,17,18,19,20,21,22,27,28,33,40,41,42,43)\n\n        # r2G[n] is a list of triples (r2, ts, M) so that we have all number fields with signature [n-2*r2, r2] and Galois group nTt (for t in ts) as long as the absolute discriminant is at most M (if M is None, there is no discriminant restriction since that signature/Galois group combination is impossible)\n        self._r2G = {\n            3: [(1, (1,), None)],\n            4: [(0, (1,2,3), 150**4),\n                (0, (4,), 10**10), # from megrez\n                (1, (1,2,4), None),\n                (1, (3,), 15**6),\n                (2, (1,2,3), 15**6),\n                (2, (4,), 10**10)], # from megrez\n            5: [(0, (1,2), 10**10),\n                (0, (4,), 2**38),\n                (1, (1,2,3,4), None),\n                (2, (1,), None),\n                (2, (2,4), 10**8)],\n            6: [# r2=0 bound for arbitrary t is 28^6\n                (0, (1,2), 250**6), # Base changing S_3 grd up, using Belabash, disc filter, moving them up; redid 6T2 by Rachel/grd, which picks up 6T1\n                (0, (3,), 10**11), # from Kluners\n                (0, (4,), 100**6), # from Kluners\n                (0, (5,), 10**10), # matches Kluners\n                (0, (6,), 50**6), # higher than Kluners\n                (0, (7,), 18**9), # Computed with a special version for even groups\n                (0, (8,), 10**12), # from Kluners\n                (0, (9,), 2*10**10), # from Kluners\n                (0, (10,), 10**11), # from Kluners\n                (0, (11,), 35**6),\n                (0, (12,), 2**38), # from A5 quintics pushed up\n                (0, (14,), 35**6), # from S5 quintics pushed up\n                # r2=1 bound for arbitrary t is 10^7\n                (1, (1,2,3,4,5,7,8,9,10,12,14,15), None),\n                (1, (6,), 10**9), # from Kluners\n                (1, (11,), 10**9), # from Kluners\n                (1, (13,), 10**8-1), # from Eric Driver\n                # r2=2 bound for arbitrary t is 10^7\n                (2, (1,2,5), None),\n                (2, (3,), 64**6), # Done by composita\n                (2, (4,), 100**6), # from Kluners\n                (2, (6,), 10**9), # from Kluners\n                (2, (7,), 18**9), # Computed with a special version for even groups\n                (2, (8,), 15**9), # JJ has double checked\n                (2, (9,10), 5*10**9), # from Eric Driver\n                (2, (11,), 10**8), # from Kluners\n                (2, (12,14), 35**6),\n                (2, (13,), 10**8-1), # from Eric Driver\n                # r2=3 bound for arbitrary t is 10^7\n                (3, (4,7,10,12,15), None),\n                (3, (1,2), 250**6), # Base changing S_3 grd up, using Belabash, disc filter, moving them up; redid 6T2 by Rachel/grd, which picks up 6T1\n                (3, (3,), 64**6), # Done by composita\n                (3, (5,), 10**10), # matches Kluners\n                (3, (6,), 10**9), # from Kluners\n                (3, (8,), 15**9), # JJ has double checked\n                (3, (9,), 5*10**9), # from Eric Driver\n                (3, (11,), 10**8), # from Kluners\n                (3, (13,), 10**8-1), # from Eric Driver\n                (3, (14,), 35**6)],\n            7: [# r2=0 bound for arbitrary t is 214942297\n                (0, (3,), 26**7), # LMFDB\n                (0, (5,), 38**7), # LMFDB\n                (0, (6,), 988410720),\n                # r2=1,2,3 bound for arbitrary t is 2*10^8\n                (1, tup(1,7), None),\n                (2, tup(1,5), None),\n                (3, (1,3,5,6), None)],\n            8: [# r2=0 bound for arbitrary t is 17^8\n                (0, (1,2), 150**8), # also 5\n                (0, (5,), 512**8), # LMFDB\n                (0, octic_with_quartic, 10**12),\n                (0, (4,), 55**8),\n                (0, (12,), 56**8),\n                (0, (37,), 30**8),\n                (0, (45,), 3*15**8),\n                # r2=1 bound for arbitrary t is 79259702\n                (1, skip(1,50,{27,32,35,38,44,47}), None),\n                (1, (27,32,35,38,44), 10**12),\n                (1, (47,), 3*10**9),\n                # r2=2 bound for arbitrary t is 20829049\n                (2, tup(1,7)+(8,12,13,14,23,25,36,37,43), None),\n                (2, octic_with_quartic, 4*10**10),\n                (2, octic_type_2, 3*10**9), # from Eric Driver, quartic over quadratic\n                (2, (45,), 3*15**8),\n                (2, (48,), 35831808), # special computation using 7t5 results\n                # r2=3 bound for arbitrary t is 5726300\n                (3, skip(1,50,{6,8,15,23,26,27,30,31,35,38,40,43,44,47}), None),\n                (3, octic_with_quartic, 144*10**8),\n                (3, (8,), 20**9),\n                (3, octic_type_2, 3*10**9), # from Eric Driver, quartic over quadratic\n                # r2=4 bound for arbitrary t is 1656109\n                (4, octic_with_quartic, 49*10**8),\n                (4, (4,), 55**8),\n                (4, (5,), 512**8), # LMFDB\n                (4, (8,), 20**9),\n                (4, octic_type_2, 3*10**9), # from Eric Driver, quartic over quadratic\n                (4, (36,), 15**8), # LMFDB\n                (4, (37,), 30**8),\n                (4, (45,), 3*15**8),\n                (4, (48,), 35831808)], # special computation using 7t5 results\n            9: [# r2=0 bound for arbitrary t is 15^9\n                (0, (1,2,6,7,17), 50**9), # C3 over C3\n                (0, (3,10,11,21), 56**9),\n                (0, (4,8,12,20,29,31), 25**9),\n                (0, (5,), 20**9), # LMFDB\n                (0, (13,22), 32**9),\n                (0, (14,15), 85.96137**9),\n                (0, (16,), 22**9),\n                (0, (18,19,24), 50**9),\n                (0, (23,), 67**9),\n                (0, (25,), 28**9),\n                (0, (26,30), 35**9),\n                # r2=1 bound for arbitrary t is 27316369\n                (1, skip(1,34,{28,31}), None),\n                (1, (28,31), 15**9),\n                # r2=2 bound for arbitrary t is 27316369\n                (2, skip(1,28,{25})+(32,), None),\n                (2, (25,), 23**9),\n                (2, (28,30,31), 15**9),\n                (2, (29,), 18**9),\n                # r2=3 bound for arbitrary t is 146723910\n                (3, (1,2,3,5,6,7,9,10,11,14,15,17,21,23,25,27,30,32,33), None),\n                (3, (4,8,12,20,28,31), 15**9), # 8 is LMFDB\n                (3, (13,16), 12**9), # LMFDB\n                (3, (18,24), 16**9),\n                (3, (19,21,26), 20**9),\n                (3, (22,29), 18**9),\n                # r2=4 bound for arbitrary t is 39657561\n                (4, (1,2,4,6,7,12,13,17,20,22,25,28,29), None),\n                (4, (3,8,10,11,30,31), 15**9), # 8 from LMFDB\n                (4, (5,), 20**9), # LMFDB\n                (4, (14,15), 18**9), # LMFDB\n                (4, (16,), 12**9), # LMFDB\n                (4, (18,24), 16**9),\n                (4, (19,21,26), 20**9),\n                (4, (23,), 17**9)], # LMFDB\n            10: [# bound for arbitrary r2,t is 190612177\n                 (0, decic_with_quad, 12*10**10),\n                 (0, decic_with_quint, 10**13),\n                 (1, skip(1,45,{14,23,29,36,39,43}), None),\n                 (1, (14,23,29,36,39), 10**13), # decic with quintic\n                 (1, (43,), 12*10**10), # decic with quadratic\n                 (2, skip(1,14,{8})+(17,18,19,20,26,30,31,32,35), None),\n                 (2, decic_with_quad, 12*10**10),\n                 (2, decic_with_quint, 10**12),\n                 (3, skip(1,45,{13,14,23,29,32,35,36,38,39,43}), None),\n                 (3, (14,23,29,36,38,39), 10**12), # decic with quintic\n                 (3, (43,), 12*10**10), # decic with quadratic\n                 (4, (1,2,6), None),\n                 (4, decic_with_quad, 12*10**10),\n                 (4, decic_with_quint, 10**12),\n                 (5, (4,7,8,10,13,15,18,20,24,25,26,28,31,32,34,37,42,44), None),\n                 (5, decic_with_quad, 12*10**10),\n                 (5, decic_with_quint, 10**12)],\n            11: [(1, tup(1,8), None),\n                 (2, tup(1,7), None),\n                 (3, tup(1,8), None),\n                 (4, tup(1,5), None),\n                 (5, (1,3,5,6,7), None)],\n        }\n\n        # nS[n] consists of specific sets S so that we have completeness in degree n for number fields unramified outside S.\n        self._nS = {\n            5: {(2,191), (3,163), (3,181), (3,211), (3,241), (3,401), (3,431), (3,461), (5,211), (5,241), (7,163), (7,181), (2,7,31), (2,7,41), (2,11,31)},\n            6: {(2,3,7)},\n            7: {(2,11), (2,13), (3,11), (11,13)}\n        }\n\n        # If nSp[n][k] = M then we have completeness in degree n for number fields unramified outside of S for all S of size k consisting of primes less than M.\n        self._nSp = {\n            2: {1: 12000, 2: 500, 3: 100, 4: 30, 5: 30, 6: 30, 7: 30, 8: 30, 9: 30, 10: 30},\n            #2: {1: 12000, 2: 500, 3: 100, 4: 30, 5: 18, 6: 18, 7: 18},\n            3: {1: 12000, 2: 500, 3: 100, 4: 30, 5: 30, 6: 30, 7: 30, 8: 30, 9: 30, 10: 30},\n            #3: {1: 12000, 2: 500, 3: 100, 4: 30, 5: 24, 6: 24, 7: 24, 8: 24, 9: 24},\n            4: {1: 12000, 2: 500, 3: 100, 4: 30, 5: 14, 6: 14},\n            5: {1: 7500, 2: 150, 3: 24, 4: 8},\n            6: {1: 2000, 2: 32},\n            7: {1: 192, 2: 6},\n        }\n\n        # nSGp[n][k] is a list of pairs (M, Gs) so that we have completeness in degree n for number fields with Galois group nTt for t in Gs and unramified outside a set S of size k all of whose primes are less than M\n        self._nSGp = {\n            6: {1: [(5000, tup(1,15))],\n                2: [(100, (12,14))],\n                3: [(12, (12,14)), (8, tup(1,15))],\n                4: [(8, tup(1,15))]},\n            7: {1: [(5000, (1,2,3)), (1500, (4,)), (228, (5,6))],\n                2: [(42, (1,)), (14, (3,)), (8, (2,)), (6, (4,))],\n                3: [(42, (1,)), (14, (3,)), (8, (2,)), (6, (4,))],\n                4: [(42, (1,)), (14, (3,)), (8, (2,))],\n                5: [(42, (1,)), (14, (3,))],\n                6: [(42, (1,)), (14, (3,))],\n                7: [(42, (1,))],\n                8: [(42, (1,))],\n                9: [(42, (1,))],\n                10: [(42, (1,))],\n                11: [(42, (1,))],\n                12: [(42, (1,))],\n                13: [(42, (1,))]},\n            8: {1: [(2500, octic_2_group), (230, octwith4), (228, (37,)), (200, (25,)), (8, octic_with_quartic), (8, (25,36)), (6, (33,34,41,42,45,46,47))],\n                2: [(250, octic_2_group), (8, octic_with_quartic), (8, (25,36)), (6, (33,34,41,42,45,46,47))],\n                3: [(8, octic_with_quartic), (8, (25,36)), (6, (33,34,41,42,45,46,47))],\n                4: [(8, (25,36))]},\n            9: {1: [(6, tup(1,19)+tup(20,26)+(28,29,31)), (6, (19,26,30))],\n                2: [(6, tup(1,19)+tup(20,26)+(28,29,31)), (6, (19,26,30))],\n                3: [(6, tup(1,19)+tup(20,26)+(28,29,31))]},\n            10: {1: [(20, (32,)), (6, decic_with_quint), (6, (6,7,9,10,13,17)), (4, (18,19,20,21,26,27,32,33))],\n                 2: [(20, (32,)), (6, decic_with_quint), (6, (6,7,9,10,13,17)), (4, (18,19,20,21,26,27,32,33))],\n                 3: [(6, decic_with_quint), (6, (6,7,9,10,13,17))]},\n            11: {1: [(200, (1,)), (5000, (2,)), (12, (3,))],\n                 2: [(8, (1,2,3))],\n                 3: [(8, (1,2,3))],\n                 4: [(8, (1,2,3))]},\n            13: {1: [(5000, (2,))]},\n            24: {1: [(1000, (1,))]},\n            25: {1: [(1000, (1,))]},\n        }\n\n        # nSGp1[n] is a list of triples (p, M, Gs) so that we have completeness in degree n for number fields with Galois group nTt for t in Gs and unramified outside {p,q} for q < M.\n        self._nSGp1 = {\n            4: [(2, 2500, quartic_2_group)],\n            5: [(3, 1328, (1,2,4)), (2, 980, (1,2,4))],\n            8: [(2, 2500, octic_2_group), (2, 200, (25,))],\n        }\n\n        # nSG[n] is a list of pairs (T, Gs) so that we have completeness in degree n for number fields with Galois group nTt for t in Gs and unramified outside S for any subset S of T.\n        self._nSG = {\n            5: [((2,3,7,11), (1,2,4)),\n                ((2,3,7,31), (1,2,4)),\n                ((2,3,11,19), (1,2,4)),\n                ((2,3,31), (1,2,4)),\n                ((2,3,37), (1,2,4)),\n                ((2,3,41), (1,2,4)),\n                ((2,3,43), (1,2,4)),\n                ((2,3,53), (1,2,4)),\n                ((2,3,61), (1,2,4)),\n                ((2,3,79), (1,2,4)),\n                ((2,3,89), (1,2,4)),\n                ((2,3,101), (1,2,4)),\n                ((2,3,103), (1,2,4)),\n                ((2,3,107), (1,2,4)),\n                ((2,3,113), (1,2,4)),\n                ((2,3,127), (1,2,4)),\n                ((2,3,131), (1,2,4)),\n                ((2,3,137), (1,2,4)),\n                ((2,3,151), (1,2,4)),\n                ((2,5,13), (1,2,4)),\n                ((2,5,17), (1,2,4)),\n                ((2,5,23), (1,2,4)),\n                ((2,5,29), (1,2,4)),\n                ((2,5,31), (1,2,4)),\n                ((2,7,17), (1,2,4)),\n                ((2,7,19), (1,2,4)),\n                ((2,7,59), (1,2,4)),\n                ((2,7,61), (1,2,4)),\n                ((2,7,71), (1,2,4)),\n                ((2,7,103), (1,2,4)),\n                ((2,7,127), (1,2,4)),\n                ((2,7,131), (1,2,4)),\n                ((2,13,71), (1,2,4)),\n                ((2,17,31), (1,2,4)),\n                ((2,19,23), (1,2,4)),\n                ((2,23,41), (1,2,4)),\n                ((2,29,31), (1,2,4)),\n                ((2,11,13), (1,2,4)),\n                ((2,11,17), (1,2,4)),\n                ((2,11,19), (1,2,4)),\n                ((2,11,23), (1,2,4)),\n                ((2,11,29), (1,2,4)),\n                ((2,11,31), (1,2,4)),\n                ((2,11,37), (1,2,4)),\n                ((2,11,41), (1,2,4)),\n                ((2,11,43), (1,2,4)),\n                ((2,11,47), (1,2,4)),\n                ((2,11,53), (1,2,4)),\n                ((2,11,59), (1,2,4)),\n                ((2,11,61), (1,2,4)),\n                ((2,11,67), (1,2,4)),\n                ((2,11,71), (1,2,4)),\n                ((2,11,73), (1,2,4)),\n                ((2,13,29), (1,2,4)),\n                ((2,13,31), (1,2,4)),\n                ((2,13,37), (1,2,4)),\n                ((2,13,41), (1,2,4)),\n                ((2,13,43), (1,2,4)),\n                ((2,13,47), (1,2,4)),\n                ((2,13,53), (1,2,4)),\n                ((2,13,59), (1,2,4)),\n                ((2,13,61), (1,2,4)),\n                ((2,13,67), (1,2,4)),\n                ((2,13,71), (1,2,4)),\n                ((2,13,73), (1,2,4)),\n                ((2,17,31), (1,2,4)),\n                ((2,19,23), (1,2,4)),\n                ((2,23,41), (1,2,4)),\n                ((2,29,31), (1,2,4)),\n                ((3,5,17), (1,2,4)),\n                ((3,5,31), (1,2,4)),\n                ((3,5,37), (1,2,4)),\n                ((3,7,11), (1,2,4)),\n                ((3,7,11,17), (1,2,4)),\n                ((3,7,17), (1,2,4)),\n                ((3,7,31), (1,2,4)),\n                ((3,7,41), (1,2,4)),\n                ((3,7,61), (1,2,4)),\n                ((3,7,101), (1,2,4)),\n                ((3,7,107), (1,2,4)),\n                ((3,7,131), (1,2,4)),\n                ((3,7,139), (1,2,4)),\n                ((3,7,163), (1,2,4)),\n                ((3,7,181), (1,2,4)),\n                ((3,11,13), (1,2,4)),\n                ((3,11,17), (1,2,4)),\n                ((3,11,19), (1,2,4)),\n                ((3,11,29), (1,2,4)),\n                ((3,11,31), (1,2,4)),\n                ((3,11,41), (1,2,4)),\n                ((3,11,61), (1,2,4)),\n                ((3,11,71), (1,2,4)),\n                ((3,11,73), (1,2,4)),\n                ((3,11,101), (1,2,4)),\n                ((3,11,103), (1,2,4)),\n                ((3,11,109), (1,2,4)),\n                ((3,13,31), (1,2,4)),\n                ((3,13,41), (1,2,4)),\n                ((3,13,61), (1,2,4)),\n                ((3,13,71), (1,2,4)),\n                ((3,13,89), (1,2,4)),\n                ((3,17,37), (1,2,4)),\n                ((3,17,41), (1,2,4)),\n                ((3,17,43), (1,2,4)),\n                ((3,17,71), (1,2,4)),\n                ((3,19,61), (1,2,4)),\n                ((3,29,37), (1,2,4)),\n                ((3,29,41), (1,2,4)),\n                ((3,31,41), (1,2,4)),\n                ((5,7,13), (1,2,4)),\n                ((5,7,17), (1,2,4)),\n                ((5,7,71), (1,2,4)),\n                ((5,7,97), (1,2,4)),\n                ((5,11,13), (1,2,4)),\n                ((5,11,19), (1,2,4)),\n                ((5,11,31), (1,2,4)),\n                ((5,11,41), (1,2,4)),\n                ((5,11,43), (1,2,4)),\n                ((5,11,71), (1,2,4)),\n                ((5,13,23), (1,2,4)),\n                ((5,151), (1,2,4)),\n                ((5,163), (1,2,4)),\n                ((5,223), (1,2,4)),\n                ((5,241), (1,2,4)),\n                ((5,367), (1,2,4)),\n                ((5,571), (1,2,4)),\n                ((5,631), (1,2,4)),\n                ((7,11,17), (1,2,4)),\n                ((7,11,23), (1,2,4)),\n                ((7,11,37), (1,2,4)),\n                ((7,13,31), (1,2,4)),\n                ((7,13,37), (1,2,4)),\n                ((7,13,41), (1,2,4)),\n                ((7,151), (1,2,4)),\n                ((7,163), (1,2,4)),\n                ((7,181), (1,2,4)),\n                ((7,191), (1,2,4)),\n                ((7,211), (1,2,4)),\n                ((7,241), (1,2,4)),\n                ((7,257), (1,2,4)),\n                ((7,281), (1,2,4)),\n                ((7,313), (1,2,4)),\n                ((7,331), (1,2,4)),\n                ((7,379), (1,2,4)),\n                ((7,401), (1,2,4)),\n                ((7,409), (1,2,4)),\n                ((7,421), (1,2,4)),\n                ((7,433), (1,2,4)),\n                ((7,431), (1,2,4)),\n                ((7,491), (1,2,4)),\n                ((7,541), (1,2,4)),\n                ((7,571), (1,2,4)),\n                ((11,13,23), (1,2,4)),\n                ((11,17,19), (1,2,4)),\n                ((11,151), (1,2,4)),\n                ((11,167), (1,2,4)),\n                ((11,179), (1,2,4)),\n                ((11,181), (1,2,4)),\n                ((11,191), (1,2,4)),\n                ((11,211), (1,2,4)),\n                ((11,251), (1,2,4)),\n                ((11,269), (1,2,4)),\n                ((11,263), (1,2,4)),\n                ((11,271), (1,2,4)),\n                ((11,281), (1,2,4)),\n                ((11,283), (1,2,4)),\n                ((11,311), (1,2,4)),\n                ((11,293), (1,2,4)),\n                ((11,307), (1,2,4)),\n                ((11,331), (1,2,4)),\n                ((11,331), (1,2,4)),\n                ((11,359), (1,2,4)),\n                ((13,191), (1,2,4)),\n                ((13,223), (1,2,4)),\n                ((13,211), (1,2,4)),\n                ((13,307), (1,2,4)),\n                ((17,227), (1,2,4)),\n                ((17,211), (1,2,4)),\n                ((19,191), (1,2,4)),\n                ((19,157), (1,2,4)),\n                ((19,181), (1,2,4)),\n                ((19,193), (1,2,4)),\n                ((23,151), (1,2,4)),\n                ((23,173), (1,2,4))],\n            8: [((2,3), (37,48)),\n                ((2,5), (37,48)),\n                ((2,29), (25,)),\n                ((7,29), (25,)),\n                ((41, 241), octic_2_group)],\n            9: [((3,7,13), (1,2,6,7,17))],\n            10: [((2,3,7), (32,)),\n                 ((2,7), decic_with_quad),\n                 ((2,5), (19,20,21,26,32)),\n                 ((3,5), (18,19,20,21,26,27,32,33))],\n            11: [((2,11), (3,)),\n                 ((3,11), (3,)),\n                 ((7,11), (3,))],\n        }"
  },
  {
    "type": "class",
    "file": "lmfdb/lfunctions/test_lfunctions.py",
    "name": "LfunctionTest",
    "line_start": 6,
    "line_end": 618,
    "lines": 613,
    "bytes": 34360,
    "has_71": true,
    "code": "class LfunctionTest(LmfdbTest):\n\n    # All tests should pass\n\n    #------------------------------------------------------\n    # Testing at least one example of each type of L-function page\n    #------------------------------------------------------\n\n    def test_LDirichlet(self):\n        L = self.tc.get('/L/Character/Dirichlet/19/9/', follow_redirects=True)\n        assert '0.4813597783' in L.get_data(as_text=True)\n        #assert 'SatoTate' in L.get_data(as_text=True)\n        #assert 'mu(9)' in L.get_data(as_text=True)\n        assert '2.13818063440820276534' in L.get_data(as_text=True)\n        assert '1-19-19.9-r0-0-0' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Character/Dirichlet/6400/3/', follow_redirects=True)\n        assert '2.131285033' in L.get_data(as_text=True) in L.get_data(as_text=True)\n        #assert 'SatoTate' in L.get_data(as_text=True)\n        #assert 'mu(320)' in L.get_data(as_text=True)\n        assert '3.1381043104275982' in L.get_data(as_text=True)\n        assert '1-80e2-6400.3-r0-0-0' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Character/Dirichlet/17/16/', follow_redirects=True)\n        assert '1.01608483' in L.get_data(as_text=True)\n        assert '1-17-17.16-r0-0-0' in L.get_data(as_text=True)\n\n        # errors\n        for url in ['/L/Character/Dirichlet/6400/2/',\n                    '/L/Character/Dirichlet/6400/6399/',\n                    'L/Character/Dirichlet/1000000000/3/',\n                    'L/Character/Dirichlet/1000000000000000000000/3/']:\n            L = self.tc.get(url, follow_redirects=True)\n            assert 'not found' in L.get_data(as_text=True)\n\n    def test_Lec(self):\n        L = self.tc.get('/L/EllipticCurve/Q/11/a/', follow_redirects=True)\n        assert '0.253841' in L.get_data(as_text=True)\n        assert 'Elliptic curve 11.a' in L.get_data(as_text=True)\n        assert 'Modular form 11.2.a.a' in L.get_data(as_text=True)\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n        assert '2-11-1.1-c1-0-0' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/2/11/1.1/c1/0/0/')\n        assert '6.362613894713' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/Q/27/a/', follow_redirects=True)\n        assert '0.5888795834' in L.get_data(as_text=True)\n        assert 'Elliptic curve 27.a' in L.get_data(as_text=True)\n        assert 'Modular form 27.2.a.a' in L.get_data(as_text=True)\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n        assert '2-3e3-1.1-c1-0-0' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/2/3e3/1.1/c1/0/0/')\n        assert '4.043044013797' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/Q/379998/d/', follow_redirects=True)\n        assert '9.364311197' in L.get_data(as_text=True)\n        assert 'Elliptic curve 379998.d' in L.get_data(as_text=True)\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n        assert '2-379998-1.1-c1-0-2' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/2/379998/1.1/c1/0/2/')\n        assert '0.8292065891985' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/2.2.5.1/31.1/a/', follow_redirects=True)\n        assert '0.3599289594' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.2.5.1-31.1-a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.2.5.1-31.2-a' in L.get_data(as_text=True)\n        assert 'Hilbert modular form 2.2.5.1-31.1-a' in L.get_data(as_text=True)\n        assert 'Hilbert modular form 2.2.5.1-31.2-a' in L.get_data(as_text=True)\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n        assert '4-775-1.1-c1e2-0-0' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/2.2.5.1/80.1/a/', follow_redirects=True)\n        assert '0.5945775518' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.2.5.1-80.1-a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 20.a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 100.a' in L.get_data(as_text=True)\n        assert 'Hilbert modular form 2.2.5.1-80.1-a' in L.get_data(as_text=True)\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n        assert '4-2000-1.1-c1e2-0-0' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/2.0.11.1/256.1/a/', follow_redirects=True)\n        assert 'Elliptic curve 2.0.11.1-256.1-a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.0.11.1-256.1-b' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.2.44.1-16.1-a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.2.44.1-16.1-c' in L.get_data(as_text=True)\n        assert 'Hilbert modular form 2.2.44.1-16.1-a' in L.get_data(as_text=True)\n        assert 'Hilbert modular form 2.2.44.1-16.1-c' in L.get_data(as_text=True)\n        assert 'Bianchi modular form 2.0.11.1-256.1-a' in L.get_data(as_text=True)\n        assert 'Bianchi modular form 2.0.11.1-256.1-b' in L.get_data(as_text=True)\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n        assert '4-176e2-1.1-c1e2-0-4' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/2.0.1879.1/1.1/a/', follow_redirects=True)\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.0.1879.1-1.1-a' in L.get_data(as_text=True)\n        assert '4-1879e2-1.1-c1e2-0-0' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/2.0.4.1/100.2/a/', follow_redirects=True)\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n        assert '0.5352579714' in L.get_data(as_text=True)\n        assert 'Bianchi modular form 2.0.4.1-100.2-a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.0.4.1-100.2-a' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Elliptic curve 20.a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 80.b' in L.get_data(as_text=True)\n        assert 'Modular form 20.2.a.a' in L.get_data(as_text=True)\n        assert 'Modular form 80.2.a.b' in L.get_data(as_text=True)\n        assert '4-40e2-1.1-c1e2-0-1' in L.get_data(as_text=True)\n        # check the zeros across factors\n        assert '2.76929890617261215013507568311' in L.get_data(as_text=True)\n        assert '4.78130792717525308450176413839' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/20/2/a/a/', follow_redirects=True)\n        assert '4.78130792717525308450176413839' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/Q/20/a/', follow_redirects=True)\n        assert '4.781307927175253' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/80/2/a/b/', follow_redirects=True)\n        assert '2.76929890617261215013507568311' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/Q/80/b/', follow_redirects=True)\n        assert '2.769298906172612' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/2.0.3.1/75.1/a/', follow_redirects=True)\n        assert 'Bianchi modular form 2.0.3.1-75.1-a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.0.3.1-75.1-a' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Elliptic curve 15.a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 45.a' in L.get_data(as_text=True)\n        assert 'Modular form 15.2.a.a' in L.get_data(as_text=True)\n        assert 'Modular form 45.2.a.a' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/2.0.8.1/2592.3/c/', follow_redirects=True)\n        assert 'Bianchi modular form 2.0.8.1-2592.3-c' in L.get_data(as_text=True)\n        assert 'Hilbert modular form 2.2.8.1-2592.1-f' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.0.8.1-2592.3-c' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.2.8.1-2592.1-f' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Elliptic curve 288.a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 576.i' in L.get_data(as_text=True)\n        assert 'Modular form 288.2.a.a' in L.get_data(as_text=True)\n\n        # check we get same L-fcn across 2 instances\n        for url in ['EllipticCurve/2.0.11.1/11.1/a/', 'ModularForm/GL2/ImaginaryQuadratic/2.0.11.1/11.1/a/']:\n            L = self.tc.get('/L/' + url, follow_redirects=True)\n            assert '4-11e3-1.1-c1e2-0-0' in L.get_data(as_text=True)\n\n    def test_Lcmf(self):\n        # test old links\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/11/2/1/a/0/', follow_redirects=True)\n        assert \"Modular form 11.2.a.a.1.1\" in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/13/12/a/a/1/1/', follow_redirects=True)\n        assert '4.84e4' in L.get_data(as_text=True) # a_7\n        assert '71.7' in L.get_data(as_text=True) # a_2\n        assert '1.51472556377341264746894823521' in L.get_data(as_text=True) # first zero\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/13/12/a/a/', follow_redirects=True)\n        assert '1.51472556377341264746894823521' in L.get_data(as_text=True) # first zero\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        for i in range(1,6):\n            assert 'Modular form 13.12.a.a.1.%d' % i in L.get_data(as_text=True)\n        assert '371293' in L.get_data(as_text=True) # L_3 root\n        assert '2.54e3' in L.get_data(as_text=True) # a_13\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/7/3/b/a/', follow_redirects=True)\n        assert '0.332981' in L.get_data(as_text=True)\n        assert '2-7-7.6-c2-0-0' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/2/7/7.6/c2/0/0/')\n        assert '7.21458918128718444354242474222' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/1/18/a/a/', follow_redirects=True)\n        assert '1.34e12' in L.get_data(as_text=True) # a26\n        assert '2-1-1.1-c17-0-0' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/2/1/1.1/c17/0/0/')\n        assert '18.17341115038590061946085869072' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/13/4/c/a/3/1/', follow_redirects=True)\n        assert '0.523757' in L.get_data(as_text=True) and '0.530517' in L.get_data(as_text=True)\n        assert '(16 + 27.7<em>i</em>)' in L.get_data(as_text=True)\n        assert 'Dual L-function' in L.get_data(as_text=True)\n        assert '2-13-13.3-c3-0-2' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/2/13/13.3/c3/0/2/')\n        assert '5.68016097036963500634962429051' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/11/2/a/a/', follow_redirects=True)\n        assert '0.253841' in L.get_data(as_text=True)\n        assert 'Elliptic curve 11.a' in L.get_data(as_text=True)\n        assert 'Modular form 11.2.a.a' in L.get_data(as_text=True)\n        #FIXME fill ST info in origins = CMFs\n        #assert '/SatoTateGroup/1.2.' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/13/2/e/a/', follow_redirects=True)\n        assert 'Genus 2 curve 169.a' in L.get_data(as_text=True)\n        assert 'Modular form 13.2.e.a' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Modular form 13.2.e.a.4.1' in L.get_data(as_text=True)\n        assert 'Modular form 13.2.e.a.10.1' in L.get_data(as_text=True)\n        #assert '/SatoTateGroup/1.4.E_6' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/18/2/c/a/', follow_redirects=True)\n        assert 'Genus 2 curve 324.a' in L.get_data(as_text=True)\n        assert 'Modular form 18.2.c.a' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Modular form 18.2.c.a.7.1' in L.get_data(as_text=True)\n        assert 'Modular form 18.2.c.a.13.1' in L.get_data(as_text=True)\n        #assert '/SatoTateGroup/1.4.E_3' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/490/2/a/a/', follow_redirects=True)\n        assert 'Modular form 490.2.a.a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 490.a' in L.get_data(as_text=True)\n        assert '0.729971' in L.get_data(as_text=True)\n        assert r'(2,\\ 490,\\ (\\ :1/2),\\ 1)' in L.get_data(as_text=True)\n        assert '0.940863335931152039286421559408' in L.get_data(as_text=True)\n        assert '1 + 7 T + p T^{2}' in L.get_data(as_text=True)\n        assert 'Trivial' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/Q/490/a/', follow_redirects=True)\n        assert '0.9408633359311520' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/350/2/e/k/51/1/', follow_redirects=True)\n        assert 'Modular form 350.2.e.k.51.1' in L.get_data(as_text=True)\n        assert 'Dual L-function' in L.get_data(as_text=True)\n        assert r'\\chi_{350} (51, \\cdot )' in L.get_data(as_text=True)\n        assert r'(2,\\ 350,\\ (\\ :1/2),\\ 0.991 + 0.126i)' in L.get_data(as_text=True)\n        assert '2.00692' in L.get_data(as_text=True)\n        assert '0.127359' in L.get_data(as_text=True)\n        assert '1 + 6T + 29T^{2}' in L.get_data(as_text=True)\n        assert '1.68486586956382681209348921118' in L.get_data(as_text=True)\n        assert '3.10207045712088492456262227600' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/350/2/e/k/151/1/', follow_redirects=True)\n        assert 'Modular form 350.2.e.k.151.1' in L.get_data(as_text=True)\n        assert 'Dual L-function' in L.get_data(as_text=True)\n        assert r'\\chi_{350} (151, \\cdot )' in L.get_data(as_text=True)\n        assert r'(2,\\ 350,\\ (\\ :1/2),\\ 0.991 - 0.126i)' in L.get_data(as_text=True)\n        assert '2.00692' in L.get_data(as_text=True)\n        assert '0.127359' in L.get_data(as_text=True)\n        assert '1 + 6T + 29T^{2}' in L.get_data(as_text=True)\n        assert '1.68486586956382681209348921118' in L.get_data(as_text=True)\n        assert '3.10207045712088492456262227600' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/350/2/e/k/', follow_redirects=True)\n        assert 'Modular form 350.2.e.k.151.1' in L.get_data(as_text=True)\n        assert 'Modular form 350.2.e.k.51.1' in L.get_data(as_text=True)\n        assert 'Modular form 350.2.e.k' in L.get_data(as_text=True)\n        assert r'(4,\\ 122500,\\ (\\ :1/2, 1/2),\\ 1)' in L.get_data(as_text=True)\n        assert '4.04397' in L.get_data(as_text=True)\n        assert '1.68486586956382681209348921118' in L.get_data(as_text=True)\n        assert '3.10207045712088492456262227600' in L.get_data(as_text=True)\n        assert '( 1 + T + p T^{2} )( 1 + 7 T + p T^{2} )' in L.get_data(as_text=True)\n        assert '( 1 - 2 T + p T^{2} )^{2}' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/129/2/a/d/', follow_redirects=True)\n        assert 'Modular form 129.2.a.d' in L.get_data(as_text=True)\n        for i in range(1,4):\n            assert 'Modular form 129.2.a.d.1.%d' % i in L.get_data(as_text=True)\n\n        assert '1.04395' in L.get_data(as_text=True)\n        assert '( 1 + T )^{3}' in L.get_data(as_text=True)\n        assert '1.55341889806322957326786121161' in L.get_data(as_text=True)\n        assert r'S_4\\times C_2' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/60/2/i/a/', follow_redirects=True)\n        assert 'Modular form 60.2.i.a' in L.get_data(as_text=True)\n        for c in [17, 53]:\n            for i in range(1,3):\n                assert 'Modular form 60.2.i.a.%d.%d' % (c,i) in L.get_data(as_text=True), 'Modular form 60.2.%d.a.%d' % (c,i)\n        assert '0.676894' in L.get_data(as_text=True)\n        assert '2.15777231959226116393597609132' in L.get_data(as_text=True)\n        assert '1 - 2 T + 2 T^{2} - 2 p T^{3} + p^{2} T^{4}' in L.get_data(as_text=True)\n        assert r'(8,\\ 12960000,\\ (\\ :1/2, 1/2, 1/2, 1/2),\\ 1)' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/207/2/i/b/', follow_redirects=True)\n        for c in [55,64,73,82,100,118,127,154,163,190]:\n            assert 'Modular form 207.2.i.b.%d.1' % c in L.get_data(as_text=True), 'Modular form 207.2.%d.d.1' % c\n        assert '0.233961' in L.get_data(as_text=True)\n        assert '0.096070203083029088532433951629' in L.get_data(as_text=True)\n        assert 'T + T^{2} + 21 T^{3} - 219 T^{4} - 1365 T^{5} - 219 p T^{6} + 21 p^{2} T^{7} + p^{3} T^{8}' in L.get_data(as_text=True)\n        assert 'Plot not available' in L.get_data(as_text=True)\n\n    def test_Lhmf(self):\n        L = self.tc.get('/L/ModularForm/GL2/TotallyReal/2.2.5.1/holomorphic/2.2.5.1-31.1-a/0/0/', follow_redirects=True)\n        assert '0.3599289594' in L.get_data(as_text=True)\n        assert '4-775-1.1-c1e2-0-0' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/4/775/1.1/c1e2/0/0/', follow_redirects=True)\n        assert '3.67899147579' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/TotallyReal/2.2.8.1/holomorphic/2.2.8.1-9.1-a/0/0/', follow_redirects=True)\n        assert '0.22396252' in L.get_data(as_text=True)\n        assert '4-24e2-1.1-c1e2-0-0' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/4/24e2/1.1/c1e2/0/0/', follow_redirects=True)\n        assert '3.03882077536' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/TotallyReal/2.2.24.1/holomorphic/2.2.24.1-1.1-a/0/0/', follow_redirects=True)\n        assert '0.28781' in L.get_data(as_text=True)\n        assert '4-24e2-1.1-c1e2-0-1' in L.get_data(as_text=True)\n\n    # def test_Lgl2maass(self):\n    #     L = self.tc.get('/L/ModularForm/GL2/Q/Maass/4f5695df88aece2afe000021/')\n    #     assert '1 + 4.54845492142i' in L.get_data(as_text=True)\n    #     # FIXME\n    #     # these zeros cannot be correct to this much precision\n    #     # the eigenvalue was computed to lower precision\n    #     L = self.tc.get('/L/Zeros/ModularForm/GL2/Q/Maass/4f5695df88aece2afe000021/')\n    #     assert '7.8729423429' in L.get_data(as_text=True)\n    #     L = self.tc.get('/L/ModularForm/GL2/Q/Maass/4f55571b88aece241f000013/')\n    #     assert '5.09874190873i' in L.get_data(as_text=True)\n    #     L = self.tc.get('/L/Zeros/ModularForm/GL2/Q/Maass/4f55571b88aece241f000013/')\n    #     assert '11.614970337' in L.get_data(as_text=True)\n    #     L = self.tc.get('/L/ModularForm/GL2/Q/Maass/4cb8503a58bca91458000032/')\n    #     assert '1 + 9.53369526135i' in L.get_data(as_text=True)\n\n    def test_Lgl3maass(self):\n        L = self.tc.get('/L/ModularForm/GL3/Q/Maass/1/1/20.39039_14.06890/-0.0742719/', follow_redirects=True)\n        assert '0.0742' in L.get_data(as_text=True)\n        assert '3-1-1.1-r0e3-p14.07p20.39m34.46-0' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/3/1/1.1/r0e3/p14.07p20.39m34.46/0/', follow_redirects=True)\n        assert '0.9615558824' in L.get_data(as_text=True)\n\n    def test_Lgl4maass(self):\n        L = self.tc.get('/L/ModularForm/GL4/Q/Maass/1/1/16.89972_2.272587_-6.03583/0.55659019/', follow_redirects=True)\n        assert '4-1-1.1-r0e4-p2.27m6.04m13.14p16.90-0' in L.get_data(as_text=True)\n        assert '0.556' in L.get_data(as_text=True)\n        assert 'Graph' in L.get_data(as_text=True)\n        assert '16.89972715592' in L.get_data(as_text=True)\n        assert '4-1-1.1-r0e4-p2.27m6.04m13.14p16.90-0' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/4/1/1.1/r0e4/p2.27m6.04m13.14p16.90/0/')\n        assert '16.18901597' in L.get_data(as_text=True)\n\n    # def test_Lsym2EC(self):\n    #     L = self.tc.get('/L/SymmetricPower/2/EllipticCurve/Q/11/a/')\n    #     assert '0.8933960461' in L.get_data(as_text=True)\n    #     L = self.tc.get('/L/Zeros/SymmetricPower/2/EllipticCurve/Q/11/a/')\n    #     assert '4.7345954' in L.get_data(as_text=True)\n\n    # def test_Lsym3EC(self):\n    #     L = self.tc.get('/L/SymmetricPower/3/EllipticCurve/Q/11/a/')\n    #     assert '1.140230868' in L.get_data(as_text=True)\n\n    # def test_Lsym4EC(self):\n    #     L = self.tc.get('/L/SymmetricPower/4/EllipticCurve/Q/11/a/')\n    #     assert '0.6058003920' in L.get_data(as_text=True)\n\n    # def test_LsymHighEC(self):\n    #     L = self.tc.get('/L/SymmetricPower/5/EllipticCurve/Q/11/a/')\n    #     assert '161051' in L.get_data(as_text=True)\n    #     L = self.tc.get('/L/SymmetricPower/6/EllipticCurve/Q/11/a/')\n    #     assert '1771561' in L.get_data(as_text=True)\n    #     L = self.tc.get('/L/SymmetricPower/11/EllipticCurve/Q/11/a/')\n    #     assert '11^{11}' in L.get_data(as_text=True)\n\n    # def test_Ldedekind(self):\n    #     L = self.tc.get('/L/NumberField/3.1.23.1/')\n    #     assert '0.2541547348' in L.get_data(as_text=True)\n    #     L = self.tc.get('/L/Zeros/NumberField/3.1.23.1/')\n    #     assert '5.1156833288' in L.get_data(as_text=True)\n    #     L = self.tc.get('/L/NumberField/5.5.2337227518904161.1/')\n    #     assert '3718837' in L.get_data(as_text=True)\n    #     L = self.tc.get('L/NumberField/14.14.28152039412241052225421312.1/')\n    #     assert 'chi_{172}' in L.get_data(as_text=True) and 'chi_{43}' in L.get_data(as_text=True)\n\n    # def test_Ldedekindabelian(self):\n    #     L = self.tc.get('/L/NumberField/3.3.81.1/')\n    #     assert 'Graph' in L.get_data(as_text=True)\n\n    def test_Lartin(self):\n        L = self.tc.get('/L/ArtinRepresentation/2.23.3t2.1c1/', follow_redirects=True)\n        assert '0.1740363269' in L.get_data(as_text=True)\n        # same in new labels\n        L = self.tc.get('/L/ArtinRepresentation/2.23.3t2.b.a/', follow_redirects=True)\n        assert '0.1740363269' in L.get_data(as_text=True)\n        L = self.tc.get('/L/Zeros/2/23/23.22/c0/0/0', follow_redirects=True)\n        assert '5.1156833288' in L.get_data(as_text=True)\n    #     L = self.tc.get('/L/ArtinRepresentation/4.1609.5t5.a.a/', follow_redirects=True)\n    #     assert '0.0755586459' in L.get_data(as_text=True)\n    #     L = self.tc.get('/L/Zeros/ArtinRepresentation/4.1609.5t5.1c1/', follow_redirects=True)\n    #     assert '3.50464340448' in L.get_data(as_text=True)\n\n    # def test_Lhgm(self):\n    #     L = self.tc.get('/L/Motive/Hypergeometric/Q/A4_B2.1/t-1.1')\n    #     assert 'Graph' in L.get_data(as_text=True)\n\n    def test_Lgenus2(self):\n        L = self.tc.get('/L/Genus2Curve/Q/169/a/', follow_redirects=True)\n        assert '0.0904903908' in L.get_data(as_text=True)\n        assert '4-13e2-1.1-c1e2-0-0' in L.get_data(as_text=True)\n        #assert 'SatoTate' in L.get_data(as_text=True)\n        #assert 'E_6' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Zeros/4/13e2/1.1/c1e2/0/0/')\n        assert '5.0682346354' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Genus2Curve/Q/15360/f/', follow_redirects=True)\n        assert 'Genus 2 curve 15360.f' in L.get_data(as_text=True)\n        assert '4-15360-1.1-c1e2-0-5' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Zeros/4/15360/1.1/c1e2/0/5/', follow_redirects=True)\n        assert '2.15654793578' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Genus2Curve/Q/2457/b/', follow_redirects=True)\n        assert 'Elliptic curve 2.0.3.1-273.1-a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.0.3.1-273.4-a' in L.get_data(as_text=True)\n        assert 'Genus 2 curve 2457.b' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Genus2Curve/Q/363/a/', follow_redirects=True)\n        assert 'Genus 2 curve 363.a' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Elliptic curve 11.a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 33.a' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Genus2Curve/Q/360/a/', follow_redirects=True)\n        assert 'Genus 2 curve 360.a' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Elliptic curve 15.a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 24.a' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Genus2Curve/Q/336/a/', follow_redirects=True)\n        assert 'Genus 2 curve 336.a' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Elliptic curve 14.a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 24.a' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Genus2Curve/Q/324/a/', follow_redirects=True)\n        assert 'Genus 2 curve 324.a' in L.get_data(as_text=True)\n        assert 'Modular form 18.2.c.a' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Genus2Curve/Q/294/a/', follow_redirects=True)\n        assert 'Genus 2 curve 294.a' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Elliptic curve 14.a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 21.' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Genus2Curve/Q/256/a/', follow_redirects=True)\n        assert 'Genus 2 curve 256.a' in L.get_data(as_text=True)\n        assert 'Modular form 16.2.e.a' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Genus2Curve/Q/169/a/', follow_redirects=True)\n        assert 'Genus 2 curve 169.a' in L.get_data(as_text=True)\n        assert 'Modular form 13.2.e.a' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Modular form 13.2.e.a.4.1' in L.get_data(as_text=True)\n        assert 'Modular form 13.2.e.a.10.1' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Genus2Curve/Q/196/a/', follow_redirects=True)\n        assert 'Genus 2 curve 196.a' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Elliptic curve 14.a' in L.get_data(as_text=True)\n        assert 'Modular form 14.2.a.a' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Genus2Curve/Q/576/a/', follow_redirects=True)\n        assert 'Hilbert modular form 2.2.8.1-9.1-a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.2.8.1-9.1-a' in L.get_data(as_text=True)\n        assert 'Genus 2 curve 576.a' in L.get_data(as_text=True)\n        assert 'Modular form 24.2.d.a' in L.get_data(as_text=True)\n        assert 'Modular form 24.2.d.a.13.1' in L.get_data(as_text=True)\n        assert 'Modular form 24.2.d.a.13.2' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Genus2Curve/Q/20736/i/', follow_redirects=True)\n        assert 'Bianchi modular form 2.0.8.1-324.3-a' in L.get_data(as_text=True)\n        assert 'Hilbert modular form 2.2.24.1-36.1-a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.0.8.1-324.3-a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 2.2.24.1-36.1-a' in L.get_data(as_text=True)\n        assert 'Genus 2 curve 20736.i' in L.get_data(as_text=True)\n        assert 'Origins of factors' in L.get_data(as_text=True)\n        assert 'Elliptic curve 36.a' in L.get_data(as_text=True)\n        assert 'Elliptic curve 576.f' in L.get_data(as_text=True)\n        assert 'Modular form 36.2.a.a' in L.get_data(as_text=True)\n        assert 'Modular form 36.2.a.a.1.1' in L.get_data(as_text=True)\n        assert 'Modular form 576.2.a.f' in L.get_data(as_text=True)\n        assert 'Modular form 576.2.a.f.1.1' in L.get_data(as_text=True)\n\n    def test_Llhash(self):\n        r\"\"\"\n        Checking L/lhash/ pages\n        \"\"\"\n        # The hash for /L/EllipticCurve/Q/324016/h\n        L = self.tc.get('/L/lhash/1938322253992393114/', follow_redirects=True)\n        assert '324016' in L.get_data(as_text=True), \"Missing data in /L/lhash/1938322253992393114/\"\n        assert 'Dual L-function' not in L.get_data(as_text=True)\n        assert '2-324016-1.1-c1-0-6' in L.get_data(as_text=True)\n        assert 'Elliptic curve 324016.h' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/lhash/dirichlet_L_6253.458/', follow_redirects=True)\n        assert '1.0612' in L.get_data(as_text=True), \"Missing data in /L/lhash/dirichlet_L_6253.458/\"\n        assert '1-6253-6253.458-r1-0-0' in L.get_data(as_text=True)\n        assert 'Dual L-function' in L.get_data(as_text=True)\n        assert 'Character/Dirichlet/6253/458' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Lhash/7200459463482029776252499748763/', follow_redirects=True)\n        assert 'Dual L-function' in L.get_data(as_text=True)\n        assert 'Modular form 13.4.c.a.3.1' in L.get_data(as_text=True)\n        assert 'ModularForm/GL2/Q/holomorphic/13/4/c/a/3/1' in L.get_data(as_text=True)\n\n    def test_tracehash(self):\n        L = self.tc.get('/L/tracehash/7200459463482029776252499748763/', follow_redirects=True)\n        assert 'trace_hash = 7200459463482029776252499748763 not in [0, 2^61]' in L.get_data(as_text=True)\n        L = self.tc.get('/L/tracehash/1938322253992393114/', follow_redirects=True)\n        assert '324016' in L.get_data(as_text=True), \"Missing data in /L/tracehash/1938322253992393114/\"\n        assert 'Dual L-function' not in L.get_data(as_text=True)\n        assert '2-324016-1.1-c1-0-6' in L.get_data(as_text=True)\n        assert 'Elliptic curve 324016.h' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/tracehash/1127515239490717889/', follow_redirects=True)\n        assert 'Elliptic curve 37.a' in L.get_data(as_text=True)\n        assert 'Dual L-function' not in L.get_data(as_text=True)\n\n    def test_jump(self):\n        self.check_args('/L/?jump=4-167040-1.1-c1e2-0-7', 'Functional equation')\n        self.check_args('/L/?jump=3-1-1.1-r0e3-m9.92m29.99p39.92-0', 'Functional equation')\n        self.check_args('/L/?jump=2-1.2.1-r0e2-0-4', 'Malformed L-function label')\n        self.check_args('/L/?jump=2-1-2.1-r0e2-0-4', 'not found')\n\n    #------------------------------------------------------\n    # Testing plots and zeros of L-functions\n    #------------------------------------------------------\n\n    def test_LDirichletZeros(self):\n        L = self.tc.get('/L/Character/Dirichlet/5/2/', follow_redirects=True)\n        assert '6.18357819' in L.get_data(as_text=True)\n\n    def test_LecZeros(self):\n        # EC 56.a or MF 56.2.a.a\n        L = self.tc.get('/L/Zeros/2/56/1.1/c1/0/0/')\n        assert '2.791838' in L.get_data(as_text=True)\n\n    def test_LecPlot(self):\n        L = self.tc.get('/L/Plot/2/56/1.1/c1/0/0/')\n        assert b'PNG' in L.get_data()\n\n    def test_LcmfPlot(self):\n        # ModularForm/GL2/Q/holomorphic/14/6/a/a/\n        L = self.tc.get('/L/Plot/2/14/1.1/c5/0/0/')\n        assert b'PNG' in L.get_data()\n\n    # def test_LartinPlot(self):\n    #     L = self.tc.get('/L/Plot/ArtinRepresentation/2.68.4t3.b.a/')\n    #     assert b'PNG' in L.get_data()\n\n    # def test_LHGMZeros(self):\n    #     L = self.tc.get('/L/Zeros/Motive/Hypergeometric/Q/A2.2.2.2_B1.1.1.1/t-1.1/')\n    #     assert '4.4977' in L.get_data(as_text=True)\n\n    # ------------------------------------------------------\n    # Testing error messages\n    # ------------------------------------------------------\n\n    def test_errorMessages(self):\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/5/k/4/a/1/')\n        assert 'The requested URL was not found on the server' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Character/Dirichlet/9/10/')\n        assert 'L-function for dirichlet character with label 9.10 not found' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/EllipticCurve/Q/11/b/')\n        assert 'L-function for elliptic curve isogeny class with label 11.b not found' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/5/6/d/c/')\n        assert 'L-function for classical modular form with label 5.6.d.c not found' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL3/Q/Maass/1/1/16.40312_0.171121/-0.421999/')\n        assert 'L-function for modular form ModularForm/GL3/Q/Maass/1/1/16.40312_0.171121/-0.421999/ not found' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/TotallyReal/2.2.5.1/holomorphic/2.2.5.1-31.1-a/2/0/')\n        assert 'not in the database' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ModularForm/GL2/TotallyReal/2.2.5.1/holomorphic/2.2.5.1-31.5-a/0/0/')\n        assert 'not in the database' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/Genus2Curve/Q/247/a/')\n        assert 'L-function for genus 2 curve with label 247.a not found' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/NumberField/2.2.7.1/')\n        assert 'not in the database' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/ArtinRepresentation/3.231.4t5.a.a/')\n        assert 'not in the database' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/SymmetricPower/2/EllipticCurve/Q/37/d/')\n        assert 'not in the database' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/SymmetricPower/2/EllipticCurve/Q/27/a/')\n        assert 'not in the database' in L.get_data(as_text=True)\n\n    # ------------------------------------------------------\n    # Testing congruences in search\n    # ------------------------------------------------------\n\n    def test_trace_search_mod_q(self):\n        L = self.tc.get('L/rational?conductor=37&degree=2&search_type=Traces&an_constraints=a11+%3D1&an_modulo=3&view_modp=reductions')\n        assert '2-37-1.1-c1-0-1' in L.get_data(as_text=True)\n        assert '2-37-1.1-c1-0-0' not in L.get_data(as_text=True)\n\n    # ------------------------------------------------------\n    # Testing units not tested above\n    # ------------------------------------------------------\n\n    def test_paintSVGall(self):\n        svg = paintSvgFileAll([[\"GSp4\", 1]])\n        assert \"12.4687\" in svg\n\n    def test_underlying_data(self):\n        data = self.tc.get(\"/L/data/2-289379-1.1-c1-0-0\").get_data(as_text=True)\n        assert (\"lfunc_lfunctions\" in data and \"st_group\" in data\n                and \"lfunc_search\" in data and \"euler19\" in data\n                and \"lfunc_instances\" in data and \"Lhash_array\" in data)\n\n    def test_trivial_chi(self):\n        L = self.tc.get('/L/4/13e2/1.1/c1e2/0/0')\n        assert 'Trivial' in L.get_data(as_text=True)\n\n        L = self.tc.get('/L/4/851472/1.1/c1e2/0/0')\n        assert 'Trivial' in L.get_data(as_text=True)"
  },
  {
    "type": "class",
    "file": "lmfdb/classical_modular_forms/test_cmf.py",
    "name": "CmfTest",
    "line_start": 9,
    "line_end": 683,
    "lines": 675,
    "bytes": 37176,
    "has_71": true,
    "code": "class CmfTest(LmfdbTest):\n    def runTest(self):\n        pass\n\n    def test_expression_divides(self):\n        # checks search of conductors dividing 1000\n        self.check_args('/ModularForm/GL2/Q/holomorphic/?level_type=divides&level=1000', '40.2.k.a')\n\n    def test_browse_page(self):\n        r\"\"\"\n        Check browsing for elliptic modular forms\n        \"\"\"\n        data = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/\").get_data(as_text=True)\n        assert '?search_type=Dimensions&dim=1' in data\n        assert '?search_type=SpaceDimensions&char_order=1' in data\n        assert \"/stats\" in data\n        data = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?search_type=SpaceDimensions\",follow_redirects=True).get_data(as_text=True)\n        assert r'<a href=\"/ModularForm/GL2/Q/holomorphic/23/12/\">229</a>' in data\n        data = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?search_type=SpaceDimensions&char_order=1\", follow_redirects=True).get_data(as_text=True)\n        assert r'<a href=\"/ModularForm/GL2/Q/holomorphic/18/4/a/\">1</a>' in data\n\n    def test_stats(self):\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/stats\")\n        assert \"Classical modular forms: Statistics\" in page.get_data(as_text=True)\n        assert \"Distribution\" in page.get_data(as_text=True)\n        assert \"proportion\" in page.get_data(as_text=True)\n        assert \"count\" in page.get_data(as_text=True)\n        assert \"CM disc\" in page.get_data(as_text=True)\n        assert \"RM disc\" in page.get_data(as_text=True)\n        assert \"inner twists\" in page.get_data(as_text=True)\n        assert \"projective image\" in page.get_data(as_text=True)\n        assert \"character order\" in page.get_data(as_text=True)\n\n    def test_dynamic_stats(self):\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/dynamic_stats?char_order=2&col1=level&buckets1=1-1000%2C1001-10000&proportions=recurse&col2=weight&buckets2=1-8%2C9-316&search_type=DynStats\")\n        data = page.get_data(as_text=True)\n        for x in [\"16576\", \"24174\", \"6172\", \"20.90%\", \"30.46%\", \"13.26%\"]:\n            assert x in data\n\n    def test_sidebar(self):\n        data = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/Labels\").get_data(as_text=True)\n        assert 'Labels for classical modular forms' in data\n        data = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/Completeness\").get_data(as_text=True)\n        assert \"Completeness of classical modular form data\" in data\n        data = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/Reliability\").get_data(as_text=True)\n        assert \"Reliability of classical modular form data\" in data\n        data = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/Source\").get_data(as_text=True)\n        assert \"Source of classical modular form data\" in data\n\n    def test_badp(self):\n        data = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?level_primes=7&count=100\").get_data(as_text=True)\n        assert '273.1.o.a' in data\n        assert '56.1.h.a' in data\n        assert '14.2.a.a' in data\n        assert '168' in data\n\n    def test_level_bread(self):\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/1124/',\n                           follow_redirects=True)\n        assert '1124.1.d.a' in page.get_data(as_text=True)\n        assert r'\\Q(\\sqrt{-281})' in page.get_data(as_text=True)\n        assert '1124.1.d.d' in page.get_data(as_text=True)\n        assert r'\\Q(\\zeta_{20})^+' in page.get_data(as_text=True)\n        assert '1124.1.ba.a' in page.get_data(as_text=True)\n        assert r'\\Q(\\zeta_{35})' in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/1124/?weight=10&level=10', follow_redirects=True)\n        assert 'Results (4 matches)' in page.get_data(as_text=True)\n        assert '10.10.b.a' in page.get_data(as_text=True)\n        assert '2580' in page.get_data(as_text=True)\n\n    @unittest.skip(\"Long tests for many newform spaces, should be run & pass before any release\")\n    def test_many(self):\n        from sage.all import ZZ\n        for Nk2 in range(1, 2001):\n            for N in ZZ(Nk2).divisors():\n                k = (Nk2 // N).sqrt()\n                if k in ZZ and k > 1:\n                    print(\"testing (N, k) = (%s, %s)\" % (N, k))\n                    url = \"/ModularForm/GL2/Q/holomorphic/{0}/{1}/\".format(N, k)\n                    rv = self.tc.get(url,follow_redirects=True)\n                    self.assertTrue(rv.status_code == 200,\"Request failed for {0}\".format(url))\n                    assert str(N) in rv.get_data(as_text=True)\n                    assert str(k) in rv.get_data(as_text=True)\n                    assert str(N)+'.'+str(k) in rv.get_data(as_text=True)\n\n    def test_favorite(self):\n        favorite_newform_labels = [\n            [('23.1.b.a','Smallest analytic conductor'),\n             ('11.2.a.a','First weight 2 form'),\n             ('39.1.d.a','First D2 form'),\n             ('7.3.b.a','First CM-form with weight at least 2'),\n             ('23.2.a.a','First trivial-character non-rational form'),\n             ('1.12.a.a','Delta'),\n             ('124.1.i.a','First non-dihedral weight 1 form'),\n             ('148.1.f.a','First S4 form'),\n            ],\n            [\n                ('633.1.m.b','First A5 form'),\n                ('163.3.b.a','Best q-expansion'),\n                ('8.14.b.a','Large weight, non-self dual, analytic rank 1'),\n                ('8.21.d.b','Large coefficient ring index'),\n                ('3600.1.e.a','Many zeros in q-expansion'),\n                ('983.2.c.a','Large dimension'),\n                ('3997.1.cz.a','Largest projective image'),\n                ('7524.2.l.b', 'CM-form by Q(-627) and many inner twists'),\n            ]\n        ]\n        favorite_space_labels = [\n            [('1161.1.i', 'Has A5, S4, D3 forms'),\n             ('23.10', 'Mile high 11s'),\n             ('3311.1.h', 'Most weight 1 forms'),\n             ('1200.2.a', 'All forms rational'),\n             ('9450.2.a','Most newforms'),\n             ('4000.1.bf', 'Two large A5 forms'),\n            ]\n        ]\n        for l in favorite_newform_labels:\n            for elt, desc in l:\n                page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?jump=%s\" % elt, follow_redirects=True)\n                assert (\"Newform orbit %s\" % elt) in page.get_data(as_text=True)\n                # redirect to the same page\n                page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/%s\" % elt, follow_redirects=True)\n                assert (\"Newform orbit %s\" % elt) in page.get_data(as_text=True)\n        for l in favorite_space_labels:\n            for elt, desc in l:\n                page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?jump=%s\" % elt, follow_redirects=True)\n                assert elt in page.get_data(as_text=True)\n                # redirect to the same page\n                assert \"Space of modular forms of \" in page.get_data(as_text=True)\n                page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/%s\" % elt, follow_redirects=True)\n                assert elt in page.get_data(as_text=True)\n                assert \"Space of modular forms of \" in page.get_data(as_text=True)\n\n    def test_tracehash(self):\n        for t, l in [[1329751273693490116,'7.3.b.a'],[1294334189658968734, '4.5.b.a'],[0,'not found']]:\n            page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?jump=%%23%d\" % t, follow_redirects=True)\n            assert l in page.get_data(as_text=True)\n\n    def test_jump(self):\n        for j, l in [['10','10.3.c.a'], ['3.6.1.a', '3.6.a.a'], ['55.3.d', '55.3.d'], ['55.3.54', '55.3.d'], ['20.5', '20.5'], ['yes','23.1.b.a'], ['yes&weight=2','11.2.a.a'], ['yes&weight=-2', 'There are no newforms specified by the query']]:\n            page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?jump=%s\" % j, follow_redirects=True)\n            assert l in page.get_data(as_text=True)\n\n    def test_failure(self):\n        r\"\"\"\n        Check that bad inputs are handled correctly\n        \"\"\"\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/983/2000/c/a/', follow_redirects=True)\n        assert \"Level and weight too large\" in page.get_data(as_text=True)\n        assert \"for non trivial character.\" in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/1000/4000/a/a/', follow_redirects=True)\n        assert \"Level and weight too large\" in page.get_data(as_text=True)\n        assert \" for trivial character.\" in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/100/2/z/a/', follow_redirects=True)\n        assert \"The newform 100.2.z.a is not in the database\" in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=1000&weight=100-', follow_redirects=True)\n        assert \"No matches\" in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/maria/', follow_redirects=True)\n        assert 'maria' in page.get_data(as_text=True) and \"is not a valid newform\" in page.get_data(as_text=True)\n\n    def test_delta(self):\n        r\"\"\"\n        Check that the Delta function is ok....\n        Recall that this version uses the old urls...\n        \"\"\"\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/1/12/\")\n        assert '1.12.a.a' in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/1/12/a/\")\n        assert '1.12.a.a' in page.get_data(as_text=True)\n        assert '16744' in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/1/12/a/a/\")\n        assert '24 q^{2}' in page.get_data(as_text=True)\n        assert '84480 q^{8}' in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/1/12/a/a/?format=satake\")\n        assert '0.299367' in page.get_data(as_text=True)\n        assert '0.954138' in page.get_data(as_text=True)\n        page = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/1/12/a/a/', follow_redirects=True)\n        assert '0.792122' in page.get_data(as_text=True)\n\n    def test_level11(self):\n        r\"\"\"\n        Check that the weight 2 form of level 11 works.\n        \"\"\"\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/11/2/a/a/\")\n        assert '2 q^{2}' in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/11/2/a/a/?format=satake\")\n        assert r'0.707107' in page.get_data(as_text=True)\n        assert r'0.957427' in page.get_data(as_text=True)\n        assert r'0.223607' in page.get_data(as_text=True)\n        assert r'0.974679' in page.get_data(as_text=True)\n        ## We also check that the L-function works\n        page = self.tc.get('/L/ModularForm/GL2/Q/holomorphic/11/2/a/a/', follow_redirects=True)\n        assert '0.253841' in page.get_data(as_text=True)\n\n    def test_triv_character(self):\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/2/8/a/a/\")\n        assert r'1016 q^{7}' in page.get_data(as_text=True)\n        assert '1680' in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/3/6/a/a/\")\n        assert '168 q^{8}' in page.get_data(as_text=True)\n        assert '36' in page.get_data(as_text=True)\n\n    def test_non_triv_character(self):\n        r\"\"\"\n        Check that non-trivial characters are also working.\n        \"\"\"\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/13/2/e/a/\")\n        assert r'\\Q(\\sqrt{-3})' in page.get_data(as_text=True)\n        assert '0.866025' in page.get_data(as_text=True)\n        assert r'6 q^{6}' in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/10/4/b/a/\")\n        assert r'46 q^{9}' in page.get_data(as_text=True)\n        assert r'\\Q(\\sqrt{-1})' in page.get_data(as_text=True)\n        assert r'10' in page.get_data(as_text=True)\n\n    def test_get_args(self):\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/13/10/a/\")\n        assert '11241' in page.get_data(as_text=True)\n        assert '10099' in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/13/10/1/\", follow_redirects=True)\n        assert '11241' in page.get_data(as_text=True)\n        assert '10099' in page.get_data(as_text=True)\n\n    def test_empty(self):\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/2/2/a/\")\n        assert 'The following table gives the dimensions of various' in page.get_data(as_text=True)\n        assert 'subspaces' in page.get_data(as_text=True)\n        assert r'\\(M_{2}(\\Gamma_0(2))\\)' in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/12/3/a/\")\n        assert 'weight is odd while the character is ' in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/12/6/a/\")\n        for elt in ['Decomposition', r'S_{6}^{\\mathrm{old}}(\\Gamma_0(12))', 'lower level spaces']:\n            assert elt in page.get_data(as_text=True)\n\n    def test_not_in_db(self):\n        # The following redirects to \"ModularForm/GL2/Q/holomorphic/12000/12/\"\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/12000/12/\")\n        assert 'Space not in database' in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/12000/12/a/\")\n        assert 'Space 12000.12.a not found' in page.get_data(as_text=True)\n\n    def test_character_validation(self):\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/12/10/e/\")\n        assert 'Space 12.10.e not found' in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/12/10/c/\")\n        assert 'since the weight is even while the character is' in page.get_data(as_text=True)\n\n    def test_decomposition(self):\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/6/12/\", follow_redirects=True)\n        assert r'Decomposition</a> of \\(S_{12}^{\\mathrm{new}}(\\Gamma_1(6))\\)' in page.get_data(as_text=True)\n        page = self.tc.get('ModularForm/GL2/Q/holomorphic/38/9/')\n        for elt in map(str,[378, 120, 258, 342, 120, 222, 36]):\n            assert elt in page.get_data(as_text=True)\n        for elt in ['38.9.b','38.9.d','38.9.f']:\n            assert elt in page.get_data(as_text=True)\n            assert elt + '.a' in page.get_data(as_text=True)\n        for elt in ['Decomposition', r\"S_{9}^{\\mathrm{old}}(\\Gamma_1(38))\", \"lower level spaces\"]:\n            assert elt in page.get_data(as_text=True)\n        decomposition = r\"\"\"\n<div class=\"center\">\n  \\( S_{9}^{\\mathrm{old}}(\\Gamma_1(38)) \\cong \\) <a href=/ModularForm/GL2/Q/holomorphic/1/9/>\\(S_{9}^{\\mathrm{new}}(\\Gamma_1(1))\\)</a>\\(^{\\oplus 4}\\)\\(\\oplus\\)<a href=/ModularForm/GL2/Q/holomorphic/2/9/>\\(S_{9}^{\\mathrm{new}}(\\Gamma_1(2))\\)</a>\\(^{\\oplus 2}\\)\\(\\oplus\\)<a href=/ModularForm/GL2/Q/holomorphic/19/9/>\\(S_{9}^{\\mathrm{new}}(\\Gamma_1(19))\\)</a>\\(^{\\oplus 2}\\)\n</div>\n\"\"\"\n        assert decomposition in page.get_data(as_text=True)\n\n    def test_convert_conreylabels(self):\n        for c in [27, 31]:\n            page = self.tc.get('/ModularForm/GL2/Q/holomorphic/38/9/%d/a/' % c,follow_redirects=True)\n            assert \"Newform orbit 38.9.d.a\" in page.get_data(as_text=True)\n            for e in range(1, 13):\n                page = self.tc.get('/ModularForm/GL2/Q/holomorphic/38/9/d/a/%d/%d/' % (c, e),follow_redirects=True)\n                assert \"Newform orbit 38.9.d.a\" in page.get_data(as_text=True)\n\n    def test_maximal(self):\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?level=1234&weight=2\")\n        assert '15 matches' in page.get_data(as_text=True)\n        assert '1234.2.a.h' in page.get_data(as_text=True)\n        assert '1234.2.a.i' in page.get_data(as_text=True)\n        assert '1234.2.b.c' in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?level=1234&weight=2&is_maximal_largest=maximal\")\n        assert 'unique match' in page.get_data(as_text=True)\n        assert '1234.2.a.h' not in page.get_data(as_text=True)\n        assert '1234.2.a.i' in page.get_data(as_text=True)\n        assert '1234.2.b.c' not in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?level=1234&weight=2&is_maximal_largest=largest\")\n        assert '5 matches' in page.get_data(as_text=True)\n        assert '1234.2.a.h' in page.get_data(as_text=True)\n        assert '1234.2.a.i' in page.get_data(as_text=True)\n        assert '1234.2.b.c' not in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?level=1234&weight=2&is_maximal_largest=notlargest\")\n        assert '10 matches' in page.get_data(as_text=True)\n        assert '1234.2.a.h' not in page.get_data(as_text=True)\n        assert '1234.2.a.i' not in page.get_data(as_text=True)\n        assert '1234.2.b.c' in page.get_data(as_text=True)\n\n    def test_dim_table(self):\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?weight=12&level=23&search_type=Dimensions\", follow_redirects=True)\n        assert 'Dimension search results' in page.get_data(as_text=True)\n        assert '229' in page.get_data(as_text=True) # Level 23, Weight 12\n\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?weight=12&level=1-100&search_type=Dimensions\", follow_redirects=True)\n        assert 'Dimension search results' in page.get_data(as_text=True)\n        assert '229' in page.get_data(as_text=True) # Level 23, Weight 12\n\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?search_type=Dimensions\", follow_redirects=True)\n        assert 'Dimension search results' in page.get_data(as_text=True)\n        assert '1-12' in page.get_data(as_text=True)\n        assert '1-24' in page.get_data(as_text=True)\n        assert '229' in page.get_data(as_text=True) # Level 23, Weight 12\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=1-100&weight=1-20&search_type=Dimensions', follow_redirects=True)\n        assert '253' in page.get_data(as_text=True) # Level 23, Weight 13\n        assert '229' in page.get_data(as_text=True) # Level 23, Weight 12\n        assert 'Dimension search results' in page.get_data(as_text=True)\n\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?level=3900-4100&weight=1-12&char_order=2-&search_type=Dimensions\", follow_redirects=True)\n        assert '426' in page.get_data(as_text=True) # Level 3999, Weight 1\n        assert '128' in page.get_data(as_text=True) # Level 4000, Weight 1\n\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?level=3900-4100&weight=1-12&char_order=1&search_type=Dimensions\", follow_redirects=True)\n        assert 'Dimension search results' in page.get_data(as_text=True)\n        assert '0' in page.get_data(as_text=True)\n\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/?level=4002&weight=1&char_order=2-&search_type=Dimensions\", follow_redirects=True)\n        assert 'Dimension search results' in page.get_data(as_text=True)\n        assert 'n/a' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?level=7,10&weight_parity=odd&char_parity=odd&count=50&search_type=Dimensions')\n        for elt in map(str,[0,1,2,5,4,9,6,13,8,17,10]):\n            assert elt in page.get_data(as_text=True)\n        assert 'Dimension search results' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/?weight_parity=odd&level=1-1000&weight=1-100&search_type=Dimensions')\n        assert 'Error: Table too large: must have at most 10000 entries' in page.get_data(as_text=True)\n\n        #the other dim table\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/10/2/\")\n        assert '7' in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/12/2/\")\n        for elt in map(str,[9,4,5]):\n            assert elt in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/59/8/\")\n        for elt in map(str,[1044, 1042, 2, 986, 0, 58, 56]):\n            assert elt in page.get_data(as_text=True)\n        for etl in ['59.8.a', '59.8.a.a', '59.8.a.b', '59.8.c', '59.8.c.a']:\n            assert elt in page.get_data(as_text=True)\n\n    def test_character_parity(self):\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/12/10/c/\")\n        assert 'since the weight is even while the character is' in page.get_data(as_text=True)\n        page = self.tc.get(\"/ModularForm/GL2/Q/holomorphic/12/3/a/\")\n        assert 'since the weight is odd while the character is' in page.get_data(as_text=True)\n\n    def test_dual(self):\n        urls_set = [\n                [('/ModularForm/GL2/Q/holomorphic/5/9/c/a/', 'Newform orbit 5.9.c.a'),\n                ('/ModularForm/GL2/Q/holomorphic/5/9/c/a/2/1/', 'Dual form 5.9.c.a.2.1'),\n                ('/ModularForm/GL2/Q/holomorphic/5/9/c/a/3/1/', 'Dual form 5.9.c.a.3.1'),\n                ],\n                [('/ModularForm/GL2/Q/holomorphic/5/9/c/a/', 'Newform orbit 5.9.c.a'),\n                ('/ModularForm/GL2/Q/holomorphic/5/9/c/a/2/3/', 'Dual form 5.9.c.a.2.3'),\n                ('/ModularForm/GL2/Q/holomorphic/5/9/c/a/3/3/', 'Dual form 5.9.c.a.3.3'),\n                ],\n                [\n                ('/ModularForm/GL2/Q/holomorphic/13/2/e/a/', 'Newform orbit 13.2.e.a'),\n                ('/ModularForm/GL2/Q/holomorphic/13/2/e/a/4/1/', 'Dual form 13.2.e.a.4.1'),\n                ('/ModularForm/GL2/Q/holomorphic/13/2/e/a/10/1/', 'Dual form 13.2.e.a.10.1'),\n                ]\n                ]\n        for urls in urls_set:\n            for i, (url, _) in enumerate(urls):\n                page = self.tc.get(url)\n                for j, (other, name) in enumerate(urls):\n                    if i != j:\n                        assert other in page.get_data(as_text=True)\n                        if i > 0:\n                            assert name in page.get_data(as_text=True)\n\n                if i > 0:\n                    assert 'Embedding label' in page.get_data(as_text=True)\n                    assert 'Root' in page.get_data(as_text=True)\n\n    def test_embedded_invariants(self):\n        for url in ['/ModularForm/GL2/Q/holomorphic/13/2/e/a/4/1/',\n                    '/ModularForm/GL2/Q/holomorphic/13/2/e/a/10/1/']:\n\n            page = self.tc.get(url)\n            # root\n            assert 'Root' in page.get_data(as_text=True)\n            assert '0.500000' in page.get_data(as_text=True)\n            assert '0.866025' in page.get_data(as_text=True)\n            # p = 13\n            for n in ['2.50000', '2.59808', '0.693375', '0.720577']:\n                assert n in page.get_data(as_text=True)\n\n            # p = 47\n            for n in ['3.46410', '0.505291', '0.967559', '0.252646', '0.918699']:\n                assert n in page.get_data(as_text=True)\n\n            assert 'Newspace 13.2.e' in page.get_data(as_text=True)\n            assert 'Newform orbit 13.2.e.a' in page.get_data(as_text=True)\n            assert 'Dual form 13.2.e.a.' in page.get_data(as_text=True)\n            assert 'L-function 13.2.e.a.' in page.get_data(as_text=True)\n\n            assert '0.103805522628' in page.get_data(as_text=True)\n\n            assert '13.2.e.a.4.1' in page.get_data(as_text=True)\n            assert '13.2.e.a.10.1' in page.get_data(as_text=True)\n\n    def test_satake(self):\n        for url in ['/ModularForm/GL2/Q/holomorphic/11/2/a/a/?format=satake',\n                '/ModularForm/GL2/Q/holomorphic/11/2/a/a/1/1/']:\n            page = self.tc.get(url)\n            assert r'0.707107' in page.get_data(as_text=True)\n            assert r'0.957427' in page.get_data(as_text=True)\n            assert r'0.223607' in page.get_data(as_text=True)\n            assert r'0.974679' in page.get_data(as_text=True)\n            assert r'0.288675' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/7/3/b/a/?&format=satake',\n                '/ModularForm/GL2/Q/holomorphic/7/3/b/a/6/1/']:\n            page = self.tc.get(url)\n            assert r'0.750000' in page.get_data(as_text=True)\n            assert r'0.661438' in page.get_data(as_text=True)\n            assert r'0.272727' in page.get_data(as_text=True)\n            assert r'0.962091' in page.get_data(as_text=True)\n        assert r'1.00000' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/7/3/b/a/?&format=satake_angle',\n                '/ModularForm/GL2/Q/holomorphic/7/3/b/a/6/1/']:\n            page = self.tc.get(url)\n            assert r'\\(\\pi\\)' in page.get_data(as_text=True)\n            assert r'\\(0.769947\\pi\\)' in page.get_data(as_text=True)\n            assert r'\\(0.587926\\pi\\)' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/21/2/e/a/?format=satake',\n                '/ModularForm/GL2/Q/holomorphic/21/2/e/a/4/1/',\n                '/ModularForm/GL2/Q/holomorphic/21/2/e/a/16/1/',\n                ]:\n            page = self.tc.get(url)\n            assert r'0.965926' in page.get_data(as_text=True)\n            assert r'0.258819' in page.get_data(as_text=True)\n            assert r'0.990338' in page.get_data(as_text=True)\n            assert r'0.550990' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/5/9/c/a/?n=2-10&m=1-6&prec=6&format=satake',\n                '/ModularForm/GL2/Q/holomorphic/5/9/c/a/2/1/',\n                '/ModularForm/GL2/Q/holomorphic/5/9/c/a/3/1/',\n                ]:\n            page = self.tc.get(url)\n            assert '0.972878' in page.get_data(as_text=True)\n            assert '0.231320' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/5/9/c/a/?n=2-10&m=1-6&prec=6&format=satake',\n                '/ModularForm/GL2/Q/holomorphic/5/9/c/a/2/3/',\n                '/ModularForm/GL2/Q/holomorphic/5/9/c/a/3/3/',\n                ]:\n            page = self.tc.get(url)\n            assert '0.00593626' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/31/2/c/a/?m=1-4&n=2-10&prec=6&format=satake',\n                '/ModularForm/GL2/Q/holomorphic/31/2/c/a/5/1/',\n                '/ModularForm/GL2/Q/holomorphic/31/2/c/a/25/1/',\n                ]:\n            page = self.tc.get(url)\n            assert '0.998759' in page.get_data(as_text=True)\n            assert '0.0498090' in page.get_data(as_text=True)\n            assert '0.542515' in page.get_data(as_text=True)\n            assert '0.840046' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/31/2/c/a/?m=1-4&n=2-10&prec=6&format=satake_angle',\n                '/ModularForm/GL2/Q/holomorphic/31/2/c/a/5/1/',\n                '/ModularForm/GL2/Q/holomorphic/31/2/c/a/25/1/',\n                ]:\n            page = self.tc.get(url)\n            assert r'0.984139\\pi' in page.get_data(as_text=True)\n            assert r'0.317472\\pi' in page.get_data(as_text=True)\n\n        #test large floats\n        for url in ['/ModularForm/GL2/Q/holomorphic/1/36/a/a/?m=1-3&n=695-696&prec=6&format=embed',\n                    '/ModularForm/GL2/Q/holomorphic/1/36/a/a/1/1/']:\n            page = self.tc.get(url)\n            assert '213.765' in page.get_data(as_text=True)\n            assert '5.39613e49' in page.get_data(as_text=True)\n            assert '7.61562e49' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/1/36/a/a/?m=1-3&n=695-696&prec=6&format=embed',\n                    '/ModularForm/GL2/Q/holomorphic/1/36/a/a/1/2/']:\n            page = self.tc.get(url)\n            assert '3412.77' in page.get_data(as_text=True)\n            assert '1.55372e49' in page.get_data(as_text=True)\n            assert '1.00032e49' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/1/36/a/a/?m=1-3&n=695-696&prec=6&format=embed',\n                    '/ModularForm/GL2/Q/holomorphic/1/36/a/a/1/3/']:\n            page = self.tc.get(url)\n            assert '3626.53' in page.get_data(as_text=True)\n            assert '1.17540e49' in page.get_data(as_text=True)\n            assert '1.20001e50' in page.get_data(as_text=True)\n\n        # same numbers but normalized\n        for url in ['/ModularForm/GL2/Q/holomorphic/1/36/a/a/?m=1-3&n=695-696&prec=6&format=analytic_embed',\n                    '/ModularForm/GL2/Q/holomorphic/1/36/a/a/1/1/']:\n            page = self.tc.get(url)\n            assert '0.993913' in page.get_data(as_text=True)\n            assert '1.36787' in page.get_data(as_text=True)\n\n        for url in ['/ModularForm/GL2/Q/holomorphic/1/36/a/a/?m=1-3&n=695-696&prec=6&format=analytic_embed',\n                    '/ModularForm/GL2/Q/holomorphic/1/36/a/a/1/2/']:\n            page = self.tc.get(url)\n            assert '0.286180' in page.get_data(as_text=True)\n            assert '0.179671' in page.get_data(as_text=True)\n        for url in ['/ModularForm/GL2/Q/holomorphic/1/36/a/a/?m=1-3&n=695-696&prec=6&format=analytic_embed',\n                    '/ModularForm/GL2/Q/holomorphic/1/36/a/a/1/3/']:\n            page = self.tc.get(url)\n            assert '0.216496' in page.get_data(as_text=True)\n            assert '2.15537' in page.get_data(as_text=True)\n\n        # test some exact values\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/25/2/e/a/?n=97&m=8&prec=6&format=satake_angle')\n        assert '0.0890699' in page.get_data(as_text=True)\n        assert '0.689070' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/25/2/d/a/?m=4&n=97&prec=6&format=satake_angle')\n        assert '0.237314' in page.get_data(as_text=True)\n        assert '0.637314' in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/210/2/a/a/?format=satake&n=2-20')\n        # alpha_11\n        assert '0.603023' in page.get_data(as_text=True)\n        assert '0.797724' in page.get_data(as_text=True)\n        # alpha_13\n        assert '0.277350' in page.get_data(as_text=True)\n        assert '0.960769' in page.get_data(as_text=True)\n        # alpha_17\n        assert '0.727607' in page.get_data(as_text=True)\n        assert '0.685994' in page.get_data(as_text=True)\n\n        # specifying embeddings\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/99/2/p/a/?n=2-10&m=2.1%2C+95.10&prec=6&format=embed')\n        for elt in ['2.1','95.10','1.05074','0.946093', '2.90568', '0.305399']:\n            assert elt in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/13/2/e/a/?m=1-2&n=2-10000&prec=6&format=embed')\n        assert \"Only\" in page.get_data(as_text=True)\n        assert \"up to 1000 are available\" in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/7524/2/l/b/?n=5000&m=&prec=&format=embed')\n        assert \"Only\" in page.get_data(as_text=True)\n        assert \"up to 3000 are available\" in page.get_data(as_text=True)\n        assert \"in specified range; resetting to default\" in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/7524/2/l/b/?n=1500-4000&m=&prec=&format=embed')\n        assert \"Only\" in page.get_data(as_text=True)\n        assert \"up to 3000 are available\" in page.get_data(as_text=True)\n        assert \"limiting to\" in page.get_data(as_text=True)\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/13/2/e/a/?m=1-2&n=3.5&prec=6&format=embed')\n        assert \"must be an integer, range of integers or comma separated list of integers\" in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/419/3/h/a/?n=2-10&m=1-20000&prec=6&format=embed', follow_redirects=True)\n        assert \"Web interface only supports 1000 embeddings at a time.  Use download link to get more (may take some time).\" in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/419/3/h/a/?n=3.14&format=embed', follow_redirects=True)\n        assert \"must be an integer, range of integers or comma separated list of integers\" in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/99/2/p/a/?n=2-10&m=1-20&prec=16&format=embed')\n        assert 'must be a positive integer, at most 15 (for higher precision, use the download button)' in page.get_data(as_text=True)\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/99/2/p/a/?n=999-1001&m=1-20&prec=6&format=embed')\n        assert 'Only' in page.get_data(as_text=True)\n        assert 'up to 1000 are available' in page.get_data(as_text=True)\n        assert 'a_{1000}' in page.get_data(as_text=True)\n\n    def test_underlying_data(self):\n        data = self.tc.get('/ModularForm/GL2/Q/holomorphic/data/13.2').get_data(as_text=True)\n        assert ('mf_gamma1' in data and 'newspace_dims' in data\n                and 'mf_gamma1_portraits' in data and \"data:image/png;base64\" in data)\n\n        data = self.tc.get('/ModularForm/GL2/Q/holomorphic/data/13.2.e').get_data(as_text=True)\n        assert ('mf_newspaces' in data and 'num_forms' in data\n                and 'mf_newspace_portraits' in data and \"data:image/png;base64\" in data)\n\n        data = self.tc.get('/ModularForm/GL2/Q/holomorphic/data/13.2.e.a').get_data(as_text=True)\n        assert ('mf_newforms' in data and 'field_disc_factorization' in data and\n                'mf_hecke_nf' in data and 'hecke_ring_character_values' in data\n                and 'mf_newspaces' in data and 'num_forms' in data\n                and 'mf_twists_nf' in data and 'twisting_char_label' in data\n                and 'mf_hecke_charpolys' in data and 'charpoly_factorization' in data\n                and 'mf_newform_portraits' in data and \"data:image/png;base64\" in data\n                and 'mf_hecke_traces' in data and 'trace_an' in data)\n\n        data = self.tc.get('/ModularForm/GL2/Q/holomorphic/data/13.2.e.a.4.1').get_data(as_text=True)\n        assert ('mf_newforms' in data and 'field_disc_factorization' in data and\n                'mf_hecke_cc' in data and 'an_normalized' in data\n                and 'mf_newspaces' in data and 'num_forms' in data\n                and 'mf_twists_cc' in data and 'twisting_conrey_index' in data\n                and 'mf_hecke_charpolys' in data and 'charpoly_factorization' in data\n                and 'mf_newform_portraits' in data and \"data:image/png;base64\" in data\n                and 'mf_hecke_traces' in data and 'trace_an' in data)\n\n    def test_character_values(self):\n        # A newform orbit of dimension 1\n        data = self.tc.get('/ModularForm/GL2/Q/holomorphic/12/3/c/a/').get_data(as_text=True)\n        character_values_table = r\"\"\"\n<table class=\"ntdata\">\n  <tbody>\n        <tr>\n      <td class=\"dark border-right border-bottom\">\\(n\\)</td>\n      <td class=\"light border-bottom\">\\(5\\)</td>\n      <td class=\"dark border-bottom\">\\(7\\)</td>    </tr>\n    <tr>\n      <td class=\"dark border-right\">\\(\\chi(n)\\)</td>\n      <td class=\"light\">\\(-1\\)</td>\n      <td class=\"dark\">\\(1\\)</td>    </tr>\n  </tbody>\n</table>\n\"\"\"\n        assert (character_values_table in data)\n\n        # A newform orbit of dimension 2\n        data = self.tc.get('/ModularForm/GL2/Q/holomorphic/119/1/d/a/').get_data(as_text=True)\n        character_values_table = r\"\"\"\n<table class=\"ntdata\">\n  <tbody>\n        <tr>\n      <td class=\"dark border-right border-bottom\">\\(n\\)</td>\n      <td class=\"light border-bottom\">\\(52\\)</td>\n      <td class=\"dark border-bottom\">\\(71\\)</td>    </tr>\n    <tr>\n      <td class=\"dark border-right\">\\(\\chi(n)\\)</td>\n      <td class=\"light\">\\(-1\\)</td>\n      <td class=\"dark\">\\(-1\\)</td>    </tr>\n  </tbody>\n</table>\n\"\"\"\n        assert (character_values_table in data)\n\n        # An embedded newform\n        data = self.tc.get('/ModularForm/GL2/Q/holomorphic/119/1/d/a/118/1/').get_data(as_text=True)\n        character_values_table = r\"\"\"\n<table class=\"ntdata\">\n  <tbody>\n        <tr>\n      <td class=\"dark border-right border-bottom\">\\(n\\)</td>\n      <td class=\"light border-bottom\">\\(52\\)</td>\n      <td class=\"dark border-bottom\">\\(71\\)</td>    </tr>\n    <tr>\n      <td class=\"dark border-right\">\\(\\chi(n)\\)</td>\n      <td class=\"light\">\\(-1\\)</td>\n      <td class=\"dark\">\\(-1\\)</td>    </tr>\n  </tbody>\n</table>\n\"\"\"\n        assert (character_values_table in data)\n\n    def test_invalid_format_parameter(self):\n        \"\"\"Test that invalid format parameters are handled gracefully\"\"\"\n        # Test invalid format 'txt' which was causing the original issue\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/441/4/a/h/?format=txt')\n        data = page.get_data(as_text=True)\n        assert \"Invalid format parameter\" in data\n        assert \"txt\" in data\n        assert \"Valid formats are:\" in data\n\n        # Test another invalid format\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/11/2/a/a/?format=invalid')\n        data = page.get_data(as_text=True)\n        assert \"Invalid format parameter\" in data\n        assert \"invalid\" in data\n\n        # Test that valid formats still work\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/11/2/a/a/?format=embed')\n        data = page.get_data(as_text=True)\n        assert \"Valid formats are:\" not in data\n        assert \"Invalid format parameter\" not in data\n\n        page = self.tc.get('/ModularForm/GL2/Q/holomorphic/11/2/a/a/?format=satake')\n        data = page.get_data(as_text=True)\n        assert \"Valid formats are:\" not in data\n        assert \"Invalid format parameter\" not in data"
  },
  {
    "type": "class",
    "file": "lmfdb/utils/completeness.py",
    "name": "NFBound",
    "line_start": 1075,
    "line_end": 2170,
    "lines": 1096,
    "bytes": 51030,
    "has_71": true,
    "code": "class NFBound(ColTest):\n    def __init__(self):\n        # maxD[n][r2] is an integer M so that we have completeness in signature [n-2*r2, r2] as long as the absolute discriminant is at most M.\n        self._maxD = [\n            None, # n=0\n            None, # n=1\n            [2*10**6, 2*10**6], # n=2\n            [150**3, 150**3], # n=3\n            [10**7, 4*10**6, 4*10**6], # n=4\n            [10**8, 12*10**6, 12*10**6], # n=5\n            [28**6, 10**7, 10**7, 10**7], # n=6\n            [214942297, 2*10**8, 2*10**8, 2*10**8], # n=7\n            [17**8, 79259702, 20829049, 5726300, 1656109], # n=8\n            [15**9, 27316369, 27316369, 146723910, 39657561], # n=9\n            [190612177]*6, # n=10\n            [5154074557]*6, # n=11\n            [37250695278]*7, # n=12\n        ]\n\n        # num_trans[n] is the number of transitive permutation groups in degree n\n        self._num_trans = [0, 1, 1, 2, 5, 5, 16, 7, 50, 34, 45, 8, 301, 9, 63, 104, 1954, 10, 983, 8, 1117, 164, 59, 7]\n\n        # ab.get(n, {1}) gives the values of t so that nTt is abelian (for n<48)\n        self._ab = {\n            4: {1,2},\n            8: {1,2,3},\n            9: {1,2},\n            12: {1,2},\n            16: {1,2,3,4,5},\n            18: {1,2},\n            20: {1,3},\n            24: {1,2,3},\n            25: {1,2},\n            27: {1,2,4},\n            28: {1,2},\n            32: {32,33,34,36,37,39,43},\n            36: {1,2,3,4},\n            40: {1,2,7},\n            44: {1,2},\n            45: {1,2}}\n\n        # nab_gal[n] gives the values of t so that nTt is nonabelian of order n (for n<24)\n        self._nab_gal = {\n            6: {2},\n            8: {4,5},\n            10: {2},\n            12: {3,4,5},\n            14: {2},\n            16: {6,7,8,9,10,11,12,13,14},\n            18: {3,4,5},\n            20: {2,4,5},\n            21: {2},\n            22: {2}}\n\n        # nsolv.get(n, set()) gives the values of t so that nTt is nonsolvable (for n<24)\n        self._nsolv = {\n            5: {4,5},\n            6: {12,14,15,16},\n            7: {5,6,7},\n            8: {37,43,48,49,50},\n            9: {27,32,33,34},\n            10: {7,11,12,13,22,26,30,31,32,34,35,36,37,38,39,40,41,42,43,44,45},\n            11: {5,6,7,8},\n            12: {33,74,75,76,123,124,179,180,181,182,183,218,219,220,230,255,256,257,269,270,272,277,278,279,285,286,287,288,293,295,296,297,298,299,300,301},\n            13: {7,8,9},\n            14: {10,16,17,19,30,33,34,39,42,43,46,47,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63},\n            15: {5,10,15,16,20,21,22,23,24,28,29,47,53,61,62,63,69,70,72,76,77,78,83,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104},\n            16: {713,714,715,1035,1036,1080,1081,1328,1329,1504,1505,1506,1507,1508,1653,1654,1753,1801,1802,1803,1804,1805,1838,1839,1840,1842,1843,1844,1861,1873,1878,1882,1883,1902,1903,1906,1916,1938,1940,1944,1945,1946,1948,1949,1950,1951,1952,1953,1954},\n            17: {6,7,8,9,10},\n            18: {90,144,145,146,227,260,261,262,362,363,364,365,377,427,452,468,596,664,665,666,722,723,736,787,788,789,790,791,802,845,846,847,848,849,855,856,886,887,888,890,897,898,899,900,911,913,914,925,933,934,935,936,937,938,946,947,948,949,950,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983},\n            19: {7,8},\n            20: {15,30,31,32,35,36,62,63,64,65,66,70,89,116,117,118,119,120,123,145,146,147,148,149,150,151,152,172,174,175,176,177,197,198,199,200,201,202,203,204,205,206,207,208,217,218,219,220,221,222,223,224,225,226,227,228,229,230,264,265,266,267,272,273,274,275,276,277,278,279,280,281,283,284,285,287,288,289,290,291,358,362,363,365,366,367,368,369,370,373,375,376,452,453,456,457,458,459,460,461,466,467,468,531,532,539,540,541,542,543,544,545,546,547,548,555,556,558,560,561,562,564,565,566,567,568,569,570,571,573,635,654,655,656,657,658,659,663,664,665,666,667,668,669,671,672,673,674,675,676,677,679,680,681,682,684,685,686,687,688,689,690,691,692,693,694,695,752,753,754,781,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,812,855,856,857,858,885,886,887,888,912,913,914,915,916,917,918,919,920,921,922,933,934,935,936,937,938,939,947,948,949,950,951,952,953,954,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,981,985,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1006,1007,1008,1009,1010,1011,1012,1013,1015,1016,1019,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1044,1045,1046,1047,1048,1052,1053,1054,1058,1059,1060,1061,1062,1063,1064,1065,1066,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117},\n            21: {14,20,22,27,33,38,44,56,57,58,67,74,85,91,103,104,111,113,115,118,119,121,125,126,128,129,130,132,135,136,138,139,140,141,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164},\n            22: {13,14,22,26,27,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59},\n            23: {5,6,7}\n        }\n\n        # rdgrd[n][t] gives a ratio r so that grd <= rd^(1/r) for fields with Galois group nTt\n        # See https://arxiv.org/abs/1208.5806\n        self._rdgrd = [\n            [],\n            [1], # 1\n            [1], # 2\n            [1, 2/3], # 3\n            [1, 1, 1/2, 3/4, 1/2], # 4\n            [1, 4/5, 4/5, 3/5, 2/5], # 5\n            [1, 1, 2/3, 2/3, 1/2, 1/3, 2/3, 2/3, 1/2, 1/2, 1/3, 2/3, 1/3, 2/3, 1/2, 1/3],  #6\n            [1, 6/7, 6/7, 6/7, 4/7, 3/7, 2/7],  # 7\n            [1, 1, 1, 1, 1, 3/4, 1/2, 3/4, 1/2, 1/2, 1/2, 3/4, 3/4, 3/4, 1/2, 1/2,\n             1/2, 1/2, 1/2, 1/2, 1/2, 1/2, 3/4, 1/2, 7/8, 1/2, 1/4, 1/2, 1/2, 1/2,\n             1/4, 1/2, 1/2, 1/2, 1/4, 3/4, 3/4, 1/4, 1/2, 1/2, 1/2, 3/8, 3/4, 1/4,\n             3/8, 3/8, 1/4, 1/2, 3/8, 1/4],  #8\n            [1, 1, 8/9, 2/3, 8/9, 2/3, 2/3, 2/3, 8/9, 2/3, 2/3, 2/3, 2/3, 8/9, 8/9,\n             2/3, 1/3, 2/3, 2/3, 1/3, 1/3, 1/3, 2/3, 1/3, 1/3, 2/3, 7/9, 2/9, 1/3,\n             1/3, 2/9, 2/3, 1/3, 2/9],  #9\n            [1, 1, 4/5, 4/5, 4/5, 1/2, 4/5, 2/5, 1/2, 1/2, 3/5, 3/5, 3/5, 1/5, 2/5,\n             2/5, 1/2, 1/2, 1/2, 1/2, 2/5, 2/5, 1/5, 2/5, 2/5, 4/5, 2/5, 2/5, 1/5,\n             4/5, 4/5, 3/5, 2/5, 2/5, 3/5, 1/5, 2/5, 2/5, 1/5, 3/10, 3/10, 3/10,\n             1/5, 3/10, 1/5], # 10\n            [1, 10/11, 10/11, 10/11, 8/11, 8/11, 3/11, 2/11],  # 11\n            [1, 1, 1, 1, 1, 2/3, 2/3, 5/6, 2/3, 2/3, 2/3, 5/6, 5/6, 1/2, 1/2, 1/2,\n             1/2, 1/2, 1/2, 3/4, 1/3, 2/3, 2/3, 2/3, 1/3, 2/3, 2/3, 1/2, 1/3, 1/3,\n             2/3, 2/3, 5/6, 1/2, 1/2, 1/2, 1/2, 1/2, 1/2, 1/2, 1/2, 1/2, 2/3, 3/4,\n             1/2, 2/3, 2/3, 1/3, 2/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3,\n             1/2, 2/3, 1/2, 2/3, 2/3, 2/3, 2/3, 2/3, 2/3, 2/3, 1/3, 1/2, 1/2, 1/2,\n             1/2, 2/3, 2/3, 2/3, 1/3, 1/2, 1/3, 1/2, 1/2, 1/2, 1/2, 2/3, 2/3, 1/3,\n             1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3,\n             1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/2, 1/2, 2/3, 2/3, 1/2,\n             1/2, 1/2, 1/2, 1/2, 1/2, 1/2, 1/2, 2/3, 2/3, 2/3, 1/3, 1/3, 2/3, 2/3,\n             1/2, 1/4, 1/4, 1/2, 1/2, 1/6, 1/6, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3,\n             1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/2,\n             2/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/2, 1/3, 1/4, 1/4, 1/4, 1/4,\n             1/4, 1/4, 1/4, 1/4, 1/2, 1/2, 1/2, 1/2, 5/6, 1/2, 2/3, 2/3, 1/2, 1/3,\n             1/3, 1/3, 1/3, 1/6, 1/3, 1/3, 1/3, 1/3, 1/6, 1/4, 1/3, 1/3, 1/3, 1/3,\n             1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 1/6, 1/4, 1/4, 1/4, 1/4,\n             1/2, 1/4, 1/4, 1/4, 1/4, 5/6, 1/3, 2/3, 1/3, 1/6, 1/3, 1/6, 1/3, 1/3,\n             1/6, 1/3, 1/3, 1/3, 1/4, 1/4, 1/4, 1/4, 1/3, 1/3, 1/3, 1/3, 1/3, 1/6,\n             1/6, 1/4, 1/4, 1/4, 1/4, 1/4, 1/4, 1/4, 1/4, 1/6, 1/3, 1/3, 1/3, 1/3,\n             1/6, 1/3, 1/3, 1/4, 1/4, 1/6, 1/6, 1/4, 1/4, 1/6, 1/4, 1/4, 1/4, 1/3,\n             1/3, 1/6, 1/4, 2/3, 1/4, 1/6, 1/4, 1/4, 1/3, 1/3, 1/3, 1/6, 1/4, 1/4,\n             1/4, 1/4, 1/3, 1/6, 1/3, 1/3, 1/6, 1/4, 1/4, 1/6, 1/6, 1/6, 2/3, 1/4,\n             1/4, 1/4, 1/6, 1/4, 1/6],  # 12\n            [1, 12/13, 12/13, 12/13, 12/13, 12/13, 8/13, 3/13, 2/13], # 13\n            [1, 1, 6/7, 6/7, 6/7, 4/7, 6/7, 1/2, 3/7, 6/7, 4/7, 1/2, 1/2, 1/2, 1/2,\n             4/7, 5/7, 3/7, 4/7, 3/7, 2/7, 1/2, 1/2, 1/2, 1/2, 3/7, 2/7, 2/7, 1/7,\n             6/7, 3/7, 3/7, 4/7, 4/7, 2/7, 3/7, 3/7, 1/7, 6/7, 2/7, 2/7, 3/7, 3/7,\n             1/7, 3/7, 3/7, 3/7, 1/7, 2/7, 2/7, 1/7, 2/7, 2/7, 2/7, 2/7, 1/7, 1/7,\n             3/14, 3/14, 3/14, 1/7, 3/14, 1/7],  # 14\n            [1, 14/15, 4/5, 2/3, 4/5, 4/5, 2/3, 4/5, 2/3, 4/5, 2/3, 2/3, 2/3, 2/3,\n             4/5, 3/5, 2/3, 2/3, 2/3, 4/5, 4/5, 3/5, 3/5, 2/5, 1/3, 2/5, 2/3, 8/15,\n             2/5, 1/3, 1/3, 1/3, 2/5, 2/5, 2/5, 1/5, 1/3, 1/3, 1/3, 1/3, 2/5, 2/5,\n             2/5, 1/5, 1/5, 1/5, 4/5, 1/3, 1/3, 4/15, 1/3, 2/5, 2/5, 1/5, 1/5, 1/5,\n             1/3, 4/15, 4/15, 4/15, 2/5, 2/5, 2/5, 1/5, 1/3, 1/3, 4/15, 4/15, 1/5,\n             2/5, 1/5, 8/15, 4/15, 4/15, 4/15, 1/5, 1/5, 1/5, 1/5, 1/5, 2/15, 4/15,\n             1/5, 1/5, 1/5, 2/15, 2/15, 1/5, 1/5, 2/15, 1/5, 1/5, 2/15, 1/5, 1/5,\n             1/5, 1/5, 1/5, 1/5, 1/5, 2/15, 2/15, 1/5, 2/15], # 15\n            [1,1,1,1,1,1,1,1,1,1,1,1,1,1], #16\n            [1], #17\n            [1,1,1,1,1], #18\n            [1], #19\n            [1,1,1,1,1], #20\n            [1,1], #21\n            [1,1], #22\n            [1], #23\n        ]\n\n        od = 44.76323219095532388621866759\n        # grd[n] is a list of pairs(ts, M) so that we have completeness for fields with Galois group nTt (t in ts) as long as grd <= M\n        self._grd = {\n            2: [((1,), 1500)],\n            3: [((1,), 500),\n                ((2,), 250)],\n            4: [((1,2,3), 200), # quad over quad\n                ((4,5), 150)],\n            5: [((1,2), 200),\n                ((3,), 200),\n                ((4,5), 85)],\n            6: [((12,14), 85), # pumped up\n                ((15,16), 60),\n                ((1,2,3,5,9), 200), # just did 6t3 as composita\n                ((10,), 150),\n                ((4,5,6,7,8,11,13), 150)],\n            7: [((4,), 75),\n                ((1,3), 200),\n                ((2,), 200),\n                ((5,6), 45),\n                ((7,), 35)],\n            8: [((3,5,23,24,39,40,41,44,45,46), 100),\n                ((4,6,8,9,10,15,17,18,19,26,28,29,30,35), 125), # over 4T3\n                ((1,2,7,16,20,27), 125), # over 4T1\n                ((12,13,32,38), 250), # over 4T4\n                ((11,21,22,31), 100), # over 4T2\n                ((14,33), 150),\n                ((25,36), 200), #prim\n                ((34,), 110),\n                ((37,), 45),\n                ((42,), 135),\n                ((47,), 150),\n                ((48,), 45)],\n            9: [((16,), od),\n                ((26,), 75),\n                ((9,13,14,15,19,22,23,24,25,29), 100),\n                ((31,), 100),\n                ((18,), 150), # using 6T9\n                ((30,), 115),\n                ((1,2,4,6,7,17), 500), #C3 over C3\n                ((1,2,3,4,5,6,7,8,10,11,12,20,21,24,29,30,31), 200),\n                ((20,28), 150)],\n            10: [(tup(1,28)+(29,32,34,36,37,38,39), od),\n                 ((4,), 100), # F_5\n                 ((20,), 50),\n                 ((1,2,6), 200)], # C_5 over C_2\n            11: [((1,), 200),\n                 ((2,3), od),\n                 ((4,), 22.5)],\n            12: [((1,2,5), od),\n                 (tup(1,20)+tup(21,43)+tup(48,70)+tup(74,83), od/2),\n                 ((1,5), 150)],\n            13: [((1,), 200),\n                 ((2,), od),\n                 ((3,4,5,6), od/2)],\n            14: [((1,), od),\n                 ((2,), 50),\n                 ((3,4,5,6,7,8,9,10,11,17,18,19,21,27,28,29,33,34,35,38,40,41,42,43,44,47,48,50,51,53,56), 23)],\n            15: [((1,2), od)],\n            16: [((1,2,3,4,5), od),\n                 (tup(6,57)+tup(67,178)+tup(197,414), od/2)],\n            17: [((1,), 200),\n                 ((2,), od)],\n            18: [((1,2,3,4,5), 100)],\n            19: [((1,), 200),\n                 ((2,), od)],\n            20: [((1,2,3,4,5), 100)],\n            21: [((1,2), 100)],\n            22: [((1,), 100)],\n            23: [((1,2), od)],\n        }\n\n        quartic_2_group = (1,2,3)\n        octic_2_group = (1,2,3,4,5,6,7,8,9,10,11,15,16,17,18,19,20,21,22,26,27,28,29,30,31,35)\n        octwith4 = (1,2,4,6,7,8,10,12,13,14,16,17,19,20,21,23,27,28,30,38,40)\n        octic_with_quartic = tup(1,25)+tup(26,33)+(35,38,39,40,44)\n        octic_type_2 = (33,34,41,42,45,46,47)\n        decic_with_quint = (1,2,3,4,5,8,11,12,14,15,16,22,23,24,25,29,34,36,37,38,39)\n        decic_with_quad = (1,2,3,4,5,6,9,10,11,12,17,18,19,20,21,22,27,28,33,40,41,42,43)\n\n        # r2G[n] is a list of triples (r2, ts, M) so that we have all number fields with signature [n-2*r2, r2] and Galois group nTt (for t in ts) as long as the absolute discriminant is at most M (if M is None, there is no discriminant restriction since that signature/Galois group combination is impossible)\n        self._r2G = {\n            3: [(1, (1,), None)],\n            4: [(0, (1,2,3), 150**4),\n                (0, (4,), 10**10), # from megrez\n                (1, (1,2,4), None),\n                (1, (3,), 15**6),\n                (2, (1,2,3), 15**6),\n                (2, (4,), 10**10)], # from megrez\n            5: [(0, (1,2), 10**10),\n                (0, (4,), 2**38),\n                (1, (1,2,3,4), None),\n                (2, (1,), None),\n                (2, (2,4), 10**8)],\n            6: [# r2=0 bound for arbitrary t is 28^6\n                (0, (1,2), 250**6), # Base changing S_3 grd up, using Belabash, disc filter, moving them up; redid 6T2 by Rachel/grd, which picks up 6T1\n                (0, (3,), 10**11), # from Kluners\n                (0, (4,), 100**6), # from Kluners\n                (0, (5,), 10**10), # matches Kluners\n                (0, (6,), 50**6), # higher than Kluners\n                (0, (7,), 18**9), # Computed with a special version for even groups\n                (0, (8,), 10**12), # from Kluners\n                (0, (9,), 2*10**10), # from Kluners\n                (0, (10,), 10**11), # from Kluners\n                (0, (11,), 35**6),\n                (0, (12,), 2**38), # from A5 quintics pushed up\n                (0, (14,), 35**6), # from S5 quintics pushed up\n                # r2=1 bound for arbitrary t is 10^7\n                (1, (1,2,3,4,5,7,8,9,10,12,14,15), None),\n                (1, (6,), 10**9), # from Kluners\n                (1, (11,), 10**9), # from Kluners\n                (1, (13,), 10**8-1), # from Eric Driver\n                # r2=2 bound for arbitrary t is 10^7\n                (2, (1,2,5), None),\n                (2, (3,), 64**6), # Done by composita\n                (2, (4,), 100**6), # from Kluners\n                (2, (6,), 10**9), # from Kluners\n                (2, (7,), 18**9), # Computed with a special version for even groups\n                (2, (8,), 15**9), # JJ has double checked\n                (2, (9,10), 5*10**9), # from Eric Driver\n                (2, (11,), 10**8), # from Kluners\n                (2, (12,14), 35**6),\n                (2, (13,), 10**8-1), # from Eric Driver\n                # r2=3 bound for arbitrary t is 10^7\n                (3, (4,7,10,12,15), None),\n                (3, (1,2), 250**6), # Base changing S_3 grd up, using Belabash, disc filter, moving them up; redid 6T2 by Rachel/grd, which picks up 6T1\n                (3, (3,), 64**6), # Done by composita\n                (3, (5,), 10**10), # matches Kluners\n                (3, (6,), 10**9), # from Kluners\n                (3, (8,), 15**9), # JJ has double checked\n                (3, (9,), 5*10**9), # from Eric Driver\n                (3, (11,), 10**8), # from Kluners\n                (3, (13,), 10**8-1), # from Eric Driver\n                (3, (14,), 35**6)],\n            7: [# r2=0 bound for arbitrary t is 214942297\n                (0, (3,), 26**7), # LMFDB\n                (0, (5,), 38**7), # LMFDB\n                (0, (6,), 988410720),\n                # r2=1,2,3 bound for arbitrary t is 2*10^8\n                (1, tup(1,7), None),\n                (2, tup(1,5), None),\n                (3, (1,3,5,6), None)],\n            8: [# r2=0 bound for arbitrary t is 17^8\n                (0, (1,2), 150**8), # also 5\n                (0, (5,), 512**8), # LMFDB\n                (0, octic_with_quartic, 10**12),\n                (0, (4,), 55**8),\n                (0, (12,), 56**8),\n                (0, (37,), 30**8),\n                (0, (45,), 3*15**8),\n                # r2=1 bound for arbitrary t is 79259702\n                (1, skip(1,50,{27,32,35,38,44,47}), None),\n                (1, (27,32,35,38,44), 10**12),\n                (1, (47,), 3*10**9),\n                # r2=2 bound for arbitrary t is 20829049\n                (2, tup(1,7)+(8,12,13,14,23,25,36,37,43), None),\n                (2, octic_with_quartic, 4*10**10),\n                (2, octic_type_2, 3*10**9), # from Eric Driver, quartic over quadratic\n                (2, (45,), 3*15**8),\n                (2, (48,), 35831808), # special computation using 7t5 results\n                # r2=3 bound for arbitrary t is 5726300\n                (3, skip(1,50,{6,8,15,23,26,27,30,31,35,38,40,43,44,47}), None),\n                (3, octic_with_quartic, 144*10**8),\n                (3, (8,), 20**9),\n                (3, octic_type_2, 3*10**9), # from Eric Driver, quartic over quadratic\n                # r2=4 bound for arbitrary t is 1656109\n                (4, octic_with_quartic, 49*10**8),\n                (4, (4,), 55**8),\n                (4, (5,), 512**8), # LMFDB\n                (4, (8,), 20**9),\n                (4, octic_type_2, 3*10**9), # from Eric Driver, quartic over quadratic\n                (4, (36,), 15**8), # LMFDB\n                (4, (37,), 30**8),\n                (4, (45,), 3*15**8),\n                (4, (48,), 35831808)], # special computation using 7t5 results\n            9: [# r2=0 bound for arbitrary t is 15^9\n                (0, (1,2,6,7,17), 50**9), # C3 over C3\n                (0, (3,10,11,21), 56**9),\n                (0, (4,8,12,20,29,31), 25**9),\n                (0, (5,), 20**9), # LMFDB\n                (0, (13,22), 32**9),\n                (0, (14,15), 85.96137**9),\n                (0, (16,), 22**9),\n                (0, (18,19,24), 50**9),\n                (0, (23,), 67**9),\n                (0, (25,), 28**9),\n                (0, (26,30), 35**9),\n                # r2=1 bound for arbitrary t is 27316369\n                (1, skip(1,34,{28,31}), None),\n                (1, (28,31), 15**9),\n                # r2=2 bound for arbitrary t is 27316369\n                (2, skip(1,28,{25})+(32,), None),\n                (2, (25,), 23**9),\n                (2, (28,30,31), 15**9),\n                (2, (29,), 18**9),\n                # r2=3 bound for arbitrary t is 146723910\n                (3, (1,2,3,5,6,7,9,10,11,14,15,17,21,23,25,27,30,32,33), None),\n                (3, (4,8,12,20,28,31), 15**9), # 8 is LMFDB\n                (3, (13,16), 12**9), # LMFDB\n                (3, (18,24), 16**9),\n                (3, (19,21,26), 20**9),\n                (3, (22,29), 18**9),\n                # r2=4 bound for arbitrary t is 39657561\n                (4, (1,2,4,6,7,12,13,17,20,22,25,28,29), None),\n                (4, (3,8,10,11,30,31), 15**9), # 8 from LMFDB\n                (4, (5,), 20**9), # LMFDB\n                (4, (14,15), 18**9), # LMFDB\n                (4, (16,), 12**9), # LMFDB\n                (4, (18,24), 16**9),\n                (4, (19,21,26), 20**9),\n                (4, (23,), 17**9)], # LMFDB\n            10: [# bound for arbitrary r2,t is 190612177\n                 (0, decic_with_quad, 12*10**10),\n                 (0, decic_with_quint, 10**13),\n                 (1, skip(1,45,{14,23,29,36,39,43}), None),\n                 (1, (14,23,29,36,39), 10**13), # decic with quintic\n                 (1, (43,), 12*10**10), # decic with quadratic\n                 (2, skip(1,14,{8})+(17,18,19,20,26,30,31,32,35), None),\n                 (2, decic_with_quad, 12*10**10),\n                 (2, decic_with_quint, 10**12),\n                 (3, skip(1,45,{13,14,23,29,32,35,36,38,39,43}), None),\n                 (3, (14,23,29,36,38,39), 10**12), # decic with quintic\n                 (3, (43,), 12*10**10), # decic with quadratic\n                 (4, (1,2,6), None),\n                 (4, decic_with_quad, 12*10**10),\n                 (4, decic_with_quint, 10**12),\n                 (5, (4,7,8,10,13,15,18,20,24,25,26,28,31,32,34,37,42,44), None),\n                 (5, decic_with_quad, 12*10**10),\n                 (5, decic_with_quint, 10**12)],\n            11: [(1, tup(1,8), None),\n                 (2, tup(1,7), None),\n                 (3, tup(1,8), None),\n                 (4, tup(1,5), None),\n                 (5, (1,3,5,6,7), None)],\n        }\n\n        # nS[n] consists of specific sets S so that we have completeness in degree n for number fields unramified outside S.\n        self._nS = {\n            5: {(2,191), (3,163), (3,181), (3,211), (3,241), (3,401), (3,431), (3,461), (5,211), (5,241), (7,163), (7,181), (2,7,31), (2,7,41), (2,11,31)},\n            6: {(2,3,7)},\n            7: {(2,11), (2,13), (3,11), (11,13)}\n        }\n\n        # If nSp[n][k] = M then we have completeness in degree n for number fields unramified outside of S for all S of size k consisting of primes less than M.\n        self._nSp = {\n            2: {1: 12000, 2: 500, 3: 100, 4: 30, 5: 30, 6: 30, 7: 30, 8: 30, 9: 30, 10: 30},\n            #2: {1: 12000, 2: 500, 3: 100, 4: 30, 5: 18, 6: 18, 7: 18},\n            3: {1: 12000, 2: 500, 3: 100, 4: 30, 5: 30, 6: 30, 7: 30, 8: 30, 9: 30, 10: 30},\n            #3: {1: 12000, 2: 500, 3: 100, 4: 30, 5: 24, 6: 24, 7: 24, 8: 24, 9: 24},\n            4: {1: 12000, 2: 500, 3: 100, 4: 30, 5: 14, 6: 14},\n            5: {1: 7500, 2: 150, 3: 24, 4: 8},\n            6: {1: 2000, 2: 32},\n            7: {1: 192, 2: 6},\n        }\n\n        # nSGp[n][k] is a list of pairs (M, Gs) so that we have completeness in degree n for number fields with Galois group nTt for t in Gs and unramified outside a set S of size k all of whose primes are less than M\n        self._nSGp = {\n            6: {1: [(5000, tup(1,15))],\n                2: [(100, (12,14))],\n                3: [(12, (12,14)), (8, tup(1,15))],\n                4: [(8, tup(1,15))]},\n            7: {1: [(5000, (1,2,3)), (1500, (4,)), (228, (5,6))],\n                2: [(42, (1,)), (14, (3,)), (8, (2,)), (6, (4,))],\n                3: [(42, (1,)), (14, (3,)), (8, (2,)), (6, (4,))],\n                4: [(42, (1,)), (14, (3,)), (8, (2,))],\n                5: [(42, (1,)), (14, (3,))],\n                6: [(42, (1,)), (14, (3,))],\n                7: [(42, (1,))],\n                8: [(42, (1,))],\n                9: [(42, (1,))],\n                10: [(42, (1,))],\n                11: [(42, (1,))],\n                12: [(42, (1,))],\n                13: [(42, (1,))]},\n            8: {1: [(2500, octic_2_group), (230, octwith4), (228, (37,)), (200, (25,)), (8, octic_with_quartic), (8, (25,36)), (6, (33,34,41,42,45,46,47))],\n                2: [(250, octic_2_group), (8, octic_with_quartic), (8, (25,36)), (6, (33,34,41,42,45,46,47))],\n                3: [(8, octic_with_quartic), (8, (25,36)), (6, (33,34,41,42,45,46,47))],\n                4: [(8, (25,36))]},\n            9: {1: [(6, tup(1,19)+tup(20,26)+(28,29,31)), (6, (19,26,30))],\n                2: [(6, tup(1,19)+tup(20,26)+(28,29,31)), (6, (19,26,30))],\n                3: [(6, tup(1,19)+tup(20,26)+(28,29,31))]},\n            10: {1: [(20, (32,)), (6, decic_with_quint), (6, (6,7,9,10,13,17)), (4, (18,19,20,21,26,27,32,33))],\n                 2: [(20, (32,)), (6, decic_with_quint), (6, (6,7,9,10,13,17)), (4, (18,19,20,21,26,27,32,33))],\n                 3: [(6, decic_with_quint), (6, (6,7,9,10,13,17))]},\n            11: {1: [(200, (1,)), (5000, (2,)), (12, (3,))],\n                 2: [(8, (1,2,3))],\n                 3: [(8, (1,2,3))],\n                 4: [(8, (1,2,3))]},\n            13: {1: [(5000, (2,))]},\n            24: {1: [(1000, (1,))]},\n            25: {1: [(1000, (1,))]},\n        }\n\n        # nSGp1[n] is a list of triples (p, M, Gs) so that we have completeness in degree n for number fields with Galois group nTt for t in Gs and unramified outside {p,q} for q < M.\n        self._nSGp1 = {\n            4: [(2, 2500, quartic_2_group)],\n            5: [(3, 1328, (1,2,4)), (2, 980, (1,2,4))],\n            8: [(2, 2500, octic_2_group), (2, 200, (25,))],\n        }\n\n        # nSG[n] is a list of pairs (T, Gs) so that we have completeness in degree n for number fields with Galois group nTt for t in Gs and unramified outside S for any subset S of T.\n        self._nSG = {\n            5: [((2,3,7,11), (1,2,4)),\n                ((2,3,7,31), (1,2,4)),\n                ((2,3,11,19), (1,2,4)),\n                ((2,3,31), (1,2,4)),\n                ((2,3,37), (1,2,4)),\n                ((2,3,41), (1,2,4)),\n                ((2,3,43), (1,2,4)),\n                ((2,3,53), (1,2,4)),\n                ((2,3,61), (1,2,4)),\n                ((2,3,79), (1,2,4)),\n                ((2,3,89), (1,2,4)),\n                ((2,3,101), (1,2,4)),\n                ((2,3,103), (1,2,4)),\n                ((2,3,107), (1,2,4)),\n                ((2,3,113), (1,2,4)),\n                ((2,3,127), (1,2,4)),\n                ((2,3,131), (1,2,4)),\n                ((2,3,137), (1,2,4)),\n                ((2,3,151), (1,2,4)),\n                ((2,5,13), (1,2,4)),\n                ((2,5,17), (1,2,4)),\n                ((2,5,23), (1,2,4)),\n                ((2,5,29), (1,2,4)),\n                ((2,5,31), (1,2,4)),\n                ((2,7,17), (1,2,4)),\n                ((2,7,19), (1,2,4)),\n                ((2,7,59), (1,2,4)),\n                ((2,7,61), (1,2,4)),\n                ((2,7,71), (1,2,4)),\n                ((2,7,103), (1,2,4)),\n                ((2,7,127), (1,2,4)),\n                ((2,7,131), (1,2,4)),\n                ((2,13,71), (1,2,4)),\n                ((2,17,31), (1,2,4)),\n                ((2,19,23), (1,2,4)),\n                ((2,23,41), (1,2,4)),\n                ((2,29,31), (1,2,4)),\n                ((2,11,13), (1,2,4)),\n                ((2,11,17), (1,2,4)),\n                ((2,11,19), (1,2,4)),\n                ((2,11,23), (1,2,4)),\n                ((2,11,29), (1,2,4)),\n                ((2,11,31), (1,2,4)),\n                ((2,11,37), (1,2,4)),\n                ((2,11,41), (1,2,4)),\n                ((2,11,43), (1,2,4)),\n                ((2,11,47), (1,2,4)),\n                ((2,11,53), (1,2,4)),\n                ((2,11,59), (1,2,4)),\n                ((2,11,61), (1,2,4)),\n                ((2,11,67), (1,2,4)),\n                ((2,11,71), (1,2,4)),\n                ((2,11,73), (1,2,4)),\n                ((2,13,29), (1,2,4)),\n                ((2,13,31), (1,2,4)),\n                ((2,13,37), (1,2,4)),\n                ((2,13,41), (1,2,4)),\n                ((2,13,43), (1,2,4)),\n                ((2,13,47), (1,2,4)),\n                ((2,13,53), (1,2,4)),\n                ((2,13,59), (1,2,4)),\n                ((2,13,61), (1,2,4)),\n                ((2,13,67), (1,2,4)),\n                ((2,13,71), (1,2,4)),\n                ((2,13,73), (1,2,4)),\n                ((2,17,31), (1,2,4)),\n                ((2,19,23), (1,2,4)),\n                ((2,23,41), (1,2,4)),\n                ((2,29,31), (1,2,4)),\n                ((3,5,17), (1,2,4)),\n                ((3,5,31), (1,2,4)),\n                ((3,5,37), (1,2,4)),\n                ((3,7,11), (1,2,4)),\n                ((3,7,11,17), (1,2,4)),\n                ((3,7,17), (1,2,4)),\n                ((3,7,31), (1,2,4)),\n                ((3,7,41), (1,2,4)),\n                ((3,7,61), (1,2,4)),\n                ((3,7,101), (1,2,4)),\n                ((3,7,107), (1,2,4)),\n                ((3,7,131), (1,2,4)),\n                ((3,7,139), (1,2,4)),\n                ((3,7,163), (1,2,4)),\n                ((3,7,181), (1,2,4)),\n                ((3,11,13), (1,2,4)),\n                ((3,11,17), (1,2,4)),\n                ((3,11,19), (1,2,4)),\n                ((3,11,29), (1,2,4)),\n                ((3,11,31), (1,2,4)),\n                ((3,11,41), (1,2,4)),\n                ((3,11,61), (1,2,4)),\n                ((3,11,71), (1,2,4)),\n                ((3,11,73), (1,2,4)),\n                ((3,11,101), (1,2,4)),\n                ((3,11,103), (1,2,4)),\n                ((3,11,109), (1,2,4)),\n                ((3,13,31), (1,2,4)),\n                ((3,13,41), (1,2,4)),\n                ((3,13,61), (1,2,4)),\n                ((3,13,71), (1,2,4)),\n                ((3,13,89), (1,2,4)),\n                ((3,17,37), (1,2,4)),\n                ((3,17,41), (1,2,4)),\n                ((3,17,43), (1,2,4)),\n                ((3,17,71), (1,2,4)),\n                ((3,19,61), (1,2,4)),\n                ((3,29,37), (1,2,4)),\n                ((3,29,41), (1,2,4)),\n                ((3,31,41), (1,2,4)),\n                ((5,7,13), (1,2,4)),\n                ((5,7,17), (1,2,4)),\n                ((5,7,71), (1,2,4)),\n                ((5,7,97), (1,2,4)),\n                ((5,11,13), (1,2,4)),\n                ((5,11,19), (1,2,4)),\n                ((5,11,31), (1,2,4)),\n                ((5,11,41), (1,2,4)),\n                ((5,11,43), (1,2,4)),\n                ((5,11,71), (1,2,4)),\n                ((5,13,23), (1,2,4)),\n                ((5,151), (1,2,4)),\n                ((5,163), (1,2,4)),\n                ((5,223), (1,2,4)),\n                ((5,241), (1,2,4)),\n                ((5,367), (1,2,4)),\n                ((5,571), (1,2,4)),\n                ((5,631), (1,2,4)),\n                ((7,11,17), (1,2,4)),\n                ((7,11,23), (1,2,4)),\n                ((7,11,37), (1,2,4)),\n                ((7,13,31), (1,2,4)),\n                ((7,13,37), (1,2,4)),\n                ((7,13,41), (1,2,4)),\n                ((7,151), (1,2,4)),\n                ((7,163), (1,2,4)),\n                ((7,181), (1,2,4)),\n                ((7,191), (1,2,4)),\n                ((7,211), (1,2,4)),\n                ((7,241), (1,2,4)),\n                ((7,257), (1,2,4)),\n                ((7,281), (1,2,4)),\n                ((7,313), (1,2,4)),\n                ((7,331), (1,2,4)),\n                ((7,379), (1,2,4)),\n                ((7,401), (1,2,4)),\n                ((7,409), (1,2,4)),\n                ((7,421), (1,2,4)),\n                ((7,433), (1,2,4)),\n                ((7,431), (1,2,4)),\n                ((7,491), (1,2,4)),\n                ((7,541), (1,2,4)),\n                ((7,571), (1,2,4)),\n                ((11,13,23), (1,2,4)),\n                ((11,17,19), (1,2,4)),\n                ((11,151), (1,2,4)),\n                ((11,167), (1,2,4)),\n                ((11,179), (1,2,4)),\n                ((11,181), (1,2,4)),\n                ((11,191), (1,2,4)),\n                ((11,211), (1,2,4)),\n                ((11,251), (1,2,4)),\n                ((11,269), (1,2,4)),\n                ((11,263), (1,2,4)),\n                ((11,271), (1,2,4)),\n                ((11,281), (1,2,4)),\n                ((11,283), (1,2,4)),\n                ((11,311), (1,2,4)),\n                ((11,293), (1,2,4)),\n                ((11,307), (1,2,4)),\n                ((11,331), (1,2,4)),\n                ((11,331), (1,2,4)),\n                ((11,359), (1,2,4)),\n                ((13,191), (1,2,4)),\n                ((13,223), (1,2,4)),\n                ((13,211), (1,2,4)),\n                ((13,307), (1,2,4)),\n                ((17,227), (1,2,4)),\n                ((17,211), (1,2,4)),\n                ((19,191), (1,2,4)),\n                ((19,157), (1,2,4)),\n                ((19,181), (1,2,4)),\n                ((19,193), (1,2,4)),\n                ((23,151), (1,2,4)),\n                ((23,173), (1,2,4))],\n            8: [((2,3), (37,48)),\n                ((2,5), (37,48)),\n                ((2,29), (25,)),\n                ((7,29), (25,)),\n                ((41, 241), octic_2_group)],\n            9: [((3,7,13), (1,2,6,7,17))],\n            10: [((2,3,7), (32,)),\n                 ((2,7), decic_with_quad),\n                 ((2,5), (19,20,21,26,32)),\n                 ((3,5), (18,19,20,21,26,27,32,33))],\n            11: [((2,11), (3,)),\n                 ((3,11), (3,)),\n                 ((7,11), (3,))],\n        }\n\n    def display_reason(self, reasons):\n        \"\"\"\n        Convert a set of collected reasons into a single string to display.\n\n        INPUT:\n\n        - ``reasons`` -- a set of reasons, which are either a string or\n          a tuple of the form ``(n, r2, galt, ramps, D_bound, grd_bound)``,\n          where entries are None if they are not applicable.\n        \"\"\"\n        # Current tuples created:\n        # (n, r2, None, None, M, None)\n        # (n, r2, Gs, None, M, None)\n        # (n, None, Gs, None, None, M)\n        # (n, None, None, S, None, None)\n        # (n, None, Gs, S, None, None)\n        # We group by None pattern\n        def describe(tups):\n            ans = []\n            if tups[0][0] is not None:\n                degs = [str(tup[0]) for tup in tups]\n                if len(set(degs)) == 1:\n                    ans.append(f\"degree {degs[0]}\")\n                else:\n                    ans.append(f\"degree {','.join(degs)}\")\n            if tups[0][1] is not None:\n                sigs = [f\"[{tup[0]-2*tup[1]},{tup[1]}]\" for tup in tups]\n                if len(set(sigs)) == 1:\n                    ans.append(f\"signature {sigs[0]}\")\n                else:\n                    ans.append(f\"signature {','.join(sigs)}\")\n            if tups[0][2] is not None:\n                ts = [f\"({','.join(str(t) for t in tup[2])})\" if len(tup[2]) > 1 else str(tup[2][0]) for tup in tups]\n                gals = [f\"{tup[0]}T{tt}\" for (tup, tt) in zip(tups, ts)]\n                if len(set(gals)) == 1:\n                    ans.append(f\"Galois group {gals[0]}\")\n                else:\n                    ans.append(f\"Galois group {','.join(gals)}\")\n            if tups[0][3] is not None:\n                rams = ['{'+','.join(str(p) for p in tup[3])+'}' for tup in tups]\n                if len(set(rams)) == 1:\n                    ans.append(f\"unramified outside {rams[0]}\")\n                else:\n                    ans.append(f\"unramified outside {','.join()}\")\n            if tups[0][4] is not None:\n                Dbounds = [str(tup[4]) for tup in tups]\n                if len(set(Dbounds)) == 1:\n                    ans.append(f\"absolute discriminant at most {Dbounds[0]}\")\n                else:\n                    ans.append(f\"absolute discriminant at most {','.join(Dbounds)}\")\n            if tups[0][5] is not None:\n                grd = [str(tup[5]) for tup in tups]\n                if len(set(grd)) == 1:\n                    ans.append(f\"Galois root discriminant at most {grd[0]}\")\n                else:\n                    ans.append(f\"Galois root discriminant at most {','.join(grd)}\")\n            return \", \".join(ans)\n        strings = []\n        by_pattern = defaultdict(list)\n        non_incomp = []\n        for reason in reasons:\n            if isinstance(reason, str):\n                strings.append(reason)\n                if not reason.startswith(\"incompatible conditions\"):\n                    non_incomp.append(reason)\n            else:\n                by_pattern[tuple(i for i in range(6) if reason[i] is None)].append(reason)\n        if len(non_incomp) + len(by_pattern) > 0:\n            strings = non_incomp\n        return \"number fields with \" + \"; \".join(strings + [describe(V) for V in by_pattern.values()])\n\n    def clear_signatures(self, n, D, r2opts, reasons):\n        if 2 <= n < len(self._maxD):\n            m = infinity\n            for r2 in set(r2opts):\n                M = self._maxD[n][r2]\n                if D.bounded(M):\n                    r2opts.remove(r2)\n                    reasons.add((n, r2, None, None, M, None))\n                m = min(m, M)\n            if m is not infinity:\n                D = D.intersection(bottom(m + 1))\n        return D\n\n    def clear_r2G(self, n, D, r2opts, galt, reasons):\n        r2G = defaultdict(dict)\n        for (r2, Gs, M) in self._r2G.get(n, []):\n            if r2 in r2opts and D.bounded(M):\n                for t in galt.intersection(Gs):\n                    r2G[t][r2] = (r2, Gs, M)\n        for t in galt.intersection(r2G):\n            if set(r2G[t]) == set(r2opts):\n                galt.remove(t)\n                for r2, Gs, M in r2G[t].values():\n                    reasons.add((n, r2, Gs, None, M, None))\n\n    def clear_grd(self, n, grd, galt, reasons):\n        by_t = {}\n        for (Gs, M) in self._grd.get(n, []):\n            if grd.bounded(M):\n                for t in galt.intersection(Gs):\n                    by_t[t] = (Gs, M)\n        for t in galt.intersection(by_t):\n            galt.remove(t)\n            Gs, M = by_t[t]\n            reasons.add((n, None, Gs, None, None, M))\n\n    def clear_S(self, n, S, nram, galt, reasons, update_galt=True):\n        \"\"\"\n        When False, if update_galt is True, update galt to remove t that can be proven complete.\n        \"\"\"\n        if galt is not None and not update_galt:\n            galt = set(galt)\n        if nram is None:\n            nram = len(S)\n\n        if S in self._nS.get(n, {}):\n            reasons.add((n, None, None, S, None, None))\n            return True\n\n        M = self._nSp.get(n, {}).get(nram)\n        if M is not None and all(p < M for p in S):\n            reasons.add((n, None, None, S, None, None))\n            return True\n\n        if galt is None:\n            return False\n\n        for (M, Gs) in self._nSGp.get(n, {}).get(nram, []):\n            if all(p < M for p in S):\n                I = galt.intersection(Gs)\n                if I:\n                    reasons.add((n, None, Gs, S, None, None))\n                    galt.difference_update(I)\n                    if not galt:\n                        return True\n\n        if len(S) == 2:\n            for (p0, M, Gs) in self._nSGp1.get(n, []):\n                if min(S) == p0 and max(S) < M:\n                    I = galt.intersection(Gs)\n                    if I:\n                        reasons.add((n, None, Gs, S, None, None))\n                        galt.difference_update(I)\n                        if not galt:\n                            return True\n\n        SS = set(S)\n        for T, Gs in self._nSG.get(n, []):\n            if SS.issubset(T):\n                I = galt.intersection(Gs)\n                if I:\n                    reasons.add((n, None, Gs, S, None, None))\n                    galt.difference_update(I)\n                    if not galt:\n                        return True\n\n        return False\n\n    def galt(self, n, gal, isgal, cyc, ab, solv):\n        pos_constraints = []\n        neg_constraints = []\n        if isinstance(gal, str) and gal.count(\"T\") == 1:\n            N, t = gal.split(\"T\")\n            if N == str(n) and t.isdigit():\n                pos_constraints.append({int(t)})\n            else:\n                return # incompatible constraints\n        elif isinstance(gal, dict) and list(gal) == [\"$in\"]:\n            galt = set()\n            n = str(n)\n            for G in gal[\"$in\"]:\n                if not isinstance(G, str) or G.count(\"T\") != 1:\n                    raise ValueError\n                N, t = G.split(\"T\")\n                if N == n and t.isdigit():\n                    galt.add(int(t))\n            pos_constraints.append(galt)\n        elif gal is not None or n >= len(self._num_trans):\n            raise ValueError\n        if cyc == 1:\n            if n == 32:\n                pos_constraints.append({33})\n            else:\n                pos_constraints.append({1})\n        elif cyc == 0:\n            if n == 32:\n                neg_constraints.append({33})\n            else:\n                neg_constraints.append({1})\n        elif cyc is not None:\n            raise ValueError\n\n        if ab == 1:\n            pos_constraints.append(self._ab.get(n, {1}))\n        elif ab == 0:\n            neg_constraints.append(self._ab.get(n, {1}))\n        elif ab is not None:\n            raise ValueError\n\n        gal_set = self._ab.get(n, {1}).union(self._nab_gal.get(n, set()))\n        if isgal == 1:\n            pos_constraints.append(gal_set)\n        elif isgal == 0:\n            neg_constraints.append(gal_set)\n        elif isgal is not None:\n            raise ValueError\n\n        if solv == 1:\n            if n in self._nsolv:\n                neg_constraints.append(self._nsolv[n])\n        elif solv == 0:\n            if n in self._nsolv:\n                pos_constraints.append(self._nsolv[n])\n        elif solv is not None:\n            raise ValueError\n\n        if pos_constraints:\n            galt = pos_constraints[0]\n            for Gs in pos_constraints[1:]:\n                galt.intersection_update(Gs)\n        else:\n            galt = set(range(1, self._num_trans[n] + 1))\n        for Gs in neg_constraints:\n            galt.difference_update(Gs)\n        return galt\n\n    def rd_grd_ratio(self, n, galt):\n        if n < len(self._rdgrd) and max(galt) <= len(self._rdgrd[n]):\n            return max(1 / self._rdgrd[n][t - 1] for t in galt)\n\n    def get_S(self, ramps, radical):\n        S = None\n        if radical is not None:\n            if isinstance(radical, dict):\n                if not (list(radical) == [\"$lte\"] and isinstance(ramps, dict) and \"$containedin\" in ramps and prod(ramps[\"$containedin\"]) == radical[\"$lte\"]):\n                    # Such constraints are not created by parsing code, so we give up\n                    return\n                # Now we can just fall back on ramps parsing below\n            else:\n                S = set(p for p,e in factor(radical))\n        if ramps is not None:\n            if isinstance(ramps, dict):\n                if \"$containedin\" in ramps:\n                    if S is not None:\n                        if not S.issubset(ramps[\"$containedin\"]):\n                            # incompatible, so result is complete.  We return an S that will be accepted for all n <= 11\n                            return []\n                    else:\n                        S = ramps[\"$containedin\"]\n                else:\n                    # $notcontains and $contains do not yield finite S\n                    return\n            if isinstance(ramps, list):\n                if S is not None:\n                    if not S.issubset(ramps):\n                        # incompatible, so result is complete.  We return an S that will be accepted for all n <= 11\n                        return []\n                else:\n                    S = ramps\n        if S is not None:\n            return tuple(sorted(S))\n\n    def _initial(self, db, query, reasons):\n        \"\"\"\n        Attempt to prove completeness without splitting on degree\n        \"\"\"\n        D, rd, grd = IntegerSet(query.get(\"disc_abs\")), NumberSet(query.get(\"rd\")), NumberSet(query.get(\"grd\"))\n        if D.bounded(1656109):\n            reasons.add(\"absolute discriminant at most 1656109\")\n            return True, None\n        if rd.bounded(5.989):\n            reasons.add(\"root discriminant at most 5.989\")\n            return True, None\n        if grd.bounded(5.989):\n            reasons.add(\"Galois root discriminant at most 5.989\")\n            return True, None\n        # Can also guarantee completeness based on regulator bounds and non-CMness: see https://arxiv.org/pdf/2112.15268\n\n        # TODO: use Odlyzko bounds to get upper bound on degree\n        return False, None\n\n    def _one_n(self, db, query, reasons):\n        n = query.get(\"degree\")\n        if n == 1:\n            reasons.add(\"degree 1\")\n            return True, None\n        # For now, we just do not guarantee completeness for any degrees larger than 25.\n        # TODO: improve this using Minkowski and Odlyzko bounds (which give us guarantees that there are no number fields\n        if n is None or n > 25:\n            return False, None\n\n        r2, D, sign, rd, grd = IntegerSet(query.get(\"r2\")), IntegerSet(query.get(\"disc_abs\")), query.get(\"disc_sign\"), NumberSet(query.get(\"rd\")), NumberSet(query.get(\"grd\"))\n        r2opts = list(r2.intersection(IntegerSet([0, n//2])))\n        if sign == 1:\n            r2opts = [r2 for r2 in r2opts if r2 % 2 == 0]\n        elif sign == -1:\n            r2opts = [r2 for r2 in r2opts if r2 % 2 == 1]\n        if not r2opts:\n            reasons.add(\"incompatible conditions: signature and discriminant\")\n            return True, None\n        if n == 2 and r2opts == [1]:\n            # Imaginary quadratic fields, where we can use Mark Watkins' paper (Class groups of imaginary quadratic fields) to guarantee completeness based on class number\n            h = query.get(\"class_number\")\n            C = query.get(\"class_group\")\n            if isinstance(C, list) and h is None:\n                h = prod(C)\n            h = IntegerSet(h)\n            if h.is_subset(top(97).union(IntegerSet([99,100]))):\n                # Class number 98 has entries slightly outside our bounds\n                # Watkins' result is actually unconditional\n                reasons.add(\"signature [0,1], class number at most 100 (except 98)\")\n                return True, None\n\n            # We can also use https://msp.org/obs/2019/2-1/obs-v2-n1-p16-s.pdf\n            if isinstance(C, list) and all(c == 2 for c in C):\n                reasons.add(\"signature [0,1], class group of exponent 2\")\n                return True, \"depends on GRH\"\n\n        if n > 2 and any(col in query for col in [\"class_group\", \"class_number\", \"narrow_class_group\", \"narrow_class_number\"]):\n            caveat = \"depends on GRH\"\n        else:\n            caveat = None\n\n        ## Completeness 1: degree, signature, discriminant ##\n        if grd.restricted():\n            rd = rd.pow_cap(grd, 1)\n            if not rd:\n                reasons.add(\"incompatible conditions: root discriminant and Galois root discriminant\")\n                return True, None\n        if rd.restricted():\n            D = D.pow_cap(rd, n)\n            if not D:\n                reasons.add(\"incompatible conditions: root discriminant and discriminant\")\n                return True, None\n        if D.restricted():\n            D = self.clear_signatures(n, D, r2opts, reasons)\n            if not r2opts:\n                return True, caveat\n\n        ## Completeness 2: degree, signature, Galois group, discriminant\n        gal, isgal, cyc, ab, solv, = query.get(\"galois_label\"), query.get(\"is_galois\"), query.get(\"gal_is_cyclic\"), query.get(\"gal_is_abelian\"), query.get(\"gal_is_solvable\")\n        if gal or isgal or cyc or ab or solv:\n            try:\n                galt = self.galt(n, gal, isgal, cyc, ab, solv)\n            except ValueError:\n                # Parsing problem\n                return False, None\n            if not galt:\n                reasons.add(\"incompatible conditions: Galois group\")\n                return True, None\n            if D.restricted():\n                self.clear_r2G(n, D, r2opts, galt, reasons)\n                if not galt:\n                    return True, caveat\n\n            ## Completeness 3: degree, Galois group, Galois root discriminant ##\n            if D.restricted():\n                rd = rd.pow_cap(D, 1/n)\n                if not rd:\n                    reasons.add(\"incompatible conditions: root discriminant and discriminant\")\n                    return True, None\n            if rd.restricted():\n                ratio = self.rd_grd_ratio(n, galt)\n                if ratio is not None:\n                    grd = grd.pow_cap(rd, ratio)\n                    if not grd:\n                        reasons.add(\"incompatible conditions: root discriminant and Galois root discriminant\")\n                        return True, None\n            if grd.restricted():\n                self.clear_grd(n, grd, galt, reasons)\n                if not galt:\n                    return True, caveat\n        else:\n            galt = None\n\n        ## Completeness 4: degree, ramified primes, and Galois group (optional)\n        # Can fill rams from discriminant range, or from radical\n        ramps, radical, nram = query.get(\"ramps\"), query.get(\"disc_rad\"), query.get(\"num_ram\")\n        if isinstance(nram, dict):\n            if \"$lte\" in nram:\n                nram = nram[\"$lte\"]\n            else:\n                # nram is complicated, so we give up on using it\n                nram = None\n        if ramps or radical:\n            S = self.get_S(ramps, radical)\n            if S == []: # incompatible\n                reasons.add(\"incompatible conditions: ramps and radical\")\n                return True, None\n            if S is not None and self.clear_S(n, S, nram, galt, reasons):\n                return True, caveat\n\n        # Can also iterate over valid discriminants in a discriminant range\n        if D.restricted():\n            for S in D.stickelberger(n, r2opts):\n                if not self.clear_S(n, S, nram, galt, reasons, update_galt=False):\n                    break\n            else:\n                if not reasons:\n                    reasons.add(\"incompatible conditions: no valid discriminants in range\")\n                return True, caveat\n\n            # Minkowski bound (only relevant for n>12)\n            if n >= len(self._maxD):\n                mbound = (3.14159265358979/4)**n * n**(2*n) / factorial(n)**2\n                if D.bounded(mbound):\n                    reasons.add(f\"number fields of degree {n} with discriminant at most {floor(mbound)} (Minkowski)\")\n                    return True, None\n            # TODO: Odlyzko bounds\n\n        return False, None\n\n    def __call__(self, db, query):\n        n = query.get(\"degree\")\n\n        # We collect reasons that have contributed to completeness\n        # These have the following format:\n        # (n, r2, galt, ramps, D_bound, grd_bound)\n        # Where entries can be None if they are not applicable\n        reasons = set()\n        # First check completeness without splitting on degree\n        # This may also add an upper bound on degree, based on other inputs\n        done, caveat = self._initial(db, query, reasons)\n        if done:\n            return True, self.display_reason(reasons), caveat\n        if isinstance(n, dict):\n            nopts = IntegerSet(n).intersection(bottom(1))\n            if nopts.max() >= 48:\n                return False, None, None\n            caveats = set()\n            # Reverse order since we're less likely to have completeness in higher degree\n            for n in reversed(list(nopts)):\n                nquery = dict(query)\n                nquery[\"degree\"] = n\n                ok, caveat = self._one_n(db, nquery, reasons)\n                if not ok:\n                    return False, None, None\n                if caveat:\n                    caveats.add(caveat)\n            if caveats:\n                caveats = \", \".join(caveats)\n            else:\n                caveats = None\n        else:\n            ok, caveats = self._one_n(db, query, reasons)\n            if not ok:\n                return False, None, None\n        return True, self.display_reason(reasons), caveats"
  }
]