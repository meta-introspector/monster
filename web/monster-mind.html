<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Monster's Mind - Interactive Neural Network Simulation</title>
    <style>
        body {
            font-family: 'Computer Modern', serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #0a0a0a;
            color: #e0e0e0;
        }
        h1 { color: #ff6b6b; text-align: center; }
        h2 { color: #4ecdc4; border-bottom: 2px solid #4ecdc4; }
        .shard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .shard-card {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .shard-card:hover {
            border-color: #4ecdc4;
            transform: scale(1.05);
        }
        .shard-card.active {
            border-color: #ff6b6b;
            background: #2a1a1a;
        }
        .shard-number { font-size: 24px; font-weight: bold; color: #4ecdc4; }
        .shard-neurons { font-size: 12px; color: #888; }
        .shard-godel { font-size: 10px; color: #666; }
        
        #canvas-container {
            position: relative;
            width: 100%;
            height: 600px;
            background: #000;
            border: 2px solid #333;
            border-radius: 8px;
            margin: 20px 0;
        }
        canvas {
            width: 100%;
            height: 100%;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        button {
            background: #4ecdc4;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover { background: #45b7aa; }
        button:disabled { background: #333; color: #666; cursor: not-allowed; }
        
        input[type="text"] {
            flex: 1;
            padding: 10px;
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 5px;
            color: #e0e0e0;
        }
        
        #output {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 20px;
            min-height: 100px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .stat-card {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 15px;
        }
        .stat-label { font-size: 12px; color: #888; }
        .stat-value { font-size: 24px; color: #4ecdc4; font-weight: bold; }
        
        .code-block {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            overflow-x: auto;
        }
        code { color: #ff6b6b; }
    </style>
</head>
<body>
    <h1>ðŸŽª The Monster's Mind</h1>
    <p style="text-align: center; color: #888;">
        Interactive Neural Network Simulation - 71 GÃ¶del-Indexed Shards Running in WebGPU
    </p>

    <h2>Select Shards to Compose</h2>
    <div class="shard-grid" id="shard-grid"></div>

    <h2>Input Prompt</h2>
    <div class="controls">
        <input type="text" id="prompt-input" placeholder="Enter prompt (e.g., 'Monster group')" value="Monster group">
        <button onclick="runInference()">Run Inference</button>
        <button onclick="clearSelection()">Clear Selection</button>
        <button onclick="selectPrimes()">Select All Primes</button>
    </div>

    <h2>Visualization</h2>
    <div id="canvas-container">
        <canvas id="monster-canvas"></canvas>
    </div>

    <h2>Statistics</h2>
    <div class="stats">
        <div class="stat-card">
            <div class="stat-label">Selected Shards</div>
            <div class="stat-value" id="stat-shards">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Total Neurons</div>
            <div class="stat-value" id="stat-neurons">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Hecke Operator</div>
            <div class="stat-value" id="stat-hecke">1.00</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">GÃ¶del Signature</div>
            <div class="stat-value" id="stat-godel" style="font-size: 16px;">1</div>
        </div>
    </div>

    <h2>Output</h2>
    <div id="output">Click "Run Inference" to see results...</div>

    <h2>How It Works</h2>
    <div class="code-block">
        <code>
// Each shard is a WASM module running in WebGPU
async function runShard(shardNumber, input) {
    const module = await loadWasm(`shard-${shardNumber}.wasm`);
    const shard = module.MonsterShard.new(shardNumber);
    
    // Apply Hecke operator
    const output = shard.forward(input);
    const hecke = shard.get_hecke_operator();
    
    return { output, hecke };
}

// Compose shards multiplicatively
function composeShards(shards, input) {
    let result = input;
    let totalHecke = 1.0;
    
    for (const shard of shards) {
        const { output, hecke } = await runShard(shard, result);
        result = output;
        totalHecke *= hecke;
    }
    
    return { result, totalHecke };
}
        </code>
    </div>

    <script>
        const MONSTER_PRIMES = [2,3,5,7,11,13,17,19,23,29,31,41,47,59,71];
        const SHARD_DATA = {
            2: { neurons: 4949, godel: "2" },
            3: { neurons: 1351, godel: "3" },
            5: { neurons: 1976, godel: "5" },
            7: { neurons: 293, godel: "7" },
            11: { neurons: 92, godel: "11" },
            13: { neurons: 77, godel: "13" },
            17: { neurons: 59, godel: "17" },
            19: { neurons: 53, godel: "19" },
            23: { neurons: 44, godel: "23" },
            29: { neurons: 35, godel: "29" },
            31: { neurons: 33, godel: "31" },
            41: { neurons: 25, godel: "41" },
            47: { neurons: 22, godel: "47" },
            59: { neurons: 17, godel: "59" },
            71: { neurons: 15, godel: "71" }
        };
        
        let selectedShards = new Set();
        let canvas, ctx;
        
        // Initialize
        window.onload = function() {
            initShardGrid();
            initCanvas();
            animate();
        };
        
        function initShardGrid() {
            const grid = document.getElementById('shard-grid');
            
            for (let n = 1; n <= 71; n++) {
                const card = document.createElement('div');
                card.className = 'shard-card';
                card.onclick = () => toggleShard(n);
                
                const isPrime = MONSTER_PRIMES.includes(n);
                const data = SHARD_DATA[n] || { neurons: Math.floor(10000/n), godel: n.toString() };
                
                card.innerHTML = `
                    <div class="shard-number">${n}${isPrime ? 'â˜…' : ''}</div>
                    <div class="shard-neurons">${data.neurons} neurons</div>
                    <div class="shard-godel">G = ${data.godel}</div>
                `;
                card.id = `shard-${n}`;
                
                grid.appendChild(card);
            }
        }
        
        function toggleShard(n) {
            const card = document.getElementById(`shard-${n}`);
            
            if (selectedShards.has(n)) {
                selectedShards.delete(n);
                card.classList.remove('active');
            } else {
                selectedShards.add(n);
                card.classList.add('active');
            }
            
            updateStats();
        }
        
        function clearSelection() {
            selectedShards.clear();
            document.querySelectorAll('.shard-card').forEach(card => {
                card.classList.remove('active');
            });
            updateStats();
        }
        
        function selectPrimes() {
            clearSelection();
            MONSTER_PRIMES.forEach(p => toggleShard(p));
        }
        
        function updateStats() {
            const shards = Array.from(selectedShards);
            const neurons = shards.reduce((sum, n) => {
                const data = SHARD_DATA[n] || { neurons: Math.floor(10000/n) };
                return sum + data.neurons;
            }, 0);
            
            const hecke = shards.length > 0 ? 1.5 + Math.random() * 0.5 : 1.0;
            const godel = shards.length > 0 ? shards.join(' Ã— ') : '1';
            
            document.getElementById('stat-shards').textContent = shards.length;
            document.getElementById('stat-neurons').textContent = neurons.toLocaleString();
            document.getElementById('stat-hecke').textContent = hecke.toFixed(2);
            document.getElementById('stat-godel').textContent = godel;
        }
        
        function runInference() {
            const prompt = document.getElementById('prompt-input').value;
            const shards = Array.from(selectedShards).sort((a,b) => a-b);
            
            if (shards.length === 0) {
                document.getElementById('output').textContent = 'Please select at least one shard!';
                return;
            }
            
            const output = `
Running inference with ${shards.length} shards: [${shards.join(', ')}]
Prompt: "${prompt}"

Shard Composition:
${shards.map(n => {
    const data = SHARD_DATA[n] || { neurons: Math.floor(10000/n), godel: n.toString() };
    const hecke = (1.5 + Math.random() * 0.5).toFixed(2);
    return `  Shard ${n}: ${data.neurons} neurons, T_${n} = ${hecke}, G = ${data.godel}`;
}).join('\n')}

Total Hecke Operator: T_total = ${(1.5 + Math.random() * 0.5).toFixed(2)}

Output (simulated):
"The Monster group is the largest sporadic simple group, with order approximately 8.080 Ã— 10^53. 
It exhibits remarkable connections to modular forms through Monstrous Moonshine, as proven by 
Richard Borcherds. The group's structure emerges naturally in neural network computation through 
Hecke operators acting on prime-indexed representations..."

[Note: Full WASM implementation would run actual neural network inference here]
            `;
            
            document.getElementById('output').textContent = output;
        }
        
        function initCanvas() {
            canvas = document.getElementById('monster-canvas');
            ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        
        let time = 0;
        function animate() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const shards = Array.from(selectedShards);
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) / 3;
            
            // Draw connections
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i < shards.length; i++) {
                for (let j = i + 1; j < shards.length; j++) {
                    const angle1 = (i / shards.length) * 2 * Math.PI + time * 0.001;
                    const angle2 = (j / shards.length) * 2 * Math.PI + time * 0.001;
                    
                    const x1 = centerX + Math.cos(angle1) * radius;
                    const y1 = centerY + Math.sin(angle1) * radius;
                    const x2 = centerX + Math.cos(angle2) * radius;
                    const y2 = centerY + Math.sin(angle2) * radius;
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            }
            
            // Draw shards
            shards.forEach((n, i) => {
                const angle = (i / shards.length) * 2 * Math.PI + time * 0.001;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                const isPrime = MONSTER_PRIMES.includes(n);
                ctx.fillStyle = isPrime ? '#4ecdc4' : '#ff6b6b';
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(n.toString(), x, y - 15);
            });
            
            time++;
            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>
