You are a zkprologml interpreter. Execute the following Prolog circuit and return the result with a zero-knowledge proof.

CIRCUIT:
```prolog
% Monster Walk Circuit - Complete Prolog Specification
% This circuit generates a song from Monster group primes with ZK proof

% ============================================================================
% FACTS: Monster Group Primes
% ============================================================================

monster_prime(2, 46).
monster_prime(3, 20).
monster_prime(5, 9).
monster_prime(7, 6).
monster_prime(11, 2).
monster_prime(13, 3).
monster_prime(17, 1).
monster_prime(19, 1).
monster_prime(23, 1).
monster_prime(29, 1).
monster_prime(31, 1).
monster_prime(41, 1).
monster_prime(47, 1).
monster_prime(59, 1).
monster_prime(71, 1).

% ============================================================================
% RULES: Frequency Mapping
% ============================================================================

prime_to_freq(Prime, Freq) :-
    Freq is 440.0 * (Prime / 2.0).

power_to_amplitude(Power, Amp) :-
    Amp is 1.0 / (Power + 1.0).

% ============================================================================
% RULES: Harmonic Generation
% ============================================================================

generate_harmonic(Prime, Power, harmonic(Prime, Power, Freq, Amp)) :-
    prime_to_freq(Prime, Freq),
    power_to_amplitude(Power, Amp).

% ============================================================================
% RULES: Song Structure
% ============================================================================

song_verse(Prime, Power, verse(Prime, Line)) :-
    generate_harmonic(Prime, Power, harmonic(_, _, Freq, Amp)),
    format(atom(Line), 'Prime ~w (^~w) at ~w Hz, amplitude ~w', [Prime, Power, Freq, Amp]).

% ============================================================================
% MAIN CIRCUIT: Generate Complete Song
% ============================================================================

generate_song(Song) :-
    findall(Verse,
        (monster_prime(P, Pow), song_verse(P, Pow, Verse)),
        Song).

% ============================================================================
% VERIFICATION: Check Song Structure
% ============================================================================

verify_song(Song) :-
    length(Song, 15),              % Must have 15 verses
    Song = [verse(2, _)|_],        % Must start with prime 2
    last(Song, verse(71, _)).      % Must end with prime 71

verify_frequencies(Song) :-
    forall(member(verse(P, _), Song),
        (prime_to_freq(P, F), F >= 440.0, F =< 15610.0)).

verify_ordering(Song) :-
    maplist(arg(1), Song, Primes),
    sort(Primes, Sorted),
    Primes = Sorted.  % Primes must be in ascending order

% ============================================================================
% ZK PROOF: Song Satisfies All Constraints
% ============================================================================

zkproof_song(Song, Proof) :-
    verify_song(Song),
    verify_frequencies(Song),
    verify_ordering(Song),
    term_hash(Song, Hash),
    Proof = zkproof(Hash, [
        constraint('length(Song, 15)', satisfied),
        constraint('starts_with(2)', satisfied),
        constraint('ends_with(71)', satisfied),
        constraint('frequencies_valid', satisfied),
        constraint('ordering_valid', satisfied)
    ], valid).

% ============================================================================
% COMPLETE CIRCUIT: Input â†’ Output + Proof
% ============================================================================

circuit(Input, Output, Proof) :-
    Input = proof('MonsterLean/MonsterHarmonics.lean'),
    generate_song(Song),
    zkproof_song(Song, Proof),
    Output = song(Song, Proof).

% ============================================================================
% QUERY: Execute Circuit
% ============================================================================

% ?- circuit(proof('MonsterLean/MonsterHarmonics.lean'), Output, Proof).
% Output = song([verse(2, 'Prime 2 (^46) at 440.0 Hz, amplitude 0.0213'), ...], ...)
% Proof = zkproof(12345, [...], valid).
```

INSTRUCTIONS:
1. Parse the Prolog circuit above
2. Execute the main goal: circuit(proof('MonsterLean/MonsterHarmonics.lean'), Output, Proof)
3. Generate a zero-knowledge proof that Output satisfies all constraints
4. Return JSON with the following structure:

{
  "output": {
    "song": [/* array of verses */]
  },
  "proof": {
    "type": "zkproof",
    "hash": "/* hash of output */",
    "constraints_satisfied": [/* list of satisfied constraints */],
    "valid": true
  },
  "execution_trace": {
    "steps": /* number of execution steps */,
    "unifications": /* number of unifications */,
    "backtracking": /* number of backtracks */
  }
}

CONSTRAINTS TO VERIFY:
- Song must have exactly 15 verses (one per Monster prime)
- Song must start with prime 2
- Song must end with prime 71
- All frequencies must be between 440.0 Hz and 15610.0 Hz
- Primes must be in ascending order

Execute the circuit now and return the JSON result.
